{"meta":{"title":"岛","subtitle":"面朝大海，春暖花开","description":"blog for LiMingHua","author":"李明华","url":"https://liminghua.gitee.io","root":"/"},"pages":[{"title":"说说","date":"2021-01-22T05:08:27.000Z","updated":"2021-01-22T05:14:23.901Z","comments":true,"path":"bb/index.html","permalink":"https://liminghua.gitee.io/bb/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-01-22T05:08:31.000Z","updated":"2021-01-22T05:16:17.139Z","comments":true,"path":"links/index.html","permalink":"https://liminghua.gitee.io/links/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-01-22T05:08:35.000Z","updated":"2021-01-22T05:16:07.220Z","comments":true,"path":"guestbook/index.html","permalink":"https://liminghua.gitee.io/guestbook/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-22T05:44:41.624Z","updated":"2021-01-22T05:44:41.624Z","comments":true,"path":"categories/index.html","permalink":"https://liminghua.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-01-22T05:44:52.926Z","updated":"2021-01-22T05:44:52.926Z","comments":true,"path":"tags/index.html","permalink":"https://liminghua.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"Gallery","date":"2020-04-17T07:31:36.046Z","updated":"2020-04-17T07:31:36.046Z","comments":true,"path":"photos/index.html","permalink":"https://liminghua.gitee.io/photos/index.html","excerpt":"","text":""},{"title":"about","date":"2020-04-17T04:48:53.000Z","updated":"2021-01-22T05:28:31.849Z","comments":true,"path":"about/index.html","permalink":"https://liminghua.gitee.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"167.两数之和II-输入有序数组","slug":"167-两数之和II-输入有序数组","date":"2021-01-22T00:52:58.000Z","updated":"2021-01-22T06:14:56.018Z","comments":true,"path":"2021/01/22/167-两数之和II-输入有序数组/","link":"","permalink":"https://liminghua.gitee.io/2021/01/22/167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"509.斐波那契数","slug":"509-斐波那契数","date":"2021-01-22T00:52:29.000Z","updated":"2021-01-22T06:15:15.075Z","comments":true,"path":"2021/01/22/509-斐波那契数/","link":"","permalink":"https://liminghua.gitee.io/2021/01/22/509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"989.数组形式的整数加法","slug":"989-数组形式的整数加法","date":"2021-01-22T00:52:08.000Z","updated":"2021-01-22T06:07:45.172Z","comments":true,"path":"2021/01/22/989-数组形式的整数加法/","link":"","permalink":"https://liminghua.gitee.io/2021/01/22/989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/","excerpt":"","text":"Q对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。 示例 1： 输入：A = [1,2,0,0], K = 34输出：[1,2,3,4]解释：1200 + 34 = 1234 示例 2： 输入：A = [2,7,4], K = 181输出：[4,5,5]解释：274 + 181 = 455 示例 3： 输入：A = [2,1,5], K = 806输出：[1,0,2,1]解释：215 + 806 = 1021 示例 4： 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1输出：[1,0,0,0,0,0,0,0,0,0,0]解释：9999999999 + 1 = 10000000000 A逐位相加12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123; List&lt;Integer&gt; rs = new ArrayList&lt;Integer&gt;(); //从个位加起（倒序遍历） for(int i = A.length -1;i&gt;=0;--i)&#123; //当前位数和 int sum = A[i]+K%10; //K的下一位 K/=10; //若当前位和大于10 下一位进一，当前和减10 if(sum&gt;=10)&#123; K++; sum-=10; &#125; //存入结果集（倒序） rs.add(sum); &#125; //若K位数大于A，处理K的进位结果 for (; K &gt; 0; K /= 10) &#123; rs.add(K % 10); &#125; //翻转结果集 Collections.reverse(rs); return rs; &#125;&#125; 时间复杂度O(max(n,logK)),其中 n 为数组的长度。 空间复杂度O(max(n,logK))。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"832.翻转图像","slug":"832-翻转图像","date":"2021-01-21T09:04:31.000Z","updated":"2021-01-22T06:15:26.504Z","comments":true,"path":"2021/01/21/832-翻转图像/","link":"","permalink":"https://liminghua.gitee.io/2021/01/21/832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/","excerpt":"","text":"Q给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 输入: [[1,1,0],[1,0,1],[0,0,0]]输出: [[1,0,0],[0,1,0],[1,1,1]]解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2: 输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] A模拟12345678910111213141516171819202122232425// class Solution &#123;// public int[][] flipAndInvertImage(int[][] A) &#123;// for(int[] line:A)&#123;// line = reverse(line);// line = Invert(line);// &#125;// &#125;// &#125;class Solution &#123; public int[][] flipAndInvertImage(int[][] A) &#123; int C = A[0].length; for (int[] row: A) //小于行的中位数，游标自增 for (int i = 0; i &lt; (C + 1) / 2; ++i) &#123; //异或1取反并翻转中位数两侧 int tmp = row[i] ^ 1; row[i] = row[C - 1 - i] ^ 1; row[C - 1 - i] = tmp; &#125; return A; &#125;&#125; 思路可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 A[i][j]，将它和 A[i][c - j - 1] 进行交换（即翻转），其中 c 是数组 A 的列数。在交换的同时，可以将这两个数进行反转。 时间复杂度O(M∗N)，其中 M 和 N 分别为数组 A 的行数和列数。 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"查询picklist所有值","slug":"查询picklist所有值","date":"2021-01-21T06:07:30.000Z","updated":"2021-01-22T06:23:26.921Z","comments":true,"path":"2021/01/21/查询picklist所有值/","link":"","permalink":"https://liminghua.gitee.io/2021/01/21/%E6%9F%A5%E8%AF%A2picklist%E6%89%80%E6%9C%89%E5%80%BC/","excerpt":"","text":"查询实体下PickList的所有value和name12345678910111213--attributename 字段名--logicalname 实体名SELECT attributevalue, value as nameFROM entity e INNER JOIN stringmap sm ON e.objecttypecode = sm.objecttypecode AND sm.attributename = &#x27;new_upkeepstation&#x27; WHERE logicalname = &#x27;incident&#x27;","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"SQL Server","slug":"SQL-Server","permalink":"https://liminghua.gitee.io/tags/SQL-Server/"},{"name":"pickList","slug":"pickList","permalink":"https://liminghua.gitee.io/tags/pickList/"}]},{"title":"219.存在重复元素II","slug":"219-存在重复元素II","date":"2021-01-21T05:55:31.000Z","updated":"2021-01-22T06:15:03.712Z","comments":true,"path":"2021/01/21/219-存在重复元素II/","link":"","permalink":"https://liminghua.gitee.io/2021/01/21/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/","excerpt":"","text":"Q给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。 示例 1: 输入: nums = [1,2,3,1], k = 3输出: true 示例 2: 输入: nums = [1,0,1,1], k = 1输出: true 示例 3: 输入: nums = [1,2,3,1,2,3], k = 2输出: false A12345678910111213141516171819202122class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; int length = nums.length; Set&lt;Integer&gt; temp = new HashSet&lt;&gt;(); for(int i = 0;i&lt;length;i++)&#123; //若temp中存在和当前元素相同的值，则满足nums [i] = nums [j]，并且i和j的差的绝对值小于等于k,返回true if(temp.contains(nums[i]))&#123; return true; &#125; //将当前元素放入temp中 temp.add(nums[i]); //若temp中的元素超过了K，即temp中最早加入的元素和最新比对的元素差的绝对值大于K，移除最早的元素 if(temp.size()&gt;k)&#123; temp.remove(nums[i - k]); &#125; &#125; return false; &#125;&#125; 思路用散列表来维护这个k大小的滑动窗口 时间复杂度O(N) n 次 搜索，删除，插入 操作，每次操作都耗费常数时间。 空间复杂度O(min(n,k)) 开辟的额外空间取决于散列表中存储的元素的个数，也就是滑动窗口的大小 O(min(n,k))。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://liminghua.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"1725.可以形成最大正方形的矩形数目","slug":"1725-可以形成最大正方形的矩形数目","date":"2021-01-21T02:07:58.000Z","updated":"2021-01-22T06:15:49.664Z","comments":true,"path":"2021/01/21/1725-可以形成最大正方形的矩形数目/","link":"","permalink":"https://liminghua.gitee.io/2021/01/21/1725-%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/","excerpt":"","text":"Q给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。 如果存在 k 同时满足 k &lt;= li 和 k &lt;= wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。 设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。 返回可以切出边长为 maxLen 的正方形的矩形 数目 。 示例 1： 输入：rectangles = [[5,8],[3,9],[5,12],[16,5]]输出：3解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。最大正方形的边长为 5 ，可以由 3 个矩形切分得到。 示例 2： 输入：rectangles = [[2,3],[3,7],[4,3],[3,7]]输出：3 A1234567891011121314151617181920class Solution &#123; public int countGoodRectangles(int[][] rectangles) &#123; int[] temp = new int[rectangles.length]; int maxLen = 0; int rs = 0; for(int i = 0;i&lt;rectangles.length;i++)&#123; temp[i] = Math.min(rectangles[i][0],rectangles[i][1]); if(temp[i]&gt;maxLen)&#123; maxLen = temp[i]; &#125; &#125; for(int j = 0;j&lt;temp.length;j++)&#123; if(temp[j]==maxLen) rs++; &#125; return rs; &#125;&#125; 思路计算结果时可以根据贪心算法优化 1234567891011121314151617class Solution &#123; public int countGoodRectangles(int[][] rectangles) &#123; int maxLen = 0, ans = 0; for (int[] rect : rectangles) &#123; int len = Math.min(rect[0], rect[1]); if (len &gt; maxLen) &#123; maxLen = len; ans = 1; &#125; else if (len == maxLen) &#123; ans++; &#125; &#125; return ans; &#125;&#125; 时间复杂度O(N) 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://liminghua.gitee.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"1588.所有奇数长度子数组的和","slug":"1588-所有奇数长度子数组的和","date":"2021-01-20T03:25:41.000Z","updated":"2021-01-22T06:15:46.250Z","comments":true,"path":"2021/01/20/1588-所有奇数长度子数组的和/","link":"","permalink":"https://liminghua.gitee.io/2021/01/20/1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/","excerpt":"","text":"Q给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。 子数组 定义为原数组中的一个连续子序列。 请你返回 arr 中 所有奇数长度子数组的和 。 示例 1： 输入：arr = [1,4,2,5,3]输出：58解释：所有奇数长度子数组和它们的和为：[1] = 1[4] = 4[2] = 2[5] = 5[3] = 3[1,4,2] = 7[4,2,5] = 11[2,5,3] = 10[1,4,2,5,3] = 15我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 示例 2： 输入：arr = [1,2]输出：3解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。 示例 3： 输入：arr = [10,11,12]输出：66 A12345678910111213class Solution &#123; public int sumOddLengthSubarrays(int[] arr) &#123; int len = arr.length, res = 0; for(int i = 0; i &lt; len; i ++)&#123; int LeftOdd = (i+1)/2, LeftEven = i/2+1; int RightOdd = (len-i)/2, RightEven = (len-1-i)/2+1; res += arr[i]*(LeftOdd*RightOdd + LeftEven*RightEven); &#125; return res; &#125;&#125; 思路没必要计算所有满足条件的数组，只需要知道每个元素会出现的次数，然后乘以其值，求和就可以得到结果 odd奇数，even偶数 对于每个元素i(数组中下标为i)来说，要构成奇数长度的子数组即 i左边的元素个数left+i本身自己一个+右边元素的个数right=奇数即 left+right=偶数 满足a+b=偶数就只有两种情况 奇数+奇数=偶数 偶数+偶数=偶数 所以只需要求得i左边可以选择奇数长度的可能有多少种，即left_odd,同样求右边奇数right_odd就可以求出策略1有多少种可能 所以只需要求得i左边可以选择偶数长度的可能有多少种，即left_odd,同样求右边偶数right_odd就可以求出策略1有多少种可能，注意0也算选择的一种可能 即元素i在所有奇数长度子数组出现的次数总和是left_oddright_odd+left_evenright_even 元素i左边元素共有i个，右边元素共有siz-i-1个 要算长度为奇数的子序列的总的数组和，则需要知道每个数字在各个长度为奇数的子数组中出现的次数，比如说1，4，2，5，3这个序列，长度为3的子序列（1，4，2）（4，2，5）（2，5，3）中，4出现了2次，2出现了3次等，所以问题的关键就变成了如何找每个数字在各个子序列中出现的次数。对于数组中的一个数字来说，它前面的数字可以出现0i-1次，它后面的数字可以出现0n-i次。要是前面的数字出现偶数次，则i后面的数字也应该出现偶数次，前面奇数次，后面同样奇数次。 时间复杂度O(N) 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"CASE/WHEN嵌套","slug":"CASE-WHEN嵌套","date":"2021-01-20T03:18:12.000Z","updated":"2021-01-22T06:27:44.124Z","comments":true,"path":"2021/01/20/CASE-WHEN嵌套/","link":"","permalink":"https://liminghua.gitee.io/2021/01/20/CASE-WHEN%E5%B5%8C%E5%A5%97/","excerpt":"","text":"供方服务交通费结算报表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758SELECT TB01.name &#x27;责任归属&#x27;, srv_order.new_vendoridName &#x27;责任供应商&#x27;,srv_order.new_name &#x27;服务信息单&#x27;,srv_order.new_productmodel_idName &#x27;产品型号&#x27;,srv_order.new_userprofile_idName &#x27;VIN码&#x27;,TB02.name &#x27;人员类型&#x27;,outline.new_stationidName &#x27;服务网点&#x27;,outline.new_srv_worker_idName &#x27;完工服务人员&#x27;,outline.new_name &#x27;派工单号&#x27;,DATEADD(HOUR, 8, outline.new_arrivetime) &#x27;到位时间&#x27;,DATEADD(HOUR, 8, outline.new_returntime) &#x27;完工时间&#x27;,ROUND(CONVERT(FLOAT,(SELECT SUM(new_srv_outsideline.new_mileage) FROM new_srv_outsideline WHERE new_srv_outsideline.new_srv_workorder_id=srv_order.new_srv_workorderid)),2) &#x27;派工公里数&#x27;,ROUND(CONVERT(FLOAT,(SELECT SUM(new_srv_outsideline.new_mileage) FROM new_srv_outsideline WHERE new_srv_outsideline.new_srv_workorder_id=srv_order.new_srv_workorderid)),2)*2*2&#x27;交通费&#x27;,CASE isnull(new_returntime,0) -- 如果完工时间为null WHEN 0 THEN ( CASE -- 到位时间也为null则返回null WHEN new_arrivetime is null THEN null -- 到位时间早7：00-晚8:00，补贴35元； WHEN CONVERT ( VARCHAR, DATEADD( HOUR, 8, outline.new_arrivetime ), 108)&lt;&#x27;20:00:00&#x27; and CONVERT ( VARCHAR, DATEADD( HOUR, 8, outline.new_arrivetime ), 108)&gt;=&#x27;07:00:00&#x27; THEN 35 -- 到位时间晚8:00--早7:00，补贴135元； ELSE 135 END ) -- 如果完工时间不为null ELSE ( CASE -- 完工时间早7：00-晚8:00，补贴35元； WHEN CONVERT ( VARCHAR, DATEADD( HOUR, 8, outline.new_returntime ), 108)&lt;&#x27;20:00:00&#x27; and CONVERT ( VARCHAR, DATEADD( HOUR, 8, outline.new_returntime ), 108)&gt;=&#x27;07:00:00&#x27; THEN 35 -- 完工时间晚8:00--早7:00，补贴135元； ELSE 135 END )END &#x27;食宿补贴&#x27;,null &#x27;交通食补总费&#x27;FROM new_srv_workorder srv_order --服务单LEFT JOIN new_srv_trouble on new_srv_trouble.new_srv_workorder_id=srv_order.new_srv_workorderidLEFT JOIN new_srv_outsideline outline ON outline.new_srv_workorder_id=srv_order.new_srv_workorderidLEFT JOIN new_srv_worker srv_worker ON srv_worker.new_srv_workerid=outline.new_srv_worker_idouter apply fn_GetPickListName(&#x27;new_srv_workorder&#x27;,&#x27;new_resp&#x27;,srv_order.new_resp) TB01outer apply fn_GetPickListName(&#x27;new_srv_worker&#x27;,&#x27;new_workertype&#x27;,srv_worker.new_workertype) TB02WHERE new_resp = 2 -- 责任归属，供应商and new_dealstatus = 11 -- 处理状态，已确认and srv_order.StateCode = 0 -- 单据可用--根据服务单确认时间筛选and CONVERT(VARCHAR, DATEADD(HOUR, 8, srv_order.new_finishtime),120)&gt;=&#x27;2020-05-11 11:44:37&#x27;and CONVERT(VARCHAR, DATEADD(HOUR, 8, srv_order.new_finishtime),120)&lt;=&#x27;2021-01-13 12:46:42&#x27;-- and CONVERT(VARCHAR, DATEADD(HOUR, 8, srv_order.new_finishtime),120)&gt;= @start-- and CONVERT(VARCHAR, DATEADD(HOUR, 8, srv_order.new_finishtime),120)&lt;= @end CASE WHEN1234567891011121314151617181920212223242526CASE isnull(new_returntime,0) -- 如果完工时间为null WHEN 0 THEN ( CASE -- 到位时间也为null则返回null WHEN new_arrivetime is null THEN null -- 到位时间早7：00-晚8:00，补贴35元； WHEN CONVERT ( VARCHAR, DATEADD( HOUR, 8, outline.new_arrivetime ), 108)&lt;&#x27;20:00:00&#x27; and CONVERT ( VARCHAR, DATEADD( HOUR, 8, outline.new_arrivetime ), 108)&gt;=&#x27;07:00:00&#x27; THEN 35 -- 到位时间晚8:00--早7:00，补贴135元； ELSE 135 END ) -- 如果完工时间不为null ELSE ( CASE -- 完工时间早7：00-晚8:00，补贴35元； WHEN CONVERT ( VARCHAR, DATEADD( HOUR, 8, outline.new_returntime ), 108)&lt;&#x27;20:00:00&#x27; and CONVERT ( VARCHAR, DATEADD( HOUR, 8, outline.new_returntime ), 108)&gt;=&#x27;07:00:00&#x27; THEN 35 -- 完工时间晚8:00--早7:00，补贴135元； ELSE 135 END )END &#x27;食宿补贴&#x27;, 嵌套内的子CASE要写 END ,不然会无法识别子case的结束点导致语法错误.","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL语法","slug":"SQL语法","permalink":"https://liminghua.gitee.io/tags/SQL%E8%AF%AD%E6%B3%95/"}]},{"title":"628.三个数的最大乘积","slug":"628-三个数的最大乘积","date":"2021-01-19T02:27:25.000Z","updated":"2021-01-22T06:15:18.800Z","comments":true,"path":"2021/01/19/628-三个数的最大乘积/","link":"","permalink":"https://liminghua.gitee.io/2021/01/19/628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","excerpt":"","text":"Q给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 示例 1: 输入: [1,2,3]输出: 6 示例 2: 输入: [1,2,3,4]输出: 24 A123456789public class Solution &#123; public int maximumProduct(int[] nums) &#123; Arrays.sort(nums); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); &#125;&#125; 排序 思路我们将数组进行升序排序，如果数组中所有的元素都是非负数，那么答案即为最后三个元素的乘积。 如果数组中出现了负数，那么我们还需要考虑乘积中包含负数的情况，显然选择最小的两个负数和最大的一个正数是最优的，即为前两个元素与最后一个元素的乘积。 上述两个结果中的较大值就是答案。注意我们可以不用判断数组中到底有没有正数，0 或者负数，因为上述两个结果实际上已经包含了所有情况，最大值一定在其中。 时间复杂度O(NlogN)，其中 NN 是数组的长度。 空间复杂度O(logN)，为排序使用的空间。 线性扫描123456789101112131415161718192021222324252627public class Solution &#123; public int maximumProduct(int[] nums) &#123; int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE; for (int n: nums) &#123; if (n &lt;= min1) &#123; min2 = min1; min1 = n; &#125; else if (n &lt;= min2) &#123; // n lies between min1 and min2 min2 = n; &#125; if (n &gt;= max1) &#123; // n is greater than max1, max2 and max3 max3 = max2; max2 = max1; max1 = n; &#125; else if (n &gt;= max2) &#123; // n lies betweeen max1 and max2 max3 = max2; max2 = n; &#125; else if (n &gt;= max3) &#123; // n lies betwen max2 and max3 max3 = n; &#125; &#125; return Math.max(min1 * min2 * max1, max1 * max2 * max3); &#125;&#125; 思路在方法一中，我们实际上只要求出数组中最大的三个数以及最小的两个数，因此我们可以不用排序，用线性扫描直接得出这五个数。min1 &lt;= min2 &lt;= max3 &lt;= max2 &lt;= max1 时间复杂度O(N) 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"977.有序数组的平方","slug":"977-有序数组的平方","date":"2021-01-19T02:26:44.000Z","updated":"2021-01-22T06:15:33.605Z","comments":true,"path":"2021/01/19/977-有序数组的平方/","link":"","permalink":"https://liminghua.gitee.io/2021/01/19/977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/","excerpt":"","text":"Q给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] A暴力12345678910111213class Solution &#123; public int[] sortedSquares(int[] A) &#123; int[] ans = new int[A.length]; for (int i = 0; i &lt; A.length; ++i) &#123; ans[i] = A[i] * A[i]; &#125; Arrays.sort(ans); return ans; &#125;&#125; 时间复杂度O(nlogn)，其中 n 是数组 A 的长度。 空间复杂度O(logn)。除了存储答案的数组以外，需要 O(logn) 的栈空间进行排序。 双指针（中位向两边）12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int[] sortedSquares(int[] A) &#123; int n = A.length; int negative = -1; //找正负数分界点点 for (int i = 0; i &lt; n; ++i) &#123; if (A[i] &lt; 0) &#123; negative = i; &#125; else &#123; break; &#125; &#125; int[] ans = new int[n]; int index = 0, i = negative, j = negative + 1; //存在负数 while (i &gt;= 0 || j &lt; n) &#123; if (i &lt; 0) &#123; //右边遍历完，j指针向左移动 ans[index] = A[j] * A[j]; ++j; &#125; else if (j == n) &#123; //左边遍历完毕，i指针向右移动 ans[index] = A[i] * A[i]; --i; &#125; else if (A[i] * A[i] &lt; A[j] * A[j]) &#123; //i指向值的平方小，存入，指针向左移动 ans[index] = A[i] * A[i]; --i; &#125; else &#123; //j指针指向值的平方小，存入，指针向右移动 ans[index] = A[j] * A[j]; ++j; &#125; //结果集指向下一位 ++index; &#125; return ans; &#125;&#125; 思路显然，如果数组 A 中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；如果数组 A 中的所有数都是负数，那么将每个数平方后，数组会保持降序。 这样一来，如果我们能够找到数组 A 中负数与非负数的分界线，那么就可以用类似「归并排序」的方法了。具体地，我们设 neg 为数组 A 中负数与非负数的分界线，也就是说，A[0] 到 A[neg] 均为负数，而 A[neg+1] 到 A[n−1] 均为非负数。当我们将数组 A 中的数平方后，那么 A[0] 到 A[neg] 单调递减，A[neg+1] 到 A[n−1] 单调递增。 由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置 neg 和 neg+1，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。 时间复杂度O(n)，其中 n 是数组 A 的长度 空间复杂度O(1) 双指针（两边至中间）1234567891011121314151617181920class Solution &#123; public int[] sortedSquares(int[] A) &#123; int n = A.length; int[] ans = new int[n]; for (int i = 0, j = n - 1, pos = n - 1; i &lt;= j;) &#123; if (A[i] * A[i] &gt; A[j] * A[j]) &#123; ans[pos] = A[i] * A[i]; ++i; &#125; else &#123; ans[pos] = A[j] * A[j]; --j; &#125; --pos; &#125; return ans; &#125;&#125; 思路同样地，可以使用两个指针分别指向位置 0 和 n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况， 时间复杂度O(n)，其中 n 是数组 A 的长度 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://liminghua.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"1550.存在连续三个奇数的数组","slug":"1550-存在连续三个奇数的数组","date":"2021-01-19T02:26:22.000Z","updated":"2021-01-22T06:15:42.926Z","comments":true,"path":"2021/01/19/1550-存在连续三个奇数的数组/","link":"","permalink":"https://liminghua.gitee.io/2021/01/19/1550-%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84/","excerpt":"","text":"Q给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。 示例 1： 输入：arr = [2,6,4,1]输出：false解释：不存在连续三个元素都是奇数的情况。 示例 2： 输入：arr = [1,2,34,3,4,5,7,23,12]输出：true解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。 A12345678910111213141516171819202122232425262728293031323334// class Solution &#123;// public boolean threeConsecutiveOdds(int[] arr) &#123;// int n = arr.length;// for (int i = 0; i &lt;= n - 3; ++i) &#123;// //a&amp;1 = 0 偶数// //a&amp;1 = 1 奇数// //任何偶数二进制第一位数必定0，而奇数必定是1，而1的二进制就是1// if ((arr[i] &amp; 1) != 0 &amp;&amp; (arr[i + 1] &amp; 1) != 0 &amp;&amp; (arr[i + 2] &amp; 1) != 0) &#123;// return true;// &#125;// &#125;// return false;// &#125;// &#125;class Solution &#123; public boolean threeConsecutiveOdds(int[] arr) &#123; LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;(); boolean result = false; for (int i : arr)&#123; if (i%2==1)&#123; temp.push(i); &#125; else &#123; temp.clear(); &#125; if (temp.size()&gt;2)&#123; result = true; &#125; &#125; return result; &#125;&#125; 思路位运算判断奇偶数 时间复杂度O(N) 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"删除文件夹没有权限","slug":"删除文件夹没有权限","date":"2021-01-18T14:44:04.000Z","updated":"2021-01-22T06:22:55.555Z","comments":true,"path":"2021/01/18/删除文件夹没有权限/","link":"","permalink":"https://liminghua.gitee.io/2021/01/18/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/","excerpt":"","text":"Question替换服务器上网站静态资源时提示：您需要来自xxx的权限才能对此文件夹进行更改 Solution移动文件夹到C盘ProgramFiles,右键删除即可。","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://liminghua.gitee.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"删除文件","slug":"删除文件","permalink":"https://liminghua.gitee.io/tags/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"},{"name":"系统权限","slug":"系统权限","permalink":"https://liminghua.gitee.io/tags/%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"}]},{"title":"17.10主要元素","slug":"17-10主要元素","date":"2021-01-18T03:24:35.000Z","updated":"2021-01-22T06:10:19.203Z","comments":true,"path":"2021/01/18/17-10主要元素/","link":"","permalink":"https://liminghua.gitee.io/2021/01/18/17-10%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/","excerpt":"","text":"Q数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。 示例 1： 输入：[1,2,5,9,5,9,5,5,5]输出：5 示例 2： 输入：[3,2]输出：-1 示例 3： 输入：[2,2,1,1,1,2,2]输出：2 说明： 你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？ A暴力123456789101112131415161718192021222324//执行用时：//21 ms, 在所有 Java 提交中击败了12.59%的用户//内存消耗：//43.9 MB, 在所有 Java 提交中击败了8.10%的用户class Solution &#123; public int majorityElement(int[] nums) &#123; int length = nums.length; HashMap&lt;Integer, Integer&gt; temp = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0;i&lt;length;i++)&#123; if(temp.get(nums[i])==null)&#123; temp.put(nums[i],1); &#125;else&#123; temp.put(nums[i],temp.get(nums[i])+1); &#125; if(temp.get(nums[i])&gt;length/2)&#123; return nums[i]; &#125; &#125; return -1; &#125;&#125; 思路遍历列表，将元素重复出现的次数放入map并进行比对,但不符合题目要求空间复杂度O(1) 时间复杂度O(N) 空间复杂度O(N) 摩尔投票算法 用时最少 执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户内存消耗：41.6 MB, 在所有 Java 提交中击败了67.28%的用户 12345678910111213141516171819202122232425262728293031323334353637383940414243//执行用时：//1 ms, 在所有 Java 提交中击败了100.00%的用户//内存消耗：//41.6 MB, 在所有 Java 提交中击败了67.28%的用户class Solution &#123; public int majorityElement(int[] nums) &#123; //记录元素出现次数 int count = 0; //temp，存放需要进行比对的上一个元素 int k = -1; for (int i = 0; i &lt; nums.length; i++) &#123; //第一个元素或者说抵消后出现的第一个元素 if(count == 0)&#123; //计数1 count = 1; //将元素值存入temp k = nums[i]; &#125;else&#123; //元素重复出现计数加1 if(k == nums[i]) ++count; //元素不重复抵消一位(减1) else --count; &#125; &#125; //若全部抵消，则不存在占比超过一半的元素 if(count == 0) return -1; //验证 else&#123; count = 0; //对元素进行计数 for (int i = 0; i &lt; nums.length; i++) &#123; if(k == nums[i]) count++; &#125; //占比超过一半 if(2 * count &gt; nums.length)&#123; return k; &#125;else return -1; &#125; &#125;&#125; 内存消耗最少 1234567891011121314151617181920212223242526272829class Solution &#123; public int majorityElement(int[] nums) &#123; int majority = -1; int count = 0; for(int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] == majority) &#123; count++; &#125; else &#123; if(count == 0) &#123; majority = nums[i]; count = 1; &#125; else &#123; count--; &#125; &#125; &#125; int a = 0; for(int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] == majority) &#123; a++; &#125; &#125; return a &gt; nums.length / 2 ? majority : -1; &#125;&#125; 思路 摩尔投票算法是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。 时间复杂度O(2N) = O(N) 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"867.转置矩阵","slug":"867-转置矩阵","date":"2021-01-17T09:01:22.000Z","updated":"2021-01-22T06:15:30.291Z","comments":true,"path":"2021/01/17/867-转置矩阵/","link":"","permalink":"https://liminghua.gitee.io/2021/01/17/867-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/","excerpt":"","text":"Q给定一个矩阵 A， 返回 A 的转置矩阵。 矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。 示例 1： 输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]] 示例 2： 输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]] A12345678910111213class Solution &#123; public int[][] transpose(int[][] A) &#123; //矩阵列，行 int R = A.length, C = A[0].length; //翻转后的新矩阵 int[][] ans = new int[C][R]; for (int r = 0; r &lt; R; ++r) for (int c = 0; c &lt; C; ++c) &#123; ans[c][r] = A[r][c]; &#125; return ans; &#125;&#125; 思路转置矩阵就是根据对角线翻转矩阵，行变成列，列变成行。（grd线性代数）尺寸为 R x C 的矩阵 A 转置后会得到尺寸为 C x R 的矩阵 ans，对此有 ans[c][r] = A[r][c]。初始化一个新的矩阵 ans 来表示答案。然后，复制矩阵的每个条目。 时间复杂度：O(R∗C)，其中 R 和 C 是给定矩阵 A 的行数和列数。 空间复杂度O(R*C)，也就是答案所使用的空间。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"矩阵","slug":"矩阵","permalink":"https://liminghua.gitee.io/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"1232.缀点成线","slug":"1232-缀点成线","date":"2021-01-17T08:33:21.000Z","updated":"2021-01-22T06:15:39.141Z","comments":true,"path":"2021/01/17/1232-缀点成线/","link":"","permalink":"https://liminghua.gitee.io/2021/01/17/1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/","excerpt":"","text":"Q在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。 请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。 示例 1： 输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]输出：true 示例 2： 输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]输出：false A123456789101112class Solution &#123; public boolean checkStraightLine(int[][] coordinates) &#123; for(int i = 1; i &lt; coordinates.length - 1; i++)&#123; int res1 = (coordinates[i][0] - coordinates[i - 1][0]) * (coordinates[i + 1][1] - coordinates[i][1]); int res2 = (coordinates[i + 1][0] - coordinates[i][0]) * (coordinates[i][1] - coordinates[i - 1][1]); if(res1 != res2)&#123; return false; &#125; &#125; return true; &#125;&#125; 1234567891011121314151617181920class Solution &#123; public boolean checkStraightLine(int[][] coordinates) &#123; int deltaX = coordinates[0][0], deltaY = coordinates[0][1]; int n = coordinates.length; for (int i = 0; i &lt; n; i++) &#123; coordinates[i][0] -= deltaX; coordinates[i][1] -= deltaY; &#125; int A = coordinates[1][1], B = -coordinates[1][0]; for (int i = 2; i &lt; n; i++) &#123; int x = coordinates[i][0], y = coordinates[i][1]; if (A * x + B * y != 0) &#123; return false; &#125; &#125; return true; &#125;&#125; 123456789101112131415161718192021class Solution &#123; public boolean checkStraightLine(int[][] coordinates) &#123; int[][] c = coordinates; //简便缩写 if(c == null) return false; //无任何点时，直线不存在 if(c.length == 1 || c.length ==2) return true; //只有一个点或者两个点时直接返回true //若在一条直线上，斜率必相等 //即(y2-y1)/(x2-x1)=(yi-y2)/(xi-x2) //当直线平行y轴时有除零风险，固交叉相乘改变为乘法 //即(y2-y1)(xi-x2)=(yi-y2)(x2-x1) for(int i = 2;i &lt; c.length;i++)&#123; if((c[1][1]-c[0][1]) * (c[i][0]-c[1][0]) == (c[i][1]-c[1][1]) * (c[1][0]-c[0][0])) &#123; continue;//斜率匹配，继续循环 &#125;else&#123; return false;//不匹配，不为直线 &#125; &#125; return true;//匹配完毕，任意节点斜率符合 &#125;&#125; 思路由斜率公式得(y1-y0)/(x1-x0)=(yi-y0)/(xi-x0)防止除0，变换成相乘的形式(y1-y0)(xi-x0)==(x1-x0)(yi-y0) 尽量避免 y1-y0/x1-x0等求斜率或者除法比较比值的操作，而换成乘法来比较，例如求y=kx+b的解析式或者题解中的方式，因为乘法的开销远小于除法 时间复杂度：O(n)，其中 n 是数组中的元素数量。 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"几何","slug":"几何","permalink":"https://liminghua.gitee.io/tags/%E5%87%A0%E4%BD%95/"},{"name":"数学","slug":"数学","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"26.删除排序数组中的重复项","slug":"26-删除排序数组中的重复项","date":"2021-01-16T01:37:45.000Z","updated":"2021-01-22T06:10:22.723Z","comments":true,"path":"2021/01/16/26-删除排序数组中的重复项/","link":"","permalink":"https://liminghua.gitee.io/2021/01/16/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"Q给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678910// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; A双（快慢）指针12345678910111213141516class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (nums.length == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.length; j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1; &#125;&#125; 思路数组完成排序后，可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，就增加 j 以跳过重复项。当遇到 nums[i] ！= nums[j] 时，跳过重复项的运行已经结束，因此必须把 nums[j] 的值复制到 nums[i + 1]。然后递增 i，接着再次重复相同的过程，直到 j 到达数组的末尾为止。 时间复杂度时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。 空间复杂度空间复杂度：O(1)。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://liminghua.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"189.旋转数组","slug":"189-旋转数组","date":"2021-01-15T06:34:34.000Z","updated":"2021-01-22T06:14:59.851Z","comments":true,"path":"2021/01/15/189-旋转数组/","link":"","permalink":"https://liminghua.gitee.io/2021/01/15/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/","excerpt":"","text":"Q给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 进阶： 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ A使用额外的数组12345678910111213141516171819202122232425262728293031323334class Solution &#123; public void rotate(int[] nums, int k) &#123; int[] temp = new int[nums.length]; if(k&lt;nums.length)&#123; for(int i=0;i&lt;k;i++)&#123; temp[i] = nums[nums.length-k+i]; &#125; System.arraycopy(nums, 0, temp, k, nums.length-k); System.arraycopy(temp, 0, nums, 0, nums.length); &#125;else if(k&gt;nums.length&amp;&amp;nums.length!=1)&#123; k=k%nums.length; for(int i=0;i&lt;k;i++)&#123; temp[i] = nums[nums.length-k+i]; &#125; System.arraycopy(nums, 0, temp, k, nums.length-k); System.arraycopy(temp, 0, nums, 0, nums.length); &#125; &#125;&#125;class Solution &#123; public void rotate(int[] nums, int k) &#123; int n = nums.length; int[] newArr = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; newArr[(i + k) % n] = nums[i]; &#125; System.arraycopy(newArr, 0, nums, 0, n); &#125;&#125; 思路使用额外的数组来将每个元素放至正确的位置。用 n 表示数组的长度，遍历原数组，将原数组下标为 i 的元素放至新数组下标为 (i+k)modn 的位置，最后将新数组拷贝至原数组即可。 时间复杂度时间复杂度：O(n)，其中 n 为数组的长度。 空间复杂度空间复杂度：O(n)。 数组翻转12345678910111213141516171819class Solution &#123; public void rotate(int[] nums, int k) &#123; k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); &#125; public void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start += 1; end -= 1; &#125; &#125;&#125; 思路该方法基于如下的事实：当我们将数组的元素向右移动 kk 次后，尾部 kmodn 个元素会移动至数组头部，其余元素向后移动 kmodn 个位置。 该方法为数组的翻转：可以先将所有元素翻转，这样尾部的 kmodn 个元素就被移至数组头部，然后再翻转 [0,kmodn−1] 区间的元素和 [kmodn,n−1] 区间的元素即能得到最后的答案。 1234567nums &#x3D; &quot;-----&gt;--&gt;&quot;; k &#x3D;3result &#x3D; &quot;--&gt;-----&gt;&quot;;reverse &quot;-----&gt;--&gt;&quot; we can get &quot;&lt;--&lt;-----&quot;reverse &quot;&lt;--&quot; we can get &quot;--&gt;&lt;-----&quot;reverse &quot;&lt;-----&quot; we can get &quot;--&gt;-----&gt;&quot;this visualization help me figure it out :) 时间复杂度：O(n)，其中 n 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)=O(n)。 空间复杂度：O(1)。 环状替换 官方解答最优解法 暂时没整明白","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"228.区间汇总","slug":"228-区间汇总","date":"2021-01-14T06:35:11.000Z","updated":"2021-01-22T06:15:07.694Z","comments":true,"path":"2021/01/14/228-区间汇总/","link":"","permalink":"https://liminghua.gitee.io/2021/01/14/228-%E5%8C%BA%E9%97%B4%E6%B1%87%E6%80%BB/","excerpt":"","text":"Q给定一个无重复元素的有序整数数组 nums 。 返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。 列表中的每个区间范围 [a,b] 应该按如下格式输出： “a-&gt;b” ，如果 a != b “a” ，如果 a == b 示例 1： 输入：nums = [0,1,2,4,5,7]输出：[“0-&gt;2”,”4-&gt;5”,”7”]解释：区间范围是：[0,2] –&gt; “0-&gt;2”[7,7] –&gt; “7”[4,5] –&gt; “4-&gt;5” 示例 2： 输入：nums = [0,2,3,4,6,8,9]输出：[“0”,”2-&gt;4”,”6”,”8-&gt;9”]解释：区间范围是：[0,0] –&gt; “0”[2,4] –&gt; “2-&gt;4”[6,6] –&gt; “6”[8,9] –&gt; “8-&gt;9” 示例 3： 输入：nums = []输出：[] 示例 4： 输入：nums = [-1]输出：[“-1”] 示例 5： 输入：nums = [0]输出：[“0”] A123456789101112131415161718192021222324class Solution &#123; public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; ret = new ArrayList&lt;String&gt;(); int i = 0; int n = nums.length; while (i &lt; n) &#123; int low = i; i++; while (i &lt; n &amp;&amp; nums[i] == nums[i - 1] + 1) &#123; i++; &#125; int high = i - 1; StringBuffer temp = new StringBuffer(Integer.toString(nums[low])); if (low &lt; high) &#123; temp.append(&quot;-&gt;&quot;); temp.append(Integer.toString(nums[high])); &#125; ret.add(temp.toString()); &#125; return ret; &#125;&#125; 一次遍历 思路 从数组的位置 0 出发，向右遍历。每次遇到相邻元素之间的差值大于 1 时，就找到了一个区间。遍历完数组之后，就能得到一系列的区间的列表。 在遍历过程中，维护下标 low 和 high 分别记录区间的起点和终点，对于任何区间都有 low≤high。当得到一个区间时，根据 low 和 high 的值生成区间的字符串表示。 当 low&lt;high 时，区间的字符串表示为 low-&gt;high； 当 low=high 时，区间的字符串表示为 low。 时间复杂度O(N) 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"283.移动零","slug":"283-移动零","date":"2021-01-14T06:34:47.000Z","updated":"2021-01-22T06:15:11.100Z","comments":true,"path":"2021/01/14/283-移动零/","link":"","permalink":"https://liminghua.gitee.io/2021/01/14/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/","excerpt":"","text":"Q给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例 1： 输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。 A双指针123456789101112131415161718192021class Solution &#123; public void moveZeroes(int[] nums) &#123; int n = nums.length, left = 0, right = 0; while (right &lt; n) &#123; if (nums[right] != 0) &#123; swap(nums, left, right); left++; &#125; right++; &#125; &#125; public void swap(int[] nums, int left, int right) &#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; &#125;&#125; 思路使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数； 右指针左边直到左指针处均为零。 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。 时间复杂度时间复杂度：O(n)，其中 n 为序列长度。每个位置至多被遍历两次。 空间复杂度空间复杂度：O(1)。只需要常数的空间存放若干变量 一次遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; public void moveZeroes(int[] nums) &#123; if(nums==null) &#123; return; &#125; //两个指针i和j int j = 0; for(int i=0;i&lt;nums.length;i++) &#123; //当前元素!=0，就把其交换到左边，等于0的交换到右边 if(nums[i]!=0) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j++] = tmp; &#125; &#125; &#125; public void moveZeroesSimple(int[] nums) &#123; //初始化双指针 //j指针用于找中间点0 int j = 0; //i指针用于找中间点右侧非0元素 for (int i = 0; i &lt; nums.length; i++) &#123; //如果两个指针指向元素均不为0，整体右移一位 if (nums[j] != 0 &amp;&amp; nums[i] != 0) &#123; j++; &#125; //如果j指针找到了中间点0，i没有找到中间点右侧非0元素 else if(nums[j]==0&amp;&amp;nums[i]==0)&#123; continue; &#125; //如果j指针找到了中间点0，i找到了中间点右侧非0元素 else if(nums[j]==0&amp;&amp;nums[i]!=0)&#123; int temp=nums[j]; nums[j]=nums[i]; nums[i]=temp; j++; &#125; &#125; &#125; //当i &gt; j 时，只需要把 i 的值赋值给j 并把原位置的值置0。同时这里也把交换操作换成了赋值操作，减少了一条操作语句，理论上能更节省时间。 public void moveZeroesAjust(int[] nums) &#123; int length; if (nums == null || (length = nums.length) == 0) &#123; return; &#125; int j = 0; for (int i = 0; i &lt; length; i++) &#123; if (nums[i] != 0) &#123; if (i &gt; j) &#123; //避免了数组开头是非零元素的交换也就是阻止（i==j）时交换 nums[j] = nums[i]; nums[i] = 0; &#125; j++; &#125; &#125; &#125; &#125; 本质是一个循环不变量：在每一次循环前，j 的左边全部都是不等于0的 起始j为0，明显满足此后每一次循环中，若nums[i] = 0，则j保持不变，满足；若nums[i] != 0，交换后j增一，仍然满足这就保证了最后结果的正确性。 时间复杂度O(N) 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://liminghua.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"CRM_WebService接口开发","slug":"CRM-WebService接口开发","date":"2021-01-12T05:42:58.000Z","updated":"2021-01-22T06:23:51.768Z","comments":true,"path":"2021/01/12/CRM-WebService接口开发/","link":"","permalink":"https://liminghua.gitee.io/2021/01/12/CRM-WebService%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/","excerpt":"","text":"WebService站点 WebService接口独立于系统之外，单独搭建一个站点，每个asmx页面即一个接口，接口请求系统中的HiddenApi 开发步骤开发Web服务项目 RekTec.CRM.WebService 项目开发站点接口页面及页面的后台请求逻辑（Web服务项目/ASMX） 1234567//QMSWebService.asmx [WebMethod(Description = &quot;转库存台账&quot;, EnableSession = true)] public string QMS_CRM_SiteReturn(string diffdate) &#123; return new QMSCommand(null).QMS_CRM_Base(diffdate,10); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//QMSCommand.cs /// &lt;summary&gt; /// QMS基础方法 /// &lt;/summary&gt; /// &lt;param name=&quot;diffdate&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string QMS_CRM_Base(string diffdate,int flag) &#123; try &#123; if (string.IsNullOrWhiteSpace(diffdate)) &#123; throw new Exception(&quot;修改时间不能为空！&quot;); &#125; var json = JsonHelper.Serialize(new &#123; diffdate &#125;); string developmentNumber = string.Empty; Dictionary&lt;string, object&gt; p = new Dictionary&lt;string, object&gt;(); switch (flag) &#123; case 1: developmentNumber = &quot;QMS_CRM_ServiceOrder&quot;; break; case 2: developmentNumber = &quot;QMS_CRM_ShipIn&quot;; break; case 3: developmentNumber = &quot;QMS_CRM_ShipOut&quot;; break; case 4: developmentNumber = &quot;QMS_CRM_Inv&quot;; break; case 5: developmentNumber = &quot;QMS_CRM_PartsReturn&quot;; break; case 6: developmentNumber = &quot;QMS_CRM_PartsShip&quot;; break; case 7: developmentNumber = &quot;QMS_CRM_BomProduct&quot;; break; case 8: developmentNumber = &quot;QMS_CRM_BomProductLine&quot;; break; case 9: developmentNumber = &quot;QMS_CRM_BomProduct&quot;; break; case 10: developmentNumber = &quot;QMS_CRM_SiteReturn&quot;; break; &#125; p.Add(&quot;DevelopmentNumber&quot;, developmentNumber); p.Add(&quot;Data&quot;, json); var result = CrmHelper.InvokeHiddenApi&lt;InterFaceReturn&gt;(OrganizationService, &quot;new_InterfaceAction&quot;, &quot;Interface/CallInterface&quot;, p, 2052); return JsonHelper.Serialize(result); &#125; catch (Exception e) &#123; Log.LogException(e); throw e; &#125; &#125; 开发HiddenApi 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt; /// 转库存台账 /// &lt;/summary&gt; /// &lt;param name=&quot;iModel&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static InterFaceReturn QMS_CRM_SiteReturn(InterFaceModel iModel) &#123; Logger _log = new Logger(); string postData = string.Empty; string BackMsg = string.Empty; var search = Helper.CommenHelper.Deserialize&lt;SiteReturnSearch&gt;(iModel.Data); InterFaceReturn iReturn = Try(() =&gt; &#123; string sql = string.Format($@&quot;select new_srv_partsapply_idName new_name, new_srv_userprofile_idName, new_number, new_product_idName, new_stocksite_receiveidName, convert(varchar,dateadd(hh,8,new_receiveddate),20) as new_receiveddate, new_quantity, new_amount, new_returnorderstatus.name as new_returnorderstatus, convert(varchar,dateadd(hh,8,createdon),20) as createdon FROM new_srv_sitereturn outer apply fn_GetPickListName(&#x27;new_srv_sitereturn&#x27;,&#x27;new_returnorderstatus&#x27;,new_returnorderstatus) new_returnorderstatus WHERE statecode = 0 and convert(varchar,dateadd(hh,8,modifiedon),23) &gt;=@diffdate &quot;); var dt = iModel.Broker.ExecuteQuery&lt;SiteReturnReturn&gt;(sql, new &#123; search.diffdate &#125;).ToList(); InterFaceReturn propriceapply = new InterFaceReturn() &#123; Flag = true, Msg = &quot;操作成功&quot;, Data = JsonConvert.SerializeObject(dt), Code = &quot;1&quot; &#125;; return propriceapply; &#125;, (ex) =&gt; &#123; return new InterFaceReturn() &#123; Flag = false, Msg = ex.Message, Data = null, Code = &quot;0&quot; &#125;; &#125;); iReturn.PostData = JsonConvert.SerializeObject(postData); return iReturn; &#125; 异常处理代码块 匿名函数，将逻辑写在代码块里，正常返回数据，报错捕捉异常 1234567891011121314151617181920212223242526272829InterFaceReturn iReturn = Try(() =&gt; &#123; string sql = string.Format($@&quot;select new_srv_partsapply_idName new_name, new_srv_userprofile_idName, new_number, new_product_idName, new_stocksite_receiveidName, convert(varchar,dateadd(hh,8,new_receiveddate),20) as new_receiveddate, new_quantity, new_amount, new_returnorderstatus.name as new_returnorderstatus, convert(varchar,dateadd(hh,8,createdon),20) as createdon FROM new_srv_sitereturn outer apply fn_GetPickListName(&#x27;new_srv_sitereturn&#x27;,&#x27;new_returnorderstatus&#x27;,new_returnorderstatus) new_returnorderstatus WHERE statecode = 0 and convert(varchar,dateadd(hh,8,modifiedon),23) &gt;=@diffdate &quot;); var dt = iModel.Broker.ExecuteQuery&lt;SiteReturnReturn&gt;(sql, new &#123; search.diffdate &#125;).ToList(); InterFaceReturn propriceapply = new InterFaceReturn() &#123; Flag = true, Msg = &quot;操作成功&quot;, Data = JsonConvert.SerializeObject(dt), Code = &quot;1&quot; &#125;; return propriceapply; &#125;, (ex) =&gt; &#123; return new InterFaceReturn() &#123; Flag = false, Msg = ex.Message, Data = null, Code = &quot;0&quot; &#125;; &#125;); 上传代码 RekTec.Crm.Workflow.InterfaceHiddenApi项目 生成dll上传至crm系统 HiddenApi RekTec.CRM.WebService 生成dll放入webservice站点bin目录 asmx页面直接放在webservice根站点目录下 配置系统中接口信息表 访问 直接访问站点下的asmx页面eg： http://10.8.32.4:8082/QMSWebService.asmx 根据页面说明的请求头使用PostMan测试","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"WebService","slug":"WebService","permalink":"https://liminghua.gitee.io/tags/WebService/"}]},{"title":"830.较大分组的位置","slug":"830-较大分组的位置","date":"2021-01-09T06:30:15.000Z","updated":"2021-01-22T06:15:22.917Z","comments":true,"path":"2021/01/09/830-较大分组的位置/","link":"","permalink":"https://liminghua.gitee.io/2021/01/09/830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"Q在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。 分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。 我们称所有包含大于或等于三个连续字符的分组为 较大分组 。 找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。 示例 1： 输入：s = “abbxxxxzzy”输出：[[3,6]]解释：”xxxx” 是一个起始于 3 且终止于 6 的较大分组。 示例 2： 输入：s = “abc”输出：[]解释：”a”,”b” 和 “c” 均不是符合要求的较大分组。 示例 3： 输入：s = “abcdddeeeeaabbbcd”输出：[[3,5],[6,9],[12,14]]解释：较大分组为 “ddd”, “eeee” 和 “bbb” 示例 4： 输入：s = “aba”输出：[] A双指针12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123; s = s + &quot;A&quot;; List&lt;List&lt;Integer&gt;&gt; answer = new ArrayList&lt;&gt;(); //指针i for(int i=0;i&lt;s.length();i++)&#123; //指针j,当指针i停留在字符串s的第i个字符位置时,移动指针j for(int j=i+1;j&lt;s.length();j++)&#123; //若出现了连续2位相等的情况 if(s.charAt(i) == s.charAt(j))&#123; //若出现了连续3位以上相等且连续有中断,记录当前i,j指针的位置,并将i指针移动到当前分组的末尾位置 if(j-i&gt;=2&amp;&amp;s.charAt(i)!=s.charAt(j+1))&#123; // List&lt;Integer&gt; group = new ArrayList&lt;&gt;(); // group.add(i); // group.add(j); answer.add(Arrays.asList(i,j)); i= j+1; &#125; &#125;else &#123; //若只是连续2位相等,移动i指针,回退j指针 i++; j--; &#125; &#125; &#125; return answer; &#125;&#125; 1234567891011121314151617class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); int i = 0, N = s.length(); // i is the start of each group for (int j = 0; j &lt; N; ++j) &#123; if (j == N-1 || s.charAt(j) != s.charAt(j+1)) &#123; //双指针法，判断条件更好更完善，不相等或者到达尾端时 // Here, [i, j] represents a group. if (j-i+1 &gt;= 3) ans.add(Arrays.asList(new Integer[]&#123;i, j&#125;)); //i从j的下一个作为起始位置，相当于固定i，用j去遍历 i = j + 1; &#125; &#125; return ans; &#125;&#125; 时间复杂度O(N(N-1)/2) N为字符串长度 空间复杂度O(1) 一次遍历1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) &#123; // 1. 初始化 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // 结果集 int n = s.length(); // 字符串长度 int num = 1; // 用于记录分组长度 // 2. 一次遍历该字符串 for(int i = 0;i &lt; n;i++)&#123; // 2.1 如果下一个字符与当前字符不同,或者已经枚举到字符串尾部,就说明当前字符为当前分组的尾部 if(i == n - 1 || s.charAt(i) != s.charAt(i + 1))&#123; if(num &gt;= 3)&#123; // 如果分组长度达到3 res.add(Arrays.asList(i - num + 1,i)); // 记录结果 &#125; num = 1; // 重置分组长度 // 2.2 字符重复的情况 &#125;else&#123; num++; // ++字符分区长度 &#125; &#125; // 3. 返回结果集 return res; &#125;&#125; 思路遍历该序列，并记录当前分组的长度。如果下一个字符与当前字符不同，或者已经枚举到字符串尾部，就说明当前字符为当前分组的尾部。每次找到当前分组的尾部时，如果该分组长度达到 3，我们就将其加入答案。 时间复杂度O(N) N为字符串长度 空间复杂度O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"postMan请求webservice接口","slug":"postMan请求webservice接口","date":"2021-01-05T05:49:36.000Z","updated":"2021-01-22T03:55:03.745Z","comments":true,"path":"2021/01/05/postMan请求webservice接口/","link":"","permalink":"https://liminghua.gitee.io/2021/01/05/postMan%E8%AF%B7%E6%B1%82webservice%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"Java WebService wsdl 使用soapUI解析wsdl 获取请求头http://10.8.32.58:9090/xgzx.crm.QMSWebService?wsdl .Net WebService asmx http://10.8.32.143:8086/QMSWebService.asmx/QMS_CRM_SiteReturn根据页面提示的请求头发起访问 Content-Length [{“key”:”Content-Length”,”value”:”19”,”description”:”用于描述HTTP消息实体的传输长度the transfer-length of the message-body”,”type”:”text”,”enabled”:true}] Transfer-Encoding [{“key”:”Transfer-Encoding”,”value”:”chunked”,”description”:”服务器没法提前知道资源的大小，或者不愿意花费资源提前计算资源大小，就会把http回复报文中加一个header叫Transfer-Encoding:chunked，就是分块传输的意思。每一块都使用固定的格式，前边是块的大小，后面是数据，然后最后一块大小是0。这样客户端解析的时候就需要注意去掉一些无用的字段。”,”type”:”text”,”enabled”:true}]","categories":[{"name":"工具","slug":"工具","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"WebService","slug":"WebService","permalink":"https://liminghua.gitee.io/tags/WebService/"}]},{"title":"soap协议","slug":"soap协议","date":"2021-01-05T05:48:49.000Z","updated":"2021-01-22T03:55:03.751Z","comments":true,"path":"2021/01/05/soap协议/","link":"","permalink":"https://liminghua.gitee.io/2021/01/05/soap%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"soap Simple Object Accrss Protocol 简单对象访问协议 SOAP是个通信协议， SOAP在HTTP协议的基础上，把编写成XML的REQUEST参数, 放在HTTP BODY上提交给WEB SERVICE服务器(SERVLET，ASP什么的) 处理完成后，结果也写成XML作为RESPONSE送回用户端， 为了使用户端和WEB SERVICE可以相互对应，可以使用WSDL作为这种通信方式的描述文件，利用WSDL工具可以自动生成WS和用户端的框架文件，SOAP具备把复杂对象序列化捆绑到XML里去的能力。 SOAP=RPC+HTTP+XML：采用HTTP作为底层通讯协议；RPC作为一致性的调用途径，ＸＭＬ作为数据传送的格式，允许服务提供者和服务客户经过防火墙在INTERNET进行通讯交互。 SOAP方式的Web服务中的Web服务描述语言（WSDL）和简单对象访问协议（SOAP）一起构成了SOAP方式下的Web服务的结构单元。客户端通过WSDL可以了解Web服务公开了那些可以被执行的方法以及Web服务可以发送或接收的消息格式（解决了公布访问资源方法的问题）。客户端按照SOAP将调用位于远程系统上的服务所需信息序列化为消息（解决了如何调用远程方法的问题）。注意WSDL描述的服务以及SOAP消息都是符合统一标准的，都是机器可读的 WSDL基于XML格式，用来描述Web服务。WSDL文档可以看成是客户端和服务器之间的一个协约。使用WSDL工具，你可以自动处理这个过程，几乎不用手工编写代码就能够让应用程序整合新的服务。因此WSDL是Web服务体系结构的基础，因为它提供了一个通用语言，用来描述服务和整合这些服务的平台。 SOAP本身提供了与Web服务交换信息的方法。SOAP是序列化调用位于远程系统上的服务所需信息的标准方法，这些信息可以使用一种远程系统能够读懂的格式通过网络发送到远程系统，而不必关心远程系统运行于何种平台或者使用何种语言编写。SOAP以XML格式提供了一个简单、轻量的用于在分散或分布环境中交换结构化和类型信息的机制。实际上它通过提供一个有标准组件的包模型和在模块中编码数据的机制，定义了一个简单的表示应用程序语义的机制。 soap请求是HTTP POST的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml任何数据都可以xml化。 rpc Remote Procedure Call 远程过程调用，简单的理解是一个节点请求另一个节点提供的服务","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"WebService","slug":"WebService","permalink":"https://liminghua.gitee.io/tags/WebService/"},{"name":"soap","slug":"soap","permalink":"https://liminghua.gitee.io/tags/soap/"}]},{"title":"1.两数之和","slug":"1-两数之和","date":"2021-01-03T01:59:20.000Z","updated":"2021-01-22T06:10:15.474Z","comments":true,"path":"2021/01/03/1-两数之和/","link":"","permalink":"https://liminghua.gitee.io/2021/01/03/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"Q给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6输出：[0,1] A123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] rs = new int[2]; ////暴力枚举 n^2 // int size = nums.length; // for(int i = 0;i&lt;size;i++)&#123; // for(int j = 0;j&lt;size;j++)&#123; // if(nums[i]+nums[j]==target &amp;&amp; i != j)&#123; // rs[0] = i; // rs[1] = j; // return rs; // &#125; // &#125; // &#125; //// 双重循环 循环极限为(n^2-n)/2 // for(int i = 0; i &lt; nums.length; i++)&#123; // for(int j = nums.length - 1; j &gt; i; j --)&#123; // if(nums[i]+nums[j] == target)&#123; // rs[0] = i; // rs[1] = j; // return rs; // &#125; // &#125; // &#125; //hash O(N) Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i = 0;i &lt; nums.length;i++)&#123; if(map.containsKey(nums[i]))&#123; rs[0] = i; rs[1] = map.get(nums[i]); return rs; &#125; // 将数据存入 key为补数 ，value为下标 map.put(target-nums[i],i); &#125; return rs; &#125;&#125; 暴力枚举 思路前两种写法都属于暴力枚举，即枚举数组中的每一个数 x，寻找数组中是否存在 target - x。第一种写法使用遍历整个数组的方式寻找 target - x 时，没有注意到每一个位于 x 之前的元素都已经和 x 匹配过，而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x，不需对前面的元素再进行匹配，由此得出第二种写法。 时间复杂度O(N^2) 空间复杂度O(1) 哈希表 思路使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。空间换时间。创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。 时间复杂度O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。 空间复杂度O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://liminghua.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"vue数组sort函数","slug":"vue数组sort函数","date":"2021-01-02T05:44:03.000Z","updated":"2021-01-22T03:55:03.756Z","comments":true,"path":"2021/01/02/vue数组sort函数/","link":"","permalink":"https://liminghua.gitee.io/2021/01/02/vue%E6%95%B0%E7%BB%84sort%E5%87%BD%E6%95%B0/","excerpt":"","text":"sort() arrayObject.sort(sortby) sortby:可选。规定排序顺序。必须是函数 返回值:对数组的引用。请注意，数组在原数组上进行排序，不生成副本 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 12345678910111213141516171819202122function sortNumber(a,b)&#123;return a - b&#125;var arr = new Array(6)arr[0] = &quot;10&quot;arr[1] = &quot;5&quot;arr[2] = &quot;40&quot;arr[3] = &quot;25&quot;arr[4] = &quot;1000&quot;arr[5] = &quot;1&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)document.write(arr.sort(sortNumber))//输出：10,5,40,25,1000,11,5,10,25,40,1000 1234567891011121314151617181920212223242526272829303132333435363738394041//时间排序正序ascSortTime(type)&#123; console.log(this.dataList[0].new_applydate) this.dataList.sort(this.ascCompareTime(type));&#125;,//时间排序倒序descSortTime(type)&#123; console.log(this.dataList[0].new_applydate) this.dataList.sort(this.descCompareTime(type));&#125;,//比较时间大小ascCompareTime(attr)&#123; return function(a,b)&#123; var val1 = a[attr]; var val2 = b[attr]; // return val2-val1; let dates1 = new Date(val1); let dates2 = new Date(val2); if (dates1 &gt; dates2) &#123; return 1 &#125; else &#123; return -1 &#125; &#125;&#125;,//比较时间大小descCompareTime(attr)&#123; return function(a,b)&#123; var val1 = a[attr]; var val2 = b[attr]; let dates1 = new Date(val1); let dates2 = new Date(val2); if (dates1 &gt; dates2) &#123; return -1 &#125; else &#123; return 1 &#125; &#125;&#125;, 数组对象其他方法 arrayObject.concat(arrayX,arrayX,……,arrayX) 用于连接两个或多个数组,该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本参数：arrayX。必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 123456789101112131415161718192021var a = [1,2,3];document.write(a.concat(4,5));//输出1,2,3,4,5var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;var arr2 = new Array(3)arr2[0] = &quot;James&quot;arr2[1] = &quot;Adrew&quot;arr2[2] = &quot;Martin&quot;document.write(arr.concat(arr2))//输出George,John,Thomas,James,Adrew,Martin arrayObject.join(separator) 用于连接两个或多个数组,该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符(separator)进行分隔的。separator:可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。 12345678910111213141516171819202122var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr.join())//输出George,John,Thomasvar arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr.join(&quot;.&quot;))//输出George.John.Thomas arrayObject.pop() pop() 方法用于删除并返回数组的最后一个元素。pop() 方法将删除 arrayObject 的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。 12345678910111213141516171819var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr)document.write(&quot;&lt;br /&gt;&quot;)document.write(arr.pop())document.write(&quot;&lt;br /&gt;&quot;)document.write(arr)George,John,ThomasThomasGeorge,John arrayObject.push(newelement1,….,newelementX) push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能 arrayObject.reverse() reverse() 方法用于颠倒数组中元素的顺序。该方法会改变原来的数组，而不会创建新的数组。 1234567891011var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)document.write(arr.reverse())//输出George,John,ThomasThomas,John,George arrayObject.shift() shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。 arrayObject.slice(start,end) slice() 方法可从已有的数组中返回选定的元素返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。可使用负值从数组的尾部选取元素。如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 12345678910111213141516var arr = new Array(6)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;arr[3] = &quot;James&quot;arr[4] = &quot;Adrew&quot;arr[5] = &quot;Martin&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)document.write(arr.slice(2,4) + &quot;&lt;br /&gt;&quot;)document.write(arr)//输出George,John,Thomas,James,Adrew,MartinThomas,JamesGeorge,John,Thomas,James,Adrew,Martin arrayObject.splice(index,howmany,item1,…..,itemX) splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。该方法会改变原始数组。index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX 可选。向数组添加的新项目。 123456789101112131415var arr = new Array(6)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;arr[3] = &quot;James&quot;arr[4] = &quot;Adrew&quot;arr[5] = &quot;Martin&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)arr.splice(2,1,&quot;William&quot;)document.write(arr)//输出George,John,Thomas,James,Adrew,MartinGeorge,John,William,James,Adrew,Martin arrayObject.toString() arrayObject 的字符串表示。返回值与没有参数的 join() 方法返回的字符串相同。数组中的元素之间用逗号分隔。 arrayObject.toLocaleString() 把数组转换为本地字符串。 对于字符串类型和toString()没有区别，只针对非字符类型bai转成字符类型时， 时间类型：toString()：转成标准格式。toLocalString()：转成本地的格式 数值类型：标准的数据型显示就是123456这种格式，但也有类似123,456这种显示方式。 123456789var date=new Date();date.toString(); //Tue Apr 12 2016 10:23:57 GMT+0800 (中国标准时间)date.toLocaleString(); //2016/4/12 上午10:23:57var n=12345670;n.toString(); //12345670n.toLocaleString(); //12,345,670 arrayObject.unshift(newelement1,newelement2,….,newelementX) unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。unshift() 方法不创建新的创建，而是直接修改原有的数组。unshift() 方法无法在 Internet Explorer 中正确地工作 newelement1 必需。向数组添加的第一个元素。newelement2 可选。向数组添加的第二个元素。newelementX 可选。可添加若干个元素。 12345678910111213var arr = new Array()arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)document.write(arr.unshift(&quot;William&quot;) + &quot;&lt;br /&gt;&quot;)document.write(arr)//输出George,John,Thomas4William,George,John,Thomas","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liminghua.gitee.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://liminghua.gitee.io/tags/js/"}]},{"title":"FetchXML查询","slug":"FetchXML查询","date":"2020-12-30T01:48:20.000Z","updated":"2021-01-22T06:23:57.199Z","comments":true,"path":"2020/12/30/FetchXML查询/","link":"","permalink":"https://liminghua.gitee.io/2020/12/30/FetchXML%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"实例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/// &lt;summary&gt; /// 获取当前服务单的回访任务fetch方式 /// &lt;/summary&gt; /// &lt;param name=&quot;id&quot;&gt;&lt;/param&gt; public List&lt;SurveyTaskModel&gt; GetSurveyTaskLine2(string id) &#123; if (string.IsNullOrWhiteSpace(id)) &#123; throw new Exception(&quot;当前服务单id丢失&quot;); &#125; string fetchXml = String.Format(@&quot;&lt;fetch mapping=&#x27;logical&#x27; version=&#x27;1.0&#x27;&gt; &lt;entity name=&#x27;new_srv_surveytask&#x27;&gt; &lt;attribute name=&#x27;new_srv_surveytaskid&#x27; /&gt; &lt;attribute name=&#x27;new_name&#x27; /&gt; &lt;attribute name=&#x27;new_result&#x27; /&gt; &lt;attribute name=&#x27;new_completecycle&#x27; /&gt; &lt;attribute name=&#x27;new_satisfactiondegree&#x27; /&gt; &lt;attribute name=&#x27;new_nosatisfiedreason&#x27; /&gt; &lt;attribute name=&#x27;new_memo&#x27; /&gt; &lt;attribute name=&#x27;new_rejectedreason&#x27; /&gt; &lt;attribute name=&#x27;new_belonguser_idname&#x27; /&gt; &lt;attribute name=&#x27;new_surveytime&#x27; /&gt; &lt;filter&gt; &lt;condition attribute=&#x27;new_srv_surveytaskid&#x27; operator=&#x27;eq&#x27; value=&#x27;&#123;0&#125;&#x27; /&gt; &lt;/filter&gt; &lt;link-entity name=&#x27;new_srv_workorder&#x27; from=&#x27;new_srv_workorderid&#x27; to=&#x27;new_srv_workorder_id&#x27; alias=&#x27;sw&#x27; link-type=&#x27;outer&#x27;&gt; &lt;attribute name=&#x27;new_srv_worker_id&#x27; /&gt; &lt;attribute name=&#x27;new_srv_worker_idname&#x27; /&gt; &lt;/link-entity&gt; &lt;/entity&gt; &lt;/fetch&gt;&quot;, id); var result = OrganizationServiceAdmin.RetrieveMultiple(new FetchExpression(fetchXml)); List&lt;SurveyTaskModel&gt; list = new List&lt;SurveyTaskModel&gt;(); foreach (var item in result.Entities) &#123; list.Add(new SurveyTaskModel &#123; //主键 id = item.GetAttributeValue&lt;Guid&gt;(&quot;new_srv_surveytaskid&quot;).ToString(), //单号 new_name new_name = item.GetAttributeValue&lt;string&gt;(&quot;new_name&quot;), //服务人员 new_srv_worker_idname new_srv_worker_idname = item.GetAttributeValue&lt;string&gt;(&quot;new_srv_worker_idname&quot;), //解决情况 new_result new_result = item.FormattedValues[&quot;new_result&quot;], //完工周期 new_completecycle new_completecycle = item.GetAttributeValue&lt;Decimal&gt;(&quot;new_completecycle&quot;).ToString(), //服务是否满意 new_satisfactiondegree new_satisfactiondegree = item.FormattedValues[&quot;new_satisfactiondegree&quot;], //不满意原因 new_nosatisfiedreason new_nosatisfiedreason = item.FormattedValues[&quot;new_nosatisfiedreason&quot;], //回访结果备注 new_memo new_memo = item.GetAttributeValue&lt;string&gt;(&quot;new_memo&quot;), //驳回原因 new_rejectedreason new_rejectedreason = item.GetAttributeValue&lt;string&gt;(&quot;new_rejectedreason&quot;), //回访坐席 new_belonguser_idname new_belonguser_idname = item.GetAttributeValue&lt;string&gt;(&quot;new_belonguser_idname&quot;), //实际回访时间 new_surveytime new_surveytime = item.GetAttributeValue&lt;DateTime&gt;(&quot;new_surveytime&quot;).ToString(), &#125;); &#125; return list; &#125; OrganizationServiceAdmin 构造函数里CreateOrganizationServiceIPortalCommandContext：调用PortalCommand时需要传入的上下文IUserIdentity：当前用户身份信息。不会包含框架级的认证类型，只含身份id. 1234567891011121314151617181920212223242526 public class WorkOrderCommand : PortalCommand &#123; IOrganizationService OrganizationServiceAdmin; protected readonly OrganizationServiceContext orgContext; //private PersisitBroker broker; XStudio.Data.PersisitBroker broker = new XStudio.Data.PersisitBroker(&quot;crm&quot;); public WorkOrderCommand(IUserIdentity identity) : base(identity) &#123; this.orgContext = new OrganizationServiceContext(OrganizationService); OrganizationServiceAdmin = CrmServiceFactory.CreateOrganizationService(Guid.Empty); &#125; public WorkOrderCommand(IPortalCommandContext portalCommandContext) : base(portalCommandContext) &#123; this.orgContext = new OrganizationServiceContext(this.OrganizationService); OrganizationServiceAdmin = CrmServiceFactory.CreateOrganizationService(Guid.Empty); &#125; protected override void Dispose(bool disposing) &#123; if (disposing) this.orgContext.Dispose(); base.Dispose(disposing); &#125; Crm.Common.Logger.Logger log = new Crm.Common.Logger.Logger();&#125; 获取picklist值1new_satisfactiondegree = item.FormattedValues[&quot;new_satisfactiondegree&quot;],","categories":[],"tags":[]},{"title":"Portal报表开发","slug":"Portal报表开发","date":"2020-12-30T01:47:32.000Z","updated":"2021-01-22T06:23:49.168Z","comments":true,"path":"2020/12/30/Portal报表开发/","link":"","permalink":"https://liminghua.gitee.io/2020/12/30/Portal%E6%8A%A5%E8%A1%A8%E5%BC%80%E5%8F%91/","excerpt":"","text":"RekTec.XStudio.ReportViewer portal端报表的dll VS Report项目中新增报表项目 报表中查询数据及绑定数据源仅用来设计并生成报表，真正需要的是生成后带有绑定数据标签的报表页面，因此报表中的字段名应与portal端赋值时的model字段名保持一致。报表完成开发后需生成报表rdl文件。 Portal端新增WEB窗体项目（aspx） 项目开发完成后生成dll并上传至bin目录，将作为后台的webapi aspx1234567891011121314151617181920&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; CodeBehind=&quot;ServiceWorkerDiary.aspx.cs&quot; Inherits=&quot;RekTec.XStudio.ReportViewer.Reports.Viewer.WebForm1&quot; %&gt;&lt;%@ Register Assembly=&quot;Microsoft.ReportViewer.WebForms, Version=14.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91&quot; Namespace=&quot;Microsoft.Reporting.WebForms&quot; TagPrefix=&quot;rsweb&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head runat=&quot;server&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;asp:ScriptManager runat=&quot;server&quot;&gt;&lt;/asp:ScriptManager&gt; &lt;rsweb:ReportViewer ID=&quot;ReportViewer1&quot; runat=&quot;server&quot; ProcessingMode=&quot;Local&quot; Width=&quot;100%&quot; SizeToReportContent=&quot;True&quot; AsyncRendering=&quot;False&quot;&gt; &lt;LocalReport&gt;&lt;/LocalReport&gt; &lt;/rsweb:ReportViewer&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ReportViewer:展现报表的时使用的一个控件。 aspx.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137using Microsoft.Reporting.WebForms;using RekTec.Crm.Common.Helper;using RekTec.Crm.Common.Logger;using RekTec.XStudio.ReportViewer.Reports.Model;using System;using System.Collections.Generic;using System.Data;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;namespace RekTec.XStudio.ReportViewer.Reports.Viewer&#123; public partial class WebForm1 : System.Web.UI.Page &#123; Logger log = new Logger(); protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; var new_worker_id = Request[&quot;id&quot;]; this.BindReportDataSource(new_worker_id); &#125; &#125; private void BindReportDataSource(string new_worker_id) &#123; var list = new List&lt;ServiceWorkerDiaryModel&gt;(); using (XStudio.Data.PersisitBroker broker = new XStudio.Data.PersisitBroker(&quot;crm&quot;)) &#123; var sql = $@&quot;SELECT new_name, new_station_idName, new_worker_idName, new_address, new_content, CONVERT(varchar(10), DATEADD(hh, 8, new_date),120) new_date, TB01.name as new_type, TB02.name as new_state, new_workorder_idName, new_traffic, new_accommodation, new_gongza, new_freight, new_service, new_maintenance, new_tolls, new_vehicle, new_instructions, TB03.name as new_isroutereal, TB04.name as new_isformreal, CONVERT(varchar(20), DATEADD(hh, 8, createdon),120) createdon FROM new_srv_dailylog OUTER APPLY fn_GetPickListNameByLang ( &#x27;new_srv_dailylog&#x27;, &#x27;new_type&#x27;, new_type, &#x27;2052&#x27; ) AS TB01 OUTER APPLY fn_GetPickListNameByLang ( &#x27;new_srv_dailylog&#x27;, &#x27;new_state&#x27;, new_state, &#x27;2052&#x27; ) AS TB02 OUTER APPLY fn_GetPickListNameByLang ( &#x27;new_srv_dailylog&#x27;, &#x27;new_isroutereal&#x27;, new_isroutereal, &#x27;2052&#x27; ) AS TB03 OUTER APPLY fn_GetPickListNameByLang ( &#x27;new_srv_dailylog&#x27;, &#x27;new_isformreal&#x27;, new_isformreal, &#x27;2052&#x27; ) AS TB04 WHERE new_worker_id =&#x27;&#123;new_worker_id&#125;&#x27; and StateCode = 0&quot;; var sql2 = @&quot;SELECT sum(new_traffic) as t_new_traffic, sum(new_accommodation) as t_new_accommodation, sum(new_gongza) as t_new_gongza, sum(new_freight) as t_new_freight, sum(new_service) as t_new_service, sum(new_maintenance) as t_new_maintenance, sum(new_tolls) as t_new_tolls, sum(new_vehicle) as t_new_vehicle, (sum(new_traffic)+sum(new_accommodation)+sum(new_gongza)+sum(new_freight)+sum(new_service)+sum(new_maintenance)+sum(new_tolls)+sum(new_vehicle)) as total FROM new_srv_dailylog WHERE new_worker_id = &#x27;&quot;+ new_worker_id+ &quot;&#x27;GROUP BY new_worker_id&quot;; var dt = broker.Query(sql); var dt2 = broker.Query(sql2); if (dt != null &amp;&amp; dt.Rows.Count &gt; 0) &#123; foreach (DataRow dr in dt.Rows) &#123; var model = new ServiceWorkerDiaryModel(); model.new_name = Cast.ConToString(dr[&quot;new_name&quot;]); model.new_station_idName = Cast.ConToString(dr[&quot;new_station_idName&quot;]); model.new_worker_idName = Cast.ConToString(dr[&quot;new_worker_idName&quot;]); model.new_type = Cast.ConToString(dr[&quot;new_type&quot;]); model.new_state = Cast.ConToString(dr[&quot;new_state&quot;]); model.new_workorder_idName = Cast.ConToString(dr[&quot;new_workorder_idName&quot;]); model.new_traffic = Cast.ConToDecimal(dr[&quot;new_traffic&quot;]).ToString(&quot;0.00&quot;); model.new_accommodation = Cast.ConToDecimal(dr[&quot;new_accommodation&quot;]).ToString(&quot;0.00&quot;); model.new_gongza = Cast.ConToDecimal(dr[&quot;new_gongza&quot;]).ToString(&quot;0.00&quot;); model.new_freight = Cast.ConToDecimal(dr[&quot;new_freight&quot;]).ToString(&quot;0.00&quot;); model.new_service = Cast.ConToDecimal(dr[&quot;new_service&quot;]).ToString(&quot;0.00&quot;); model.new_maintenance = Cast.ConToDecimal(dr[&quot;new_maintenance&quot;]).ToString(&quot;0.00&quot;); model.new_tolls = Cast.ConToDecimal(dr[&quot;new_tolls&quot;]).ToString(&quot;0.00&quot;); model.new_vehicle = Cast.ConToDecimal(dr[&quot;new_vehicle&quot;]).ToString(&quot;0.00&quot;); model.createdon = Cast.ConToString(dr[&quot;createdon&quot;]); model.new_address = Cast.ConToString(dr[&quot;new_address&quot;]); model.new_content = Cast.ConToString(dr[&quot;new_content&quot;]); model.new_date = Cast.ConToString(dr[&quot;new_date&quot;]); model.new_instructions = Cast.ConToString(dr[&quot;new_instructions&quot;]); model.new_isroutereal = Cast.ConToString(dr[&quot;new_isroutereal&quot;]); model.new_isformreal = Cast.ConToString(dr[&quot;new_isformreal&quot;]); list.Add(model); &#125; DataRow dr2 = dt2.Rows[0]; foreach (ServiceWorkerDiaryModel model in list) &#123; model.t_new_traffic = Cast.ConToDecimal(dr2[&quot;t_new_traffic&quot;]).ToString(&quot;0.00&quot;); model.t_new_accommodation = Cast.ConToDecimal(dr2[&quot;t_new_accommodation&quot;]).ToString(&quot;0.00&quot;); model.t_new_gongza = Cast.ConToDecimal(dr2[&quot;t_new_gongza&quot;]).ToString(&quot;0.00&quot;); model.t_new_freight = Cast.ConToDecimal(dr2[&quot;t_new_freight&quot;]).ToString(&quot;0.00&quot;); model.t_new_service = Cast.ConToDecimal(dr2[&quot;t_new_service&quot;]).ToString(&quot;0.00&quot;); model.t_new_maintenance = Cast.ConToDecimal(dr2[&quot;t_new_maintenance&quot;]).ToString(&quot;0.00&quot;); model.t_new_tolls = Cast.ConToDecimal(dr2[&quot;t_new_tolls&quot;]).ToString(&quot;0.00&quot;); model.t_new_vehicle = Cast.ConToDecimal(dr2[&quot;t_new_vehicle&quot;]).ToString(&quot;0.00&quot;); model.total = Cast.ConToDecimal(dr2[&quot;total&quot;]).ToString(&quot;0.00&quot;); &#125; &#125; &#125; //根据自己的实际情况去获取数据源 ReportViewer1.LocalReport.ReportPath = Server.MapPath(&quot;../ServiceWorkerDiary.rdlc&quot;);//直接引用rdlc文件 ReportViewer1.LocalReport.DataSources.Add(new ReportDataSource(&quot;DataSet1&quot;, list)); ReportViewer1.LocalReport.Refresh(); &#125; &#125;&#125; rdlc 文件：.rdlc是VS2005中报表文件的后缀名，是Report Definition Language Client的缩写，直接翻译过来可以理解为报表定义语言客户端。和rdlc同时存在的还有一个rdl，就是上面这个全程前3个单词的缩写。从SQL Server 2005开始，微软提供了一个报表服务(Reporting Service)，而rdl是指那些针对报表服务部署在服务器端的报表，而rdlc是指在本地的一些报表。也就是说我们要使用报表不一定要依赖于SQL Server的Reporting Service，而是可以自主生成一些数据源然后通过报表的方式展现出来。如果和rdl比较，rdlc可以看成是一个轻量级的报表。 上传报表文件和页面 将之前生成的rdl改名为rdlc文件并上传至服务器上相关目录（aspx.cs 代码中绑定的目录） 1ReportViewer1.LocalReport.ReportPath = Server.MapPath(&quot;../ServiceWorkerDiary.rdlc&quot;);//直接引用rdlc文件 访问服务器路径资源 http://10.8.32.143:8081/Reports/Viewer/ServiceWorkerDiary.aspx?id=C635F6B6-81EB-EA11-8ABD-005056AF9937","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"Portal","slug":"Portal","permalink":"https://liminghua.gitee.io/tags/Portal/"},{"name":"vsReport","slug":"vsReport","permalink":"https://liminghua.gitee.io/tags/vsReport/"}]},{"title":"瑞泰移动平台","slug":"瑞泰移动平台","date":"2020-12-22T06:18:59.000Z","updated":"2021-01-22T06:22:59.996Z","comments":true,"path":"2020/12/22/瑞泰移动平台/","link":"","permalink":"https://liminghua.gitee.io/2020/12/22/%E7%91%9E%E6%B3%B0%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"vue-xmobile 瑞泰移动平台http://nrm.recloud.com.cn:8081/repository/npm-hosted/ 引用yarn install vue-xmobile 常用组件","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"钉钉","slug":"钉钉","permalink":"https://liminghua.gitee.io/tags/%E9%92%89%E9%92%89/"},{"name":"vue组件","slug":"vue组件","permalink":"https://liminghua.gitee.io/tags/vue%E7%BB%84%E4%BB%B6/"}]},{"title":"关键业务表单体现vip客户","slug":"关键业务表单体现vip客户","date":"2020-12-18T07:16:12.000Z","updated":"2021-01-22T06:23:03.422Z","comments":true,"path":"2020/12/18/关键业务表单体现vip客户/","link":"","permalink":"https://liminghua.gitee.io/2020/12/18/%E5%85%B3%E9%94%AE%E4%B8%9A%E5%8A%A1%E8%A1%A8%E5%8D%95%E4%BD%93%E7%8E%B0vip%E5%AE%A2%E6%88%B7/","excerpt":"","text":"需求 销售信息、客户档案、客户分级申请单、合同、发货通知单、逾期催收和服务单 客户档案 account.js 12345 if(rtcrm(&quot;#new_accountproperty&quot;).val()==2)&#123; window.parent.document.getElementById(&quot;客户名称_label&quot;).style.backgroundColor = &quot;yellow&quot;;window.parent.document.getElementById(&quot;客户类别_label&quot;).style.backgroundColor = &quot;yellow&quot;; &#125; 销售信息 opportunity.js 12345678//根据客户名称查询客户类别，vip客户背景颜色变为黄色var id = rtcrm(&quot;#new_account_id&quot;).val()[0].id.replace(&quot;&#123;&quot;, &quot;&quot;).replace(&quot;&#125;&quot;, &quot;&quot;);var account = rtcrm.retrieve(&quot;accounts(&quot; + id + &quot;)&quot;, true);var new_accountproperty = account[&quot;new_accountproperty&quot;];if (new_accountproperty == 2) &#123; window.parent.document.getElementById(&quot;new_account_id_lookupValue&quot;).style.backgroundColor = &quot;yellow&quot;;&#125; 客户分级申请单 new_accountclassification.js 12345678var id = rtcrm(&quot;#new_account_id&quot;).val()[0].id.replace(&quot;&#123;&quot;, &quot;&quot;).replace(&quot;&#125;&quot;, &quot;&quot;);var account = rtcrm.retrieve(&quot;accounts(&quot; + id + &quot;)&quot;, true);var new_accountproperty = account[&quot;new_accountproperty&quot;];if (new_accountproperty == 2) &#123; window.parent.document.getElementById(&quot;new_account_id&quot;).style.backgroundColor = &quot;yellow&quot;; window.parent.document.getElementById(&quot;客户类别_label&quot;).style.backgroundColor = &quot;yellow&quot;;&#125; 合同申请单 new_contract.js 123456789new_enduser_id_lookupValuevar id = rtcrm(&quot;#new_enduser_id&quot;).val()[0].id.replace(&quot;&#123;&quot;, &quot;&quot;).replace(&quot;&#125;&quot;, &quot;&quot;); var account = rtcrm.retrieve(&quot;accounts(&quot; + id + &quot;)&quot;, true); var new_accountproperty = account[&quot;new_accountproperty&quot;]; if (new_accountproperty == 2) &#123; window.parent.document.getElementById(&quot;new_enduser_id_lookupValue&quot;).style.backgroundColor = &quot;yellow&quot;; &#125; 发货通知单 new_ord_shipment.js 12345678//根据最终用户查询客户类别，vip客户背景颜色变为黄色var id = rtcrm(&quot;#new_finalaccount_id&quot;).val()[0].id.replace(&quot;&#123;&quot;, &quot;&quot;).replace(&quot;&#125;&quot;, &quot;&quot;);var account = rtcrm.retrieve(&quot;accounts(&quot; + id + &quot;)&quot;, true);var new_accountproperty = account[&quot;new_accountproperty&quot;];if (new_accountproperty == 2) &#123; window.parent.document.getElementById(&quot;new_finalaccount_id&quot;).style.backgroundColor = &quot;yellow&quot;;&#125; 逾期催收 new_delaymanagement.js 123456var id = rtcrm(&quot;#new_account_id&quot;).val()[0].id.replace(&quot;&#123;&quot;, &quot;&quot;).replace(&quot;&#125;&quot;, &quot;&quot;); var account = rtcrm.retrieve(&quot;accounts(&quot; + id + &quot;)&quot;, true); var new_accountproperty = account[&quot;new_accountproperty&quot;]; if (new_accountproperty == 2) &#123; window.parent.document.getElementById(&quot;new_account_id&quot;).style.backgroundColor = &quot;yellow&quot;; &#125; 服务单 new_srv_workorder.js 12345678var id = rtcrm(&quot;#new_customerid&quot;).val()[0].id.replace(&quot;&#123;&quot;, &quot;&quot;).replace(&quot;&#125;&quot;, &quot;&quot;); var account = rtcrm.retrieve(&quot;accounts(&quot; + id + &quot;)&quot;, true); var new_accountproperty = account[&quot;new_accountproperty&quot;]; if (new_accountproperty == 2) &#123; window.parent.document.getElementById(&quot;new_customerid_lookupValue&quot;).style.backgroundColor = &quot;yellow&quot;; &#125;","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"CRM样式变更","slug":"CRM样式变更","permalink":"https://liminghua.gitee.io/tags/CRM%E6%A0%B7%E5%BC%8F%E5%8F%98%E6%9B%B4/"}]},{"title":"dll注册上传问题","slug":"dll注册上传问题","date":"2020-12-14T03:09:24.000Z","updated":"2021-01-22T06:23:54.409Z","comments":true,"path":"2020/12/14/dll注册上传问题/","link":"","permalink":"https://liminghua.gitee.io/2020/12/14/dll%E6%B3%A8%E5%86%8C%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98/","excerpt":"","text":"类文件冲突 原因是项目组同事新建了类文件没有上传，导致dll无法注册像plugin，操作，流程都会这样，原来有的类文件要有不然是注册不了的","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"踩坑","slug":"踩坑","permalink":"https://liminghua.gitee.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"督办单自定义页面","slug":"督办单自定义页面","date":"2020-12-12T01:42:06.000Z","updated":"2021-01-22T06:23:15.601Z","comments":true,"path":"2020/12/12/督办单自定义页面/","link":"","permalink":"https://liminghua.gitee.io/2020/12/12/%E7%9D%A3%E5%8A%9E%E5%8D%95%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"需求 取督办单下服务单号，根据服务单号查询对应的多条备件申请 一条服务单对应多条督办单 一条服务单对应多条备件申请 取督办单所关联的派工单号 new_dispatch_id（派工明细 new_srv_outsideline）下的其他督办单信息 备件申请单（new_srv_partsapply） 主键 new_srv_partsapplyid 备件申请单 new_name 服务单 new_srv_workerorder_id 单据类型 new_ordertype 备件名称 new_product_id 备件编码 new_number 产品型号 new_productmodel VIN码 new_srv_userprofile_id 申请数量 new_sum 发货仓库 new_stocksite_sendid 仓库编码 new_stockcode 旧件是否需返厂 new_isreturn 发运时间 new_shipmentdate 审核状态 new_approvalstatus 处理状态 new_despatch 创建时间 createdon 督办单（new_srv_supervise） 主键 new_srv_superviseid 督办单号 new_name 服务单 new_workorder_id 派工时间 new_dispatchingtime 周期 new_period 整机vin码 new_srv_product_id 产品型号 new_productmodel_id 反馈内容 new_content 服务网点 new_site_id 服务人员 new_srv_worker_id 未完工原因 new_delayreason 督办是否属实 new_superviseyn 督办备注 new_note 督办类型 new_item 单号链接思路123&lt;a href=&quot;#&quot; v-on:click.stop.prevent=&quot;showDetailWindow(item.new_srv_superviseid)&quot;&gt; &lt;span v-cloak=&quot;&quot;&gt;&#123;&#123;item.new_name&#125;&#125;&lt;/span&gt;&lt;/a&gt; 1234567showDetailWindow: function (entityid) &#123; var url &#x3D; rtcrm.getClientUrl() + &quot;&#x2F;main.aspx?etn&#x3D;&quot; + &#39;new_srv_supervise&#39; + &quot;&amp;id&#x3D;&quot; + entityid + &quot;&amp;extraqs&#x3D;&amp;histKey&#x3D;&quot; + (Math.random() * 100000000).toFixed(0) + &quot;&amp;newWindow&#x3D;true&amp;pagetype&#x3D;entityrecord&quot;; rtcrm.showFullWindow(url);&#125;, 获取entityid1var new_srv_superviseid &#x3D; window.parent.Xrm.Page.data.entity.getId().replace(&quot;&#123;&quot;,&quot;&quot;).replace(&quot;&#125;&quot;,&quot;&quot;); 请求hiddenApi12345 var paramList = &#123; new_dispatch_id: &quot;E0238A5F-8B30-EB11-8AC1-005056AF287C&quot;,new_srv_superviseid:&quot;4FE9371F-7A3F-EB11-8AC2-005056AF287C&quot; &#125;; rtcrm.invokeHiddenApi(&quot;new_service&quot;, &quot;Supervise/GetNewSrvSuperviseData&quot;, paramList);","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"自定义页面","slug":"自定义页面","permalink":"https://liminghua.gitee.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2/"}]},{"title":"发货单页面","slug":"发货单页面","date":"2020-12-11T08:33:14.000Z","updated":"2021-01-22T06:23:12.717Z","comments":true,"path":"2020/12/11/发货单页面/","link":"","permalink":"https://liminghua.gitee.io/2020/12/11/%E5%8F%91%E8%B4%A7%E5%8D%95%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"页面 移动端vue框架 vant文档 js获取url参数1234567891011//获取页面url参数getQueryVariable(variable)&#123; var query = window.location.search.substring(1); var vars = query.split(&quot;&amp;&quot;); for (var i=0;i&lt;vars.length;i++) &#123; var pair = vars[i].split(&quot;=&quot;); if(pair[0] == variable)&#123;return pair[1];&#125; &#125; return(false);&#125;, css背景图片设置body设置 缺点是只能横向充满，高度是按比例拉伸的 12345body&#123; background-image:url(test.jpg); background-repeat:no-repeat; background-size:100%;&#125; 用一个div充满整个body 缺点可想而知，网页的代码只能放在这个div里 123456&lt;body&gt;&lt;div class=&quot;background&quot;&gt; &lt;h1&gt;测试测试&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; 12345678910111213body&#123; overflow:hidden;&#125;div.background&#123; position:absolute; width:100%; height:100%; background-image:url(timg.jpg); background-repeat:no-repeat; background-size:100% 100%; &#125; 用一个img充满整个body 后面的元素都要设置定位 12345&lt;body&gt;&lt;img class=&quot;background&quot; src=&quot;timg.jpg&quot; /&gt;&lt;h1&gt;测试测试&lt;/h1&gt;&lt;/body&gt; 1234567891011121314body&#123; overflow:hidden;&#125;img.background&#123; position:absolute; width:100%; height:100%; &#125;h1&#123; position:absolute; top:0px;&#125; opacity 设置div透明度 后台AllowAnonymous 匿名头 绕过登录验证，类似注解 系统参数 自定义项中系统参数设置 123//获取系统参数string ip = CrmHelper.GetSystemParameterValue(OrganizationService, &quot;dingTalkIp&quot;);","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"自定义页面","slug":"自定义页面","permalink":"https://liminghua.gitee.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2/"},{"name":"绕过登录权限","slug":"绕过登录权限","permalink":"https://liminghua.gitee.io/tags/%E7%BB%95%E8%BF%87%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90/"}]},{"title":"portal搭建相关","slug":"portal搭建相关","date":"2020-12-11T08:18:45.000Z","updated":"2021-01-22T06:23:46.848Z","comments":true,"path":"2020/12/11/portal搭建相关/","link":"","permalink":"https://liminghua.gitee.io/2020/12/11/portal%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/","excerpt":"","text":"web api项目 解决方案下新建ASP.NET WEB应用程序（.net Framework） 右键项目发布根据所选的发布内容生成相应的目录结构portal即发布在文件夹下，由多个dll配合完成后台响应 服务器站点 将项目目录配置在站点下 事件查看器 查找bug","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"Portal","slug":"Portal","permalink":"https://liminghua.gitee.io/tags/Portal/"}]},{"title":"otto机器人","slug":"otto机器人","date":"2020-12-09T07:37:28.000Z","updated":"2021-01-22T03:55:03.743Z","comments":true,"path":"2020/12/09/otto机器人/","link":"","permalink":"https://liminghua.gitee.io/2020/12/09/otto%E6%9C%BA%E5%99%A8%E4%BA%BA/","excerpt":"","text":"功能设计 otto跳舞机器人 闹钟 声音播放 元器件 Arduino UNO esp8266 资料123456789101112131415技术群号、模块示例、学习资料，网盘等请访问我们资料官网：www.ultirobot.com 1、示例教程：网站首页 产品资料库（wiki.ultirobot.com）推荐电脑端打开布局比较清楚，示例教程上涉及到的库文件、软件、资料等都会在该教程页面的最下方有下载。 2、网盘：网盘里没有教程和示例，是一些第三方视频和电子书。两个网盘内容一样，百度网盘适合转存，但经常会有下载限速。天翼网盘下载不限速。 百度网盘（密码：s1dj ）：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1fYvqGLNf7Kxpr62bPvh9rg#list&#x2F;path&#x3D;%2F 天翼网盘（密码：soi2）：https:&#x2F;&#x2F;cloud.189.cn&#x2F;t&#x2F;E7fAnmMzymuy 3、我们微信公众号不定期会发布新教程、经验案例、优惠信息，欢迎关注。公众号名字：ultirobot 4、免费技术支持 产品使用可以参考我们网站上教程，教程做不通可以加我们技术群联系我们技术（群主）协助排查，我们技术周一到周六，9:00-17:30会在线协助解答，节假日休息。非本店售出产品一律不做支持，多谢理解。 技术交流QQ群群号：628663381，进群需要验证淘宝订单号。技术QQ：1342114269 （技术支持仅针本网站教程示例，不参与程序更改和个人项目制作。） 5、如果购买套件的客户，请参照套件内说明进行学习。 题外话：非技术支持时间，如果碰到问题，一、不要怀疑产品。二、不要怀疑教程。三、耐心细致一句一句看教程。坚持以上三点，90%的问题都可以自己排错。有问题可以随时给我们技术留言。 客户服务电话（非技术）：19951586806 批量购买、购物体验投诉均可拨打此电话。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140OTTO机器人说明书（Basic&amp;Plus）注意事项： 所有资料，跟本说明书若有冲突的，以本说明书为准。 如果你的编译器上传程序报错，检查以下方面： NANO分新旧固件，旧的编译器只能使用旧固件，请安装最新的arduino编译器，具体可以参考：http:&#x2F;&#x2F;ultirobot.com&#x2F;2019&#x2F;05&#x2F;23&#x2F;arduino-nano-bootloader-update&#x2F; 如果报错 no such file，就是缺少库文件，检查你的OTTO库文件是否已经安装。 打开设备管理器，检查CH340端口是否和你勾选的端口一致。 腿部塑料件卡不进凹槽的，可以进行略微修剪。OTTO-安装流程： OTTO-Basic基础版 1、安装软件（Arduino编译器和OTTO图形化编译器) 2、把OTTO库文件拖入arduino编译器对应库文件夹里 3、把图形化汉化文件拖入OTTO图形化编译器lang文件夹里。 4、根据视频教程组装OTTO机器人 5、用我们提供的测试程序对机器人进行测试，初步了解机器人功能。 6、根据视频教程，对OTTO进行图形化编程。 OTTO-Plus全功能版 7、用我们提供的测试程序，测试新增模块的功能、（触摸、声控、LED点阵） 8、用手机APP连接OTTO，尝试手机远程控制玩法。（蓝牙）主要模块和传感器： OTTO-Basic基础版 四个舵机：控制腿部和脚部活动 蜂鸣器：使OTTO能够发出不同的声音 超声波模块：使得OTTO可以通过眼睛来提供不同的反馈。 OTTO-Plus全功能版 包含了Basic版的所有部件，可以实现basic版的所有功能。 增加蓝牙模块，可以下载手机APP来远程控制OTTO机器人。 增加声控开关模块，可以通过外部声响来控制OTTO执行命令。 增加触摸传感器，可以通过OTTO头部触摸来执行命令。 增加点阵模块，让OTTO增加嘴部不同的表情表达。接线方式：(扩展板上所有的G都是连通的，所有的V都是连通的，可以任意接。） 舵机：（橙色线接S）面朝自己时候接线如下 右上-------- 接2号那排，注意橙色接S。 左上-------- 接3号那排，注意橙色接S。 右下-------- 接4号那排，注意橙色接S。 左下-------- 接5号那排，注意橙色接S。 蜂鸣器（模块上可以看到一个+，对应下方的线就是正极，另一根就是负极。） 正极-------- 13号S端 负极---------接G 超声波模块 VCC-------- 接V Trig-------- 接8号S端 Echo-------- 接9号S端 GND-------- 接G 声控开关模块（Plus版才有） VCC---------V GND---------G OUT---------A6号S端 触摸模块（Plus版才有） VCC（孔位10）---------V I&#x2F;O（孔位9）---------A0号S端 GND（孔位8）---------G 点阵模块（Plus版才有） VCC---------V GND---------G DIN---------A3号S端 CS---------A2号S端 CLK---------A1号S端 蓝牙模块（Plus版才有，未上传程序之前不要接。） VCC---------V GND---------G TXD---------RX RXD---------TX套件推荐使用方式： 1、DIY组装：通过大约1个小时，组装电子模块和3D打印件。 2、上传测试程序：我们会提供几个测试程序，比如跳舞程序，避障程序，用来测试功能。 3、图形化编程：我们提供OTTO专属blockly图形化编程软件，方便您进行自定义编程。 4、手机远程控制和编程（OTTO Plus版）。资料网盘介绍： 3Dprint：OTTO主体3D打印文件 3Daccessories：OTTO的配件3D模型文件 other bodies：（里面是一些非常规大小的主体模型文件） body：身体 foot：脚 head：头部 leg：腿 CAD：CAD用的文件，正常3D打印版本用不到，激光切割版本才会用到。 Code：测试代码 Alarm：测试超声波模块和蜂鸣器的接线是否正常。 All moves：测试OTTO的所有动作和声音，显示各种关节活动的测试，后面是声音配合体态的测试。 Avoid：超声波模块测试，前面没障碍物一直往前走，有障碍物后进入新的循环。 Calibration：校准程序，用来微调舵机角度。 Calibrationeasy：校准程序，用来微调舵机角度。效果和上一个程序类似。 Calibrationserial：校准程序，用来微调舵机角度。串口方式，类似Calibration。 Distance：OTTO变身测距仪 Follow：跟随，把手放在OTTO眼前，OTTO会跟着你走。 Footalign：舵机测试程序 Happybirthday：让OTTO机器人给你唱生日快乐歌 Happydance：一段跳舞程序，配合音乐表现出OTTO的快乐。 Jingle： 金哥拜,金哥拜,金哥on the way MarioBros：让OTTO演奏超级玛丽背景音 Mblock：使用Mblock软件时候需要预上传本程序 retrieve：狩猎，效果上参考follow run：OTTO快速小跑 singleladies：碧昂斯的热门金曲《单身女郎》，由OTTO配舞。 smoothcriminal：OTTO拿手好戏，演绎迈克杰克逊太空步。 SW：一段经典背景音 Driver：OTTO主控板的驱动，在电脑连接OTTO之前，需要先安装这个驱动。 Instruction manual：说明书 Arduino编译器使用说明书 OTTO组装说明书 OTTO图形化编译器使用说明书 Papercraft：贴纸，使用A4纸打印，让你的OTTO个性化十足。 Software：相关软件下载 Mixly图形化编译器及OTTO插件 arduino编译器：arduino代码程序的时候，使用该软件编译上传，也就是网盘里code这个文件夹。 Libraries_V9：OTTO库文件，在使用Arduino编译器之前需要先导入压缩包文件。 OTTO官方图形化编译器：基于google的blockly开发，适合做OTTO的教育编程。 Video：相关的教学视频 OTTO机器人国外玩家演示视频（在线播放：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1p4411Z7Ns） OTTO机器人v9组装视频（在线播放：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV15E411B7Uc&#x2F;） 注意：蜂鸣器模块视频中接了10号引脚，需要改接到13号引脚，才能在OTTO blockly正常使用。 视频中有张图片接线图是旧版的，所以新版套件中不再放置。接线方式以本文档为准。 OTTO机器人官方图形化软件使用指导（在线播放：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1K7411m7FC&#x2F;） OTTO米思奇图形化编程软件使用指导 (在线播放：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1Vb411k7Ep&#x2F;） OTTO机器人电池盒指南（在线播放：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV16E411F7qR&#x2F;） OTTO机器人V9资料介绍（在线播放：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1PE411P7Ni&#x2F;） V8和V9外壳对比区别（在线播放：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1vJ411g7R3&#x2F;） OTTO机器人Plus版本新增模块功能介绍和接线方式介绍（触摸、声控、LED点阵）（在线播放：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1hQ4y1M74z&#x2F;) OTTO机器人Plus版本新增模块功能介绍和接线方式介绍（蓝牙控制）（在线播放：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1n54y1d74A&#x2F;) Old：OTTO以前版本的老资料，提供参考，不做技术答疑。 otto-plus：Plus版本用户使用（Basic版用不到） codes：所有的basic版程序，plus用户都可以使用，并且新增了本文件夹的程序。 OttoAPP_sound_V9：使用蓝牙控制时候预先上传的程序 OttoPlus_clapdance_V9: 通过声控，来切换OTTO的不同舞蹈。 OttoPLUS_clapwalk_V9：通过声控，来控制OTTO是否向前走。 OttoPLUS_Guardian_V9：守卫模块，可以通过顶部触摸模块切换不同模式，由超声波模块来检测是否otto前方有物体经过。 OttoPLUS_stopgo_V9：LED点阵模块的测试程序 OttoPLUS_touchultrasound_V9：通过头顶触摸模块，让OTTO随机触发不同动作。 OttoPLUS_touchultrasound_V9：Plus的说明书，以我们视频教程为主，说明书辅助。 Librares：基本跟basic版的库文件一样，多了点阵模块的库。也需要拖入arduino的库文件夹。产品购买、技术支持： 购买地址一：ultirobot.taobao.com 购买地址二：zhongbest.taobao.com OTTO Club China 官方交流QQ群：812485512 微信公众号：ultirobot 技术支持QQ：1342114269 技术支持微信：ultirobot1024","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://liminghua.gitee.io/tags/Arduino/"},{"name":"DIY","slug":"DIY","permalink":"https://liminghua.gitee.io/tags/DIY/"}]},{"title":"成品车出库自动同步送车记录","slug":"成品车出库自动同步送车记录","date":"2020-12-06T09:21:44.000Z","updated":"2021-01-22T06:23:24.039Z","comments":true,"path":"2020/12/06/成品车出库自动同步送车记录/","link":"","permalink":"https://liminghua.gitee.io/2020/12/06/%E6%88%90%E5%93%81%E8%BD%A6%E5%87%BA%E5%BA%93%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E9%80%81%E8%BD%A6%E8%AE%B0%E5%BD%95/","excerpt":"","text":"场景及说明 送车记录维护目前是手工新建送车记录，为了更好的及时做到送车记录回传需要变更为根据成品车出库自动同步送车记录，后续根据实际送车需要再去维护相应的送车记录。自动同步送车记录的逻辑与随车物品发放记录自动同步类似。成品车出库制单状态的单据点击确认按钮时同步更新送车记录维护hiddenapi中入参为成品车出库id workflow VinShipOutCommand Confirm方法根据发货通知单号带出相关字段 实体信息成品车出库 new_vin_shipout new_vin_shipoutid 主键 送车记录 new_vin_sendtruckmaintain new_vin_sendtruckmaintainid 主键 new_sender 送车人 new_address 送车地点 new_shiptype 提货方式 new_producttypeid 产品组 new_shipnoticeid 提单号 new_productid 物料描述 new_vinmodelid 产品型号 new_productcode 物料编码 new_vinid 车辆vin码 new_contractid 合同号 new_new_saledepart 代表处 new_accountid 购车单位 new_senddate 送车日期 送车记录可用方法 VinSendTruckMainTainCommand VinSendTruckMainTainInfo GetInfoByVin(string vinid) 根据vin码获取信息 VinSendTruckMainTainInfo GetInfoByShipment(string shipmentid) 根据发货通知单号获取信息 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#region 同步创建送车记录维护//调用VinSendTruckMainTainCommand中GetInfoByVin获取送车记录维护字段信息VinSendTruckMainTainInfo vinSendTruckMainTainInfo = Command&lt;VinSendTruckMainTainCommand&gt;().GetInfoByVin(vinId);//创建实体var new_vin_sendtruckmaintain = new Entity(&quot;new_vin_sendtruckmaintain&quot;);//送车人（发运人实体）if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_shipperid))&#123; new_vin_sendtruckmaintain[&quot;new_sender&quot;] = new EntityReference(&quot;new_vin_shipper&quot;, new Guid(vinSendTruckMainTainInfo.new_shipperid));&#125;//送车地点if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_shipplace))&#123; new_vin_sendtruckmaintain[&quot;new_address&quot;] = vinSendTruckMainTainInfo.new_shipplace;&#125;//提货方式if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_shiptype))&#123; new_vin_sendtruckmaintain[&quot;new_shiptype&quot;] = vinSendTruckMainTainInfo.new_shiptype;&#125;//产品组if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_producttypeid))&#123; new_vin_sendtruckmaintain[&quot;new_producttypeid&quot;] = new EntityReference(&quot;new_productgroup&quot;, new Guid(vinSendTruckMainTainInfo.new_producttypeid));&#125;//提单号(发货通知单)if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_shipnoticeid))&#123; new_vin_sendtruckmaintain[&quot;new_shipnoticeid&quot;] = new EntityReference(&quot;new_ord_shipment&quot;, new Guid(vinSendTruckMainTainInfo.new_shipnoticeid));&#125;//物料描述(产品物料)if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_productid))&#123; new_vin_sendtruckmaintain[&quot;new_productid&quot;] = new EntityReference(&quot;product&quot;, new Guid(vinSendTruckMainTainInfo.new_productid));&#125;//产品型号（成品车型号）if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_vinmodelid))&#123; new_vin_sendtruckmaintain[&quot;new_vinmodelid&quot;] = new EntityReference(&quot;new_vin_productmodel&quot;, new Guid(vinSendTruckMainTainInfo.new_vinmodelid));&#125;//物料编码if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_productcode))&#123; new_vin_sendtruckmaintain[&quot;new_productcode&quot;] = vinSendTruckMainTainInfo.new_productcode;&#125;//车辆vin码（产品档案）if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_vinid))&#123; new_vin_sendtruckmaintain[&quot;new_vinid&quot;] = new EntityReference(&quot;new_srv_userprofile&quot;, new Guid(vinSendTruckMainTainInfo.new_vinid));&#125;//合同号(合同申请单)if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_contract))&#123; new_vin_sendtruckmaintain[&quot;new_contractid&quot;] = new EntityReference(&quot;new_contract&quot;, new Guid(vinSendTruckMainTainInfo.new_contract));&#125;//代表处(业务部门)if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_salebu))&#123; new_vin_sendtruckmaintain[&quot;new_new_saledepart&quot;] = new EntityReference(&quot;businessunit&quot;, new Guid(vinSendTruckMainTainInfo.new_salebu));&#125;//购车单位if (!string.IsNullOrWhiteSpace(vinSendTruckMainTainInfo.new_enduser))&#123; new_vin_sendtruckmaintain[&quot;new_accountid&quot;] = new EntityReference(&quot;account&quot;, new Guid(vinSendTruckMainTainInfo.new_enduser));&#125;//送车日期if (vinSendTruckMainTainInfo.new_shipdate != null)&#123; new_vin_sendtruckmaintain[&quot;new_senddate&quot;] = vinSendTruckMainTainInfo.new_shipdate;&#125;OrganizationService.Create(new_vin_sendtruckmaintain);#endregion bug 发货通知单查询增加校验 new_documentstatus 1 未确认 2 已确认 3 已作废","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"成品资源","slug":"成品资源","permalink":"https://liminghua.gitee.io/tags/%E6%88%90%E5%93%81%E8%B5%84%E6%BA%90/"}]},{"title":"Vue判断对象为空","slug":"Vue判断对象为空","date":"2020-12-04T06:58:34.000Z","updated":"2021-01-22T03:55:03.719Z","comments":true,"path":"2020/12/04/Vue判断对象为空/","link":"","permalink":"https://liminghua.gitee.io/2020/12/04/Vue%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%B8%BA%E7%A9%BA/","excerpt":"","text":"vue中可用JSON.stringify JSON.stringify(evtValue)==’{}’ Object Object.keys(xxx).length==0 js判断对象是否为空对象的几种方法将json对象转化为json字符串123var data = &#123;&#125;;var b = (JSON.stringify(data) == &quot;&#123;&#125;&quot;);alert(b);//true for in 循环判断12345678var obj = &#123;&#125;;var b = function() &#123;for(var key in obj) &#123;return false;&#125;return true;&#125;alert(b());//true jquery的isEmptyObject方法 此方法是jquery将for in方法进行封装，使用时需要依赖jquery 123var data = &#123;&#125;;var b = $.isEmptyObject(data);alert(b);//true Object.getOwnPropertyNames()方法 此方法是使用Object对象的getOwnPropertyNames方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的length来判断此对象是否为空.注意：此方法不兼容ie8，其余浏览器没有测试 123var data = &#123;&#125;;var arr = Object.getOwnPropertyNames(data);alert(arr.length == 0);//true 使用ES6的Object.keys()方法 与上个方法类似，是ES6的新方法, 返回值也是对象中属性名组成的数组 123var data = &#123;&#125;;var arr = Object.keys(data);alert(arr.length == 0);//true","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liminghua.gitee.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://liminghua.gitee.io/tags/js/"}]},{"title":"数据导出跟踪","slug":"数据导出跟踪","date":"2020-11-28T08:02:34.000Z","updated":"2021-01-22T06:22:48.689Z","comments":true,"path":"2020/11/28/数据导出跟踪/","link":"","permalink":"https://liminghua.gitee.io/2020/11/28/%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E8%B7%9F%E8%B8%AA/","excerpt":"","text":"说明 导出实体时对导出操作进行记录跟踪公用plugin 截图","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"系统安全","slug":"系统安全","permalink":"https://liminghua.gitee.io/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"}]},{"title":"portal发货单查询表","slug":"portal发货单查询表","date":"2020-11-26T01:17:37.000Z","updated":"2021-01-22T06:23:43.529Z","comments":true,"path":"2020/11/26/portal发货单查询表/","link":"","permalink":"https://liminghua.gitee.io/2020/11/26/portal%E5%8F%91%E8%B4%A7%E5%8D%95%E6%9F%A5%E8%AF%A2%E8%A1%A8/","excerpt":"","text":"实体 new_ord_shipment 发货通知单 new_contract_id 合同单号 new_userprofile_id 整机编号 new_contractdetail 合同产品明细 new_contract_id 合同 new_srv_userprofile 产品档案 new_srv_userprofileid new_contract 合同申请单 new_contractid 合同申请单为基础关联 字段说明 单号–发货通知单号 new_name 物料名称–合同产品明细 物料名称 new_product_id 自定义 new_product_id1 产品特殊要求–合同产品明细 产品特殊要求 new_specialrequirement 物料编码–合同产品明细 物料编码 new_code 合同单号–关联合同的 合同单号CRT（单号）new_name 自定义 new_crt_name 合同类型–关联合同（合同申请单） 合同类型 new_contracttype_id 纸质合同编号–关联合同 纸质合同号（合同申请单） new_pono 整机编号–发货通知单 整机编号 new_userprofile_id 付款条件–发货通知单 付款条件 new_ord_payment_id 产品名称–整机编号（产品档案） 产品名称 new_product_id 自定义 new_product_id2 底盘发动机号–整机编号（产品档案） 底盘发动机号（底盘发动机编码） new_enginecode 首付金额–关联合同（合同申请单） 首付金额 new_downpayments （万元） 首付金额（经销商与重型）–关联合同（合同申请单） 首付金额（经销商与重型）new_sparepartsmoney （万元） 首付比例–关联合同（合同申请单） 首付比例 new_downpaymentsrat（%） 国际贸易条款1–关联合同（合同申请单） 国际贸易条款1 new_ord_trade_id 交货地点–合同产品明细 交货地点 new_sendaddress 经销/直销–发货通知单 经销/直销 new_selltype 是否二手车–发货通知单 是否二手车 new_isold 售达方–关联合同（合同申请单） 售达方 new_customer_id 售达方管理员账号–关联合同（合同申请单） 售达方管理员账号 new_customeradmin_fddid 最终用户–关联合同（合同申请单） 最终用户 new_enduser_id 最终用户管理员账号–关联合同（合同申请单） 最终用户管理员账号（最终客户管理员账号） new_enduseradmin_fddid 详细地址–关联合同（合同申请单） 详细地址 new_address 徐工签约人–关联合同（合同申请单） 徐工签约人 new_ord_sales_id 定价–合同产品明细 定价 new_price 实际单台金额–发货通知单 实际单台金额 new_contractmoney 开单时间–发货通知单 开单时间 createdon 销售代表处–发货通知单 销售代表处 new_office_id sap合同凭证号–发货通知单 sap合同凭证号 new_sapcontractno 客户SAP编码–发货通知单 最终客户sap编码 new_finalaccountcode 最终客户后面增加，售达方管理员姓名，取值合同申请； new_customeradmin_fddname 售达方管理员姓名 最后一列增加是否代理制，取值合同申请； new_isagent 是否代理制 sql12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849SELECT sm.new_name, ctd.new_product_idName new_product_id1, ctd.new_specialrequirement, ctd.new_code, ct.new_name new_crt_name, ct.new_contracttype_idName new_contracttype_id, ct.new_pono, sm.new_userprofile_idName new_userprofile_id, sm.new_ord_payment_idName new_ord_payment_id, up.new_product_idName new_product_id2, up.new_enginecode, CAST ( CONVERT ( DECIMAL ( 18, 2 ), ct.new_downpayments ) AS VARCHAR ( 256 ) ) + &#x27;万元&#x27; new_downpayments, CAST ( CONVERT ( DECIMAL ( 18, 2 ), ct.new_sparepartsmoney ) AS VARCHAR ( 256 ) ) + &#x27;万元&#x27; new_sparepartsmoney, CAST ( CONVERT ( DECIMAL ( 18, 2 ), ct.new_downpaymentsrat ) AS VARCHAR ( 256 ) ) + &#x27;%&#x27; new_downpaymentsrat, ct.new_ord_trade_idName new_ord_trade_id, ctd.new_sendaddress, st.value AS new_selltype,CASE sm.new_isold WHEN &#x27;0&#x27; THEN &#x27;否&#x27; ELSE &#x27;是&#x27; END AS new_isold, ct.new_customer_idName new_customer_id, ct.new_customeradmin_fddid, ct.new_enduser_idName new_enduser_id, ct.new_enduseradmin_fddid, ct.new_address, ct.new_ord_sales_idName new_ord_sales_id, CAST ( CONVERT ( DECIMAL ( 18, 2 ), ctd.new_price ) AS VARCHAR ( 256 ) ) + &#x27;元&#x27; new_price, CAST ( CONVERT ( DECIMAL ( 18, 2 ), sm.new_contractmoney ) AS VARCHAR ( 256 ) ) + &#x27;元&#x27; new_contractmoney, sm.createdon, sm.new_office_idName new_office_id, sm.new_sapcontractno, sm.new_finalaccountcode FROM new_contract ct LEFT JOIN new_ord_shipment sm ON sm.new_contract_id = ct.new_contractid AND sm.statecode = 0 LEFT JOIN new_contractdetail ctd ON ctd.new_contract_id = ct.new_contractid AND ctd.statecode = 0 LEFT JOIN new_srv_userprofile up ON sm.new_userprofile_id = up.new_srv_userprofileid AND up.statecode = 0 LEFT JOIN stringmap st ON st.objecttypecode = 10205 AND st.attributename = &#x27;new_selltype&#x27; AND st.AttributeValue = sm.new_selltype WHERE ct.statecode = 0 角色过滤 基于合同申请单进行权限控制直销销售员 portal制单人 new_portalowner_id 徐工签约人 new_ord_sales_id代表处 代表处 new_office_id经销商 经销商 new_discustomer经销销售员 portal制单人 new_portalowner_idPortal 上经销商、代表处、经销销售员、直销销售员绑定部门实体类型均为account 123456789101112131415161718192021222324252627282930313233343536373839//互联用户类型var userType = UserIdentity.GetUserType();//互联用户idvar userid = UserIdentity.GetCrmUserId();//绑定部门idvar departid = UserIdentity.GetCrmDepartId();//代表处if (userType.Equals(&quot;7&quot;))&#123; //代表处等于绑定部门id(accountid)上的代表处 string param = &quot; AND ct.new_office_id = (select new_office_id FROM Account where AccountId = @dbc) &quot;; sql += param; paramList.Add(&quot;dbc&quot;, departid);&#125;//经销商else if (userType.Equals(&quot;3&quot;))&#123; //经销商等于绑定部门id(accountid) string param = &quot; AND ct.new_discustomer = @jxs &quot;; sql += param; paramList.Add(&quot;jxs&quot;, departid);&#125;//经销销售员else if (userType.Equals(&quot;6&quot;))&#123; //portal制单人等于互联用户上的绑定用户id string param = &quot; AND ct.new_portalowner_id = (select new_binduser_id FROM new_outeruser WHERE new_outeruserid = @jxxsy )&quot;; sql += param; paramList.Add(&quot;jxxsy&quot;, userid);&#125;//直销销售员else if (userType.Equals(&quot;5&quot;)) &#123; //portal制单人、徐工签约人等于互联用户上的绑定用户id string param = &quot; AND ct.new_portalowner_id = (select new_binduser_id FROM new_outeruser WHERE new_outeruserid = @zxxsy ) &quot; + &quot;or ct.new_ord_sales_id = (select new_binduser_id FROM new_outeruser WHERE new_outeruserid = @zxxsy ) &quot;; sql += param; paramList.Add(&quot;zxxsy&quot;, userid);&#125;","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"Portal","slug":"Portal","permalink":"https://liminghua.gitee.io/tags/Portal/"},{"name":"销售","slug":"销售","permalink":"https://liminghua.gitee.io/tags/%E9%94%80%E5%94%AE/"}]},{"title":"发货通知单导入按钮","slug":"发货通知单导入按钮","date":"2020-11-23T06:21:27.000Z","updated":"2021-01-22T06:23:09.912Z","comments":true,"path":"2020/11/23/发货通知单导入按钮/","link":"","permalink":"https://liminghua.gitee.io/2020/11/23/%E5%8F%91%E8%B4%A7%E9%80%9A%E7%9F%A5%E5%8D%95%E5%AF%BC%E5%85%A5%E6%8C%89%E9%92%AE/","excerpt":"","text":"导入字段整理 单号 new_name 负责人 ownerid 负责人当前账户 所属组织 new_organisation_id 徐工重型 实际单台金额 new_contractmoney 销售代表处 new_office_id 单据状态 new_documentstatus 已确认 发车类型 new_saletype TS发车 整机编号 new_userprofile_id 整机编号 客户 –取可用 物料编码 new_productcode 客户名称/售达方名称 new_account_id (客户名称/最终客户: 有编码优先编码查然后按名字 有一个必须有值) 最终客户 new_finalaccount_id 客户sap编码/售达方sap编码 new_accountno 最终客户SAP编码 new_finalaccountcode 付款条件 new_ord_payment_id导入成功后生成回款计划明细字段整理 发货通知单 new_ord_shipment_id 项次 new_seq 计划回款日期 new_plandate 计划回款金额 new_planmoney 实际已回金额 new_actualmoney备忘objecttypecode StringMap表中objecttypecode字段组织服务查询出的objecttypecode实际为entityNamesql查询出的是数字代码 CreateRequest 创建实体另一种方法是IOrganizationService.Create(Entity entity)事物的执行条数受限制 最大1000条 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//// 摘要:// Contains the data that is needed to create a record.//// 言论：// Message Availability// Not all entity types support this message offline. For some supported entities,// this message works regardless whether the caller is connected to the server or// offline. For other entities, the caller must be connected to the server before// the message works. For more information, see Supported Entities later in this// topic.// Usage// Pass an instance of this class to the Microsoft.Xrm.Sdk.IOrganizationService.Execute(Microsoft.Xrm.Sdk.OrganizationRequest)// method, which returns an instance of the Microsoft.Xrm.Sdk.Messages.CreateResponse// class.// This message supports one or more optional parameters. For more information,// see Use messages (request and response classes) with the Execute method.// Privileges and Access Rights// To perform this action, the caller must have privileges on the specified entity// in the entity parameter. For a list of the required privileges, see Create message// privileges.// Notes for Callers// This message creates a record with related records in one transaction. For a// less complex method that creates a single record, use the Microsoft.Xrm.Sdk.IOrganizationService.Create(Microsoft.Xrm.Sdk.Entity)// method.// By default, the caller becomes the owner for the new record. For this message// to work, the caller must have both Create and Read privileges for the entity.// For more information, see Privileges by entity. Or you can set the ownerid attribute// for the record to the ID of another user.// Supported Entities// You can use this method to create any record of an entity (includes custom entities)// that supports the Microsoft.Xrm.Sdk.Messages.CreateRequest message.// The following table shows the default entities that support this message. For// the listed entities of this message, the Availability column shows Server if// the caller must be connected to the server and shows Both if the caller can be// either connected to, or disconnected from, the server.[DataContract(Namespace = &quot;http://schemas.microsoft.com/xrm/2011/Contracts&quot;)]public sealed class CreateRequest : OrganizationRequest&#123; // // 摘要: // Initializes a new instance of the Microsoft.Xrm.Sdk.Messages.CreateRequest class. public CreateRequest(); // // 摘要: // Gets or sets an instance of an entity that you can use to create a new record. // Required. // // 返回结果: // Type: Microsoft.Xrm.Sdk.Entity The entity instance. // // 言论： // The specified target record must contain values for all the attributes where // the Microsoft.Xrm.Sdk.Metadata.AttributeMetadata.RequiredLevel is set to Microsoft.Xrm.Sdk.Metadata.AttributeRequiredLevel.SystemRequired. // You can see the required level value for each entity in the Entity Metadata topic // for the entity. If the entity instance includes properties where Microsoft.Xrm.Sdk.Metadata.AttributeMetadata.IsValidForCreate // is false, the values are ignored. You can find this information in the metadata // for your organization. See the preceding metadata browser information. public Entity Target &#123; get; set; &#125;&#125; 自定义导入 RekTec.Crm.Workflow.Import中创建类并继承ImportBase 1234namespace RekTec.Crm.Workflow.Import&#123; public class ImportNewOrdShipment : ImportBase &#123; 生成并上传 创建新流程 添加流程参数 ParentEntityId 字符串 可选 输入 ParentEntityName 字符串 可选 输入 ImportLogId 字符串 必需 输入 Message 字符串 可选 输出 添加步骤 分派值 选择导入类型 在数据导入中新建记录 实体名称填写要导入的实体 导入动作选择刚刚新建的流程 保存后将模板上传至导入模板 使用VisualRibbonEditor在系统中添加按钮 Action中选择$webresource:new_/js/rtcrm.min.js文件中的rtcrm.showImportWindow方法 rtcrm.showImportWindow123456789101112131415161718192021222324showImportWindow: function (entityName) &#123; /// &lt;summary&gt;弹出导入数据对话框&lt;/summary&gt; /// &lt;param name=&quot;entityName&quot; type=&quot;String&quot;&gt;实体名称&lt;/param&gt; if (RekTec.common.isNullOrWhiteSpace(entityName)) &#123; Xrm.Utility.alertDialog(&quot;entityName is not defined&quot;); return; &#125; var paramList = &quot;entityName=&quot; + entityName; if (Xrm &amp;&amp; Xrm.Page &amp;&amp; Xrm.Page.data &amp;&amp; Xrm.Page.data.entity &amp;&amp; Xrm.Page.data.entity.getId) &#123; var parentEntityName = Xrm.Page.data.entity.getEntityName(); var parentEntityId = Xrm.Page.data.entity.getId(); paramList += &quot;&amp;parentEntityName=&quot; + parentEntityName + &quot;&amp;parentEntityId=&quot; + parentEntityId; &#125; var url = RekTec.crmData.getClientUrl() + &quot;/WebResources/new_/datamanagement/Import.html?Data=&quot; + encodeURIComponent(paramList); RekTec.common.showWindow(url, &#123; width: 680, height: 620 &#125;);&#125;,","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"销售","slug":"销售","permalink":"https://liminghua.gitee.io/tags/%E9%94%80%E5%94%AE/"},{"name":"excel导入","slug":"excel导入","permalink":"https://liminghua.gitee.io/tags/excel%E5%AF%BC%E5%85%A5/"}]},{"title":"成品资源报表","slug":"成品资源报表","date":"2020-11-18T09:07:54.000Z","updated":"2021-01-22T06:23:21.351Z","comments":true,"path":"2020/11/18/成品资源报表/","link":"","permalink":"https://liminghua.gitee.io/2020/11/18/%E6%88%90%E5%93%81%E8%B5%84%E6%BA%90%E6%8A%A5%E8%A1%A8/","excerpt":"","text":"从字符串中提取数字、字母、中文123456789101112131415161718192021222324252627282930313233343536/*方法一: 一个一个找出来*/CREATE FUNCTION [dbo].[Fun_GetNumPart] ( @Str NVARCHAR(MAX) )RETURNS NVARCHAR(MAX)AS BEGIN DECLARE @Start INT; DECLARE @End INT; DECLARE @Part NVARCHAR(MAX) SET @Start = PATINDEX(&#x27;%[0-9]%&#x27;, @Str); SET @End = PATINDEX(&#x27;%[0-9]%&#x27;,SUBSTRING(@Str, @Start+1,LEN(@Str) - @Start)); SET @Part = SUBSTRING(@Str,@Start,1) WHILE @End &gt;0 BEGIN SET @Start = @start+@End SET @Part = @Part+SUBSTRING(@Str,@Start,1) SET @End = PATINDEX(&#x27;%[0-9]%&#x27;,SUBSTRING(@Str, @Start+1,LEN(@Str) - @Start)); END RETURN @Part; END; /*方法二：一个一个去掉*/CREATE FUNCTION [dbo].[Fun_GetNumPart] ( @Str NVARCHAR(MAX) ) RETURNS NVARCHAR(MAX) AS BEGIN WHILE PATINDEX(&#x27;%[^0-9]%&#x27;,@Str)&gt;0 BEGIN SET @Str=STUFF(@Str,PATINDEX(&#x27;%[^0-9]%&#x27;,@Str),1,&#x27;&#x27;) --删掉非数字的字符 END RETURN @Str END--可以通过将函数中的 ‘%[0-9]%’ 替换成 ‘%[A-Z]%’、’%[吖-做]%’，，改造成找字母、找中文的函数 Convert函数123CONVERT(data_type(length),data_to_be_converted,style)eg:CONVERT(int,dbo.Fun_GetNumPart(right(new_vinidname,8))) AS sort_vin,","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"vsReport","slug":"vsReport","permalink":"https://liminghua.gitee.io/tags/vsReport/"},{"name":"成品资源","slug":"成品资源","permalink":"https://liminghua.gitee.io/tags/%E6%88%90%E5%93%81%E8%B5%84%E6%BA%90/"}]},{"title":"发货通知单二维码","slug":"发货通知单二维码","date":"2020-11-17T05:58:51.000Z","updated":"2021-01-22T06:23:06.535Z","comments":true,"path":"2020/11/17/发货通知单二维码/","link":"","permalink":"https://liminghua.gitee.io/2020/11/17/%E5%8F%91%E8%B4%A7%E9%80%9A%E7%9F%A5%E5%8D%95%E4%BA%8C%E7%BB%B4%E7%A0%81/","excerpt":"","text":"需求 成品资源出库时使用的发货通知单中二维码信息增加：1、产品信息(物料名称) new_contractdetail_id2、合同号 (合同单号) new_contract_id3、最终客户 new_finalaccount_id4、运输方式 new_shiptype –单行文本5、产品送达地 new_shipplace –单行文本6、交货联系人 new_contact2 –单行文本 代码位置 RekTec.Crm.Workflow.Sales.ShipmentController.CreateQRCode OrganizationService.Retrieve123OrganizationService.Retrieve(&quot;new_ord_shipment&quot;, new Guid(shipmentid), new ColumnSet(new string[] &#123; &quot;new_name&quot; &#125;));Entity accountclassification = OrganizationService.Retrieve(&quot;new_accountclassification&quot;, classificationId, new ColumnSet(true));columnSet: 传入字段时为字段，传入true为所有字段，传入false只查询主键 修改字段大小 自定义项字段详情中可设置字段长度","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"销售","slug":"销售","permalink":"https://liminghua.gitee.io/tags/%E9%94%80%E5%94%AE/"},{"name":"报表","slug":"报表","permalink":"https://liminghua.gitee.io/tags/%E6%8A%A5%E8%A1%A8/"}]},{"title":"rtcrm.js常用脚本库方法解析","slug":"rtcrm-js常用脚本库方法解析","date":"2020-11-15T03:13:36.000Z","updated":"2021-01-22T06:23:33.503Z","comments":true,"path":"2020/11/15/rtcrm-js常用脚本库方法解析/","link":"","permalink":"https://liminghua.gitee.io/2020/11/15/rtcrm-js%E5%B8%B8%E7%94%A8%E8%84%9A%E6%9C%AC%E5%BA%93%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/","excerpt":"","text":"源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290/***********************************************************将Xrm对象下的常用的方法封装为 Rt对象，使用类似JQuery的Selector 方式访问 选择器，支持如 #new_name, :section #section01 ,#tab tab01 三种的选择器************************************************************/var rtcrm = function (selector) &#123; function _isNull(v) &#123; /// &lt;summary&gt;check if object null&lt;/summary&gt; /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt; /// &lt;returns type=&quot;&quot;&gt;&lt;/returns&gt; return v === null || v === undefined; &#125; function _isNullOrEmpty(v) &#123; /// &lt;summary&gt;check if stirng is null or empty&lt;/summary&gt; /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt; return _isNull(v) || v === &quot;&quot;; &#125; function _gets() &#123; /// &lt;summary&gt;根据selector返回CRM的对象数组&lt;/summary&gt; /// &lt;returns type=&quot;Array&quot;&gt;CRM对象数组&lt;/returns&gt; if (_isNullOrEmpty(selector)) return null; //将形如 #new_name,#new_date,:tab #tab01 的selector拆分逐个判断查找 var strList = selector.split(&#x27;,&#x27;); if (_isNull(strList) || strList.length == 0) return null; //要返回的UI 对象数据，包括界面上的控件、Tab、Section三种类型 var uis = []; //逐个的Selector判断 for (var i = 0; i &lt; strList.length; i++) &#123; var str = strList[i]; // # 号开头的是Id Selector if (str.charAt(0) == &quot;#&quot;) &#123; //去掉前缀 var ui = Xrm.Page.ui.controls.get(str.substring(1)); if (ui) &#123; uis[uis.length] = ui; &#125; &#125; // * 代表选择所有的界面UI控件 else if (str.charAt(0) == &quot;*&quot;) &#123; Xrm.Page.ui.controls.forEach(function (uiA) &#123; if (uiA) &#123; uis[uis.length] = uiA; &#125; &#125;); &#125; //：好开头的代表伪类，只支持 ;tab :section两种伪类 else if (str.charAt(0) == &quot;:&quot;) &#123; var tabStrList = str.split(&#x27; &#x27;); if (_isNull(tabStrList) || tabStrList.length &lt; 2 || tabStrList[1].substring(0, 1) != &quot;#&quot;) continue; var tabName = tabStrList[1].substring(1); // :tab 伪类 selector var obj = null; if (tabStrList[0] == &quot;:tab&quot;) &#123; obj = Xrm.Page.ui.tabs.get(tabName); &#125; //:section 伪类 selector else if (tabStrList[0] == &quot;:section&quot;) &#123; var tabs = Xrm.Page.ui.tabs.get(); for (var index in tabs) &#123; obj = tabs[index].sections.get(tabName); if (!_isNull(obj)) break; &#125; &#125; if (_isNull(obj)) continue; //如果Selector内容只有2个字符串，如 :tab #tab01 ,则代表选择的是tab本身 if (tabStrList.length == 2) &#123; uis[uis.length] = obj; &#125; //如果Selector内容只有3 个字符串，如 :tab #tab01 * ,代表选择tab下的所有的 控件，第三个字符串必须是 * 号 else if (tabStrList.length == 3) &#123; tabStrList[2] == &quot;*&quot; &amp;&amp; obj &amp;&amp; obj.controls &amp;&amp; obj.controls.forEach(function (uiA) &#123; uis[uis.length] = uiA; &#125;); &#125; &#125; &#125; return uis; &#125; function _each(fn) &#123; /// &lt;summary&gt;对于 选择到的所有的CRM UI元素调用 fn函数，fn函数形如： function(ui,index)&lt;/summary&gt; /// &lt;param name=&quot;fn&quot;&gt;回调函数&lt;/param&gt; var objs = _gets(); if (_isNull(objs) || objs.length == 0) return; for (var i = 0; i &lt; objs.length; i++) &#123; fn &amp;&amp; fn(objs[i], i); &#125; &#125; function _eachAttr(fn) &#123; /// &lt;summary&gt;对于 选择到的所有的CRM attribute 调用 fn函数，fn函数形如： function(attr,index)&lt;/summary&gt; /// &lt;param name=&quot;fn&quot;&gt;回调函数&lt;/param&gt; if (_isNull(fn)) return; var objs = _gets(); if (_isNull(objs) || objs.length == 0) return; for (var i = 0; i &lt; objs.length; i++) &#123; if (objs[i] &amp;&amp; objs[i].getAttribute) &#123; var attr = objs[i].getAttribute(); fn &amp;&amp; fn(attr, i); &#125; &#125; &#125; function _get(i) &#123; /// &lt;summary&gt;返回selector选择到的第 i 个UI 控件，如果i 不输入，则返回第一个&lt;/summary&gt; /// &lt;param name=&quot;i&quot;&gt;字段的索引，标识第几个字段&lt;/param&gt; // &#x27;&gt;&#x27;优先级大于&#x27;&amp;&amp;&#x27;大于&#x27;?:&#x27;,i为undefined时,undefined&gt;0返回false,undefined&amp;&amp;false为undefined,undefined?undefined:0值为0 //undefined 派生自 null，null 和 undefined 都表示空缺的值，转化为布尔值时都是假值，可以相等 //null 和 undefined 属于两种不同类型，使用全等运算符（==）或 typeof 运算符可以进行检测 //检测一个变量是否初始化，可以使用 、undefined或typeof快速检测 eg：(a == undefined) &amp;&amp; (a = 0);(typeof a == &quot;undefined&quot;) &amp;&amp; (a = 0); var index = i &amp;&amp; i &gt; 0 ? i : 0; var objs = _gets(); //若为只传一个页面字段的情况下,如rtcrm(#new_name),则此时objs中只有一个boj为&quot;Xrm.Page.ui.controls.get(&#x27;new_name&#x27;);&quot;,obj.length&gt;index为true,objs&amp;&amp;1为1,1&amp;&amp;true为true //则表达式结果为objs[0] return objs &amp;&amp; objs.length &amp;&amp; objs.length &gt; index ? objs[index] : null; &#125; function _getAttr() &#123; /// &lt;summary&gt;返回selector选择到的第 1 个attribute &lt;/summary&gt; var obj = _get(); return obj &amp;&amp; obj.getAttribute ? obj.getAttribute() : null; &#125; function _val(v) &#123; /// &lt;summary&gt;获取字段的值，或者设定字段的值&lt;/summary&gt; /// &lt;param name=&quot;v&quot; type=&quot;Object&quot;&gt;如果v==undifined，则为获取字段的值，否则为设定字段的值&lt;/param&gt; var attr = _getAttr(); if (_isNull(attr)) return null; if (v === undefined) return attr.getValue ? attr.getValue() : null; else return attr.setValue ? attr.setValue(v) : null; &#125; function _text() &#123; /// &lt;summary&gt;获取CRM的字段的文本表示&lt;/summary&gt; var attr = _getAttr(); return attr &amp;&amp; attr.getText ? attr.getText() : null; &#125; function _req(v) &#123; /// &lt;summary&gt;获取或设定字段的Requie Level，none、&lt;/summary&gt; /// &lt;param name=&quot;v&quot;&gt;none，required，recommended&lt;/param&gt; if (_isNullOrEmpty(v)) &#123; var attr = _getAttr(); return attr &amp;&amp; attr.getRequiredLevel ? attr.getRequiredLevel() : null; &#125; else &#123; _eachAttr(function (attribute) &#123; attribute &amp;&amp; attribute.setRequiredLevel &amp;&amp; attribute.setRequiredLevel(v); &#125;); return v; &#125; &#125; function _length() &#123; /// &lt;summary&gt;返回选择器选择到的UI控件的个数&lt;/summary&gt; var objs = _gets(); if (_isNull(objs)) return 0; return objs.length; &#125; function _attrType() &#123; /// &lt;summary&gt;字段的属性类别&lt;/summary&gt; /// &lt;returns type=&quot;String&quot;&gt;&lt;/returns&gt; var attr = _getAttr(); return attr &amp;&amp; attr.getAttributeType ? attr.getAttributeType() : null; &#125; function _fire() &#123; /// &lt;summary&gt;调用字段的 fireOnChange&lt;/summary&gt; var attr = _getAttr(); attr &amp;&amp; attr.fireOnChange &amp;&amp; attr.fireOnChange(); &#125; function _isDirty() &#123; /// &lt;summary&gt;检查界面上的字段的值是否发生改变了&lt;/summary&gt; /// &lt;returns type=&quot;Boolean&quot;&gt;&lt;/returns&gt; var attr = _getAttr(); return attr &amp;&amp; attr.getIsDirty ? attr.getIsDirty() : Xrm.Page.data.entity.getIsDirty(); &#125; function _submitMode(v) &#123; /// &lt;summary&gt;设定或者获取属性的SubmitMode&lt;/summary&gt; /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt; /// &lt;returns type=&quot;&quot;&gt;&lt;/returns&gt; if (_isNullOrEmpty(v)) &#123; var attr = _getAttr(); return attr &amp;&amp; attr.getSubmitMode ? attr.getSubmitMode() : null; &#125; else &#123; _eachAttr(function (attribute) &#123; attribute &amp;&amp; attribute.setSubmitMode &amp;&amp; attribute.setSubmitMode(v); &#125;); return v; &#125; &#125; function _disabled(v) &#123; /// &lt;summary&gt;设定或获取UI控件是否禁用&lt;/summary&gt; /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt; /// &lt;returns type=&quot;&quot;&gt;&lt;/returns&gt; if (_isNull(v)) &#123; var obj = _get(); return obj &amp;&amp; obj.getDisabled ? obj.getDisabled() : false; &#125; else &#123; _each(function (ui) &#123; var controlType = ui.getControlType(); if (controlType != &quot;iframe&quot; &amp;&amp; controlType != &quot;webresource&quot; &amp;&amp; controlType != &quot;subgrid&quot; &amp;&amp; controlType != &quot;searchwidget&quot; &amp;&amp; controlType != &quot;kbsearch&quot;) ui &amp;&amp; ui.setDisabled &amp;&amp; ui.setDisabled(v); &#125;); return v; &#125; &#125; function _visible(v) &#123; /// &lt;summary&gt;设定或获取UI控件是否可视&lt;/summary&gt; /// &lt;param name=&quot;v&quot;&gt;&lt;/param&gt; /// &lt;returns type=&quot;&quot;&gt;&lt;/returns&gt; if (_isNull(v)) &#123; var obj = _get(); return obj &amp;&amp; obj.getVisible ? obj.getVisible() : false; &#125; else &#123; _each(function (ui) &#123; ui &amp;&amp; ui.setVisible &amp;&amp; ui.setVisible(v); &#125;); return v; &#125; &#125; function _hide() &#123; /// &lt;summary&gt; /// 隐藏界面UI控件 /// &lt;/summary&gt; _visible(false); &#125; function _show() &#123; /// &lt;summary&gt; ///显示字段或其他的UI控件 /// &lt;/summary&gt; _visible(true); &#125; function _focus() &#123; /// &lt;summary&gt; ///设定控件获取输入焦点 /// &lt;/summary&gt; var obj = _get(); obj &amp;&amp; obj.setFocus &amp;&amp; obj.setFocus(); &#125; return &#123; get: _get, getAttr: _getAttr, val: _val, text: _text, req: _req, focus: _focus, each: _each, eachAttr: _eachAttr, length: _length, attrType: _attrType, fire: _fire, isDirty: _isDirty, submitMode: _submitMode, disabled: _disabled, visible: _visible, hide: _hide, show: _show &#125;;&#125;; 常用方法val() rtcrm(“#new_name”).val();获取new_name字段的值 123456//找到表单上一个对象,_gets()、_get()方法Xrm.Page.ui.controls.get(&quot;new_account_id&quot;);//获取属性,_getAttr()方法Xrm.Page.ui.controls.get(&quot;new_account_id&quot;).getAttribute();//获取值,_val(v)方法Xrm.Page.ui.controls.get(&quot;new_account_id&quot;).getAttribute().getValue(); 便捷的写法 12//直接获取字段Xrm.Page.getAttribute(&quot;new_account_id&quot;).getValue() getEntityId() rtcrm.getEntityId(); “{30FEBF82-0440-EB11-8AC1-005056AF9937}”Xrm.Page.data.entity.getId() 1var new_srv_superviseid &#x3D; window.parent.Xrm.Page.data.entity.getId().replace(&quot;&#123;&quot;,&quot;&quot;).replace(&quot;&#125;&quot;,&quot;&quot;);","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"瑞泰框架","slug":"瑞泰框架","permalink":"https://liminghua.gitee.io/tags/%E7%91%9E%E6%B3%B0%E6%A1%86%E6%9E%B6/"},{"name":"rtcrm.js","slug":"rtcrm-js","permalink":"https://liminghua.gitee.io/tags/rtcrm-js/"}]},{"title":"报表翻页保留静态标题","slug":"报表翻页保留静态标题","date":"2020-11-12T02:43:24.000Z","updated":"2021-01-22T06:23:30.036Z","comments":true,"path":"2020/11/12/报表翻页保留静态标题/","link":"","permalink":"https://liminghua.gitee.io/2020/11/12/%E6%8A%A5%E8%A1%A8%E7%BF%BB%E9%A1%B5%E4%BF%9D%E7%95%99%E9%9D%99%E6%80%81%E6%A0%87%E9%A2%98/","excerpt":"","text":"搜索栏搜索属性或f4打开属性面板 点击行组中的静态 将RepeatOnNewPage置为true","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"vsReport","slug":"vsReport","permalink":"https://liminghua.gitee.io/tags/vsReport/"}]},{"title":"销售信息自定义页面","slug":"销售信息自定义页面","date":"2020-11-09T06:09:22.000Z","updated":"2021-01-22T06:22:42.639Z","comments":true,"path":"2020/11/09/销售信息自定义页面/","link":"","permalink":"https://liminghua.gitee.io/2020/11/09/%E9%94%80%E5%94%AE%E4%BF%A1%E6%81%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"1. 脉络整理- opportunity 销售信息 - 取 new_account_id 字段 - new_delaymanagement 逾期催收管理 - 取 new_account_id 字段 - new_name 单号 - new_overdate 逾期时间 - new_delaytimes 逾期期数 - new_overamount 逾期金额 - new_overduetype 逾期分类 - new_srv_disputes 客户服务纠纷单 - 取 new_account_id 字段 - new_name 单号 - new_requirements 用户要求 - new_dealtype 处理类型 - new_consensus 达成共识 2. hiddenApi- 空工作流，plugin触发，plugin根据请求寻找对应controller - broker ——&gt; Dapper 3. 脚本12345//徐庶 销售信息rtcrm(&quot;#new_account_id&quot;).val()[0].id.replace(&quot;&#123;&quot;,&quot;&quot;).replace(&quot;&#125;&quot;,&quot;&quot;);var paramList = &#123;accountId:&quot;F8B6B7CB-D3D6-EA11-8ABD-005056AF9937&quot;&#125;;rtcrm.invokeHiddenApi(&quot;new_Sales&quot;, &quot;Opportunity/GetDelaymanagementDetailList&quot;, paramList)rtcrm.invokeHiddenApi(&quot;new_Sales&quot;, &quot;Opportunity/GetDisputesDetailModelData&quot;, paramList) 12345678//找到表单上一个对象Xrm.Page.ui.controls.get(&quot;new_account_id&quot;);//获取属性Xrm.Page.ui.controls.get(&quot;new_account_id&quot;).getAttribute();//获取值Xrm.Page.ui.controls.get(&quot;new_account_id&quot;).getAttribute().getValue();//直接获取字段Xrm.Page.getAttribute(&quot;new_account_id&quot;).getValue() 4. sql语法12345678Convert(decimal(18,2),new_overamount) new_overamount, --保留小数位2位测试数据：销售信息 NOS202008050001 服务纠纷单 CSN202008130002逾期催收管理 BET202009290029new_account_id F8B6B7CB-D3D6-EA11-8ABD-005056AF9937","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"销售","slug":"销售","permalink":"https://liminghua.gitee.io/tags/%E9%94%80%E5%94%AE/"}]},{"title":"销售内部联络单","slug":"销售内部联络单","date":"2020-11-05T08:28:08.000Z","updated":"2021-01-22T06:22:45.478Z","comments":true,"path":"2020/11/05/销售内部联络单/","link":"","permalink":"https://liminghua.gitee.io/2020/11/05/%E9%94%80%E5%94%AE%E5%86%85%E9%83%A8%E8%81%94%E7%BB%9C%E5%8D%95/","excerpt":"","text":"内部联络单号 设置 &gt; 自动编号 &gt; new_sal_contactform 根据销售信息单自动带出 √ 销售信息 new_opportunity_id（内联单) 客户名称 new_account_id（内联单) new_account_id(销售信息) 主要联系人 new_pkcontact（内联单) new_contactname(销售信息-联系人姓名) 联系电话 new_telephone（内联单) new_contacttel（销售信息-联系人电话） 联系地址 new_address（内联单) new_address（销售信息-详细地址） 提报单位 new_dept_id（内联单) new_dept_id（销售信息-提报单位） 跟踪人 new_sales_id（内联单) new_trackor（销售信息-跟踪人） 所属组织 new_organisation_id new_organisation_id(销售信息) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function opportunityOnchange() &#123; ///&lt;summary&gt;销售信息Onchange事件&lt;/summary&gt; //销售信息id var new_opportunity_id = rtcrm.getLookupId(&quot;new_opportunity_id&quot;); //查询销售信息字段（客户名称、主要联系人、联系电话、联系地址、提报单位、跟踪人） var opportunity = rtcrm.getFieldValue(new_opportunity_id, &quot;opportunities&quot;, &quot;_new_account_id_value,new_contactname,new_contacttel,new_address,_new_dept_id_value,_new_trackor_value&quot;, true); //客户名称赋值 if (opportunity[&quot;_new_account_id_value&quot;]) &#123; var new_account_id = opportunity[&quot;_new_account_id_value&quot;]; var new_account_id_name = opportunity[&quot;_new_account_id_value@OData.Community.Display.V1.FormattedValue&quot;]; var lookupValue = rtcrm.buildLookup(new_account_id, new_account_id_name, &quot;account&quot;); rtcrm(&#x27;#new_account_id&#x27;).val(lookupValue); &#125; else &#123; console.log(&quot;客户名称为空&quot;); &#125; //主要联系人赋值 if (opportunity[&quot;new_contactname&quot;]) &#123; var new_contactname = opportunity[&quot;new_contactname&quot;]; rtcrm(&quot;#new_pkcontact&quot;).val(new_contactname); &#125; else &#123; console.log(&quot;主要联系人为空&quot;); &#125; //联系电话赋值 if (opportunity[&quot;new_contacttel&quot;]) &#123; var new_contacttel = opportunity[&quot;new_contacttel&quot;]; rtcrm(&quot;#new_telephone&quot;).val(new_contacttel); &#125; else &#123; console.log(&quot;联系电话为空&quot;); &#125; //联系地址赋值 if (opportunity[&quot;new_address&quot;]) &#123; var new_address = opportunity[&quot;new_address&quot;]; rtcrm(&quot;#new_address&quot;).val(new_address); &#125; else &#123; console.log(&quot;联系地址为空&quot;); &#125; //提报单位赋值 if (opportunity[&quot;_new_dept_id_value&quot;]) &#123; var new_dept_id = opportunity[&quot;_new_dept_id_value&quot;]; var new_dept_id_name = opportunity[&quot;_new_dept_id_value@OData.Community.Display.V1.FormattedValue&quot;]; var lookupValue = rtcrm.buildLookup(new_dept_id, new_dept_id_name, &quot;businessunit&quot;); rtcrm(&#x27;#new_dept_id&#x27;).val(lookupValue); &#125; else &#123; console.log(&quot;提报单位为空&quot;); &#125; //跟踪人赋值 if (opportunity[&quot;_new_trackor_value&quot;]) &#123; var new_trackor_id = opportunity[&quot;_new_trackor_value&quot;]; var new_trackor_id_name = opportunity[&quot;_new_trackor_value@OData.Community.Display.V1.FormattedValue&quot;]; var lookupValue = rtcrm.buildLookup(new_trackor_id, new_trackor_id_name, &quot;new_ord_sales&quot;); rtcrm(&#x27;#new_sales_id&#x27;).val(lookupValue); &#125; else &#123; console.log(&quot;跟踪人为空&quot;); &#125;&#125; 处理状态 picklist字段；分为：制单、处理中、已处理、已完成； 1.处理状态初始值默认为’制单‘； 2.点击处理后，更新处理状态为’已处理‘； new_dealstatus 审核状态 picklist字段：分为：制单、审核中、已审核、已驳回、已否决 1.审核状态初始值为制单； 2.点击提交后，更新审核状态为审核中； 3.审核后，更新审核状态为已审核或者已驳回； new_approvalstatus 处理按钮 点击处理后，更新处理状态为’已处理‘ 处理中已审核时,责任人和当前账户一致时显示 注册按钮 显示隐藏控制 enable rules customRule 完成按钮 点击完成按钮，更新处理状态为‘已完成’ 已处理已审核时，单据负责人和当前账户一致时显示 场景动作 1.点击提交 1.1 更新处理状态为‘处理中’ 1.2 更新审核状态为‘审核中’ 电商运营部负责人审核 2.同意 2.1更新审核状态为‘已审核’ 3.驳回 3.1更新处理状态为‘制单’ 3.2更新审核状态为‘已驳回’ 签核流程自动化 新建解决方案 添加现有实体 添加必须组件 &gt; 否 设置 &gt; 签核流程自动化 输入解决方案名称 &gt; 无审核驳回等字段点添加字段（标准签核流不建议自己建） &gt; 无提交撤回等按钮选择添加按钮 销售内联单产品明细 new_contactformproduct 销售内联单产品明细 test 销售信息 4CBB33BE-B2A7-4873-8246-E855F762D60B new_name 名称 new_productgroup_id 产品组 new_tonlevel_id 吨级 new_productmodel_id 产品型号 new_number 需求数量 new_plandealmoney 预计成交单价 new_actualdealmoney 实际成交单价 new_plandealtime 预计成交年月 new_actualamount 实际成交金额 配置窗体时选择子网格属性即可将明细与主档根据字段关联 js打开视图表单 12345678openEntityForm: function (name, id, parameters, windowOptions) &#123; /// &lt;summary&gt;对openEntityForm函数的封装，打开CRM页面&lt;/summary&gt; /// &lt;param name=&quot;name&quot; type=&quot;String&quot;&gt;实体名称&lt;/param&gt; /// &lt;param name=&quot;id&quot; type=&quot;String&quot;&gt;实体ID，若为空，则打开新建页面&lt;/param&gt; /// &lt;param name=&quot;parameters&quot; type=&quot;Object&quot;&gt;将参数带入窗体中&lt;/param&gt; /// &lt;param name=&quot;windowOptions&quot; type=&quot;Object&quot;&gt;若 openInNewWindow 属性设置为 true，则将在新窗体中打开一个窗口。此参数在 Dynamics 365 移动客户端（电话和平板）中被忽略。&lt;/param&gt; Xrm.Utility.openEntityForm(name, id, parameters, windowOptions);&#125;, 12345678910111213141516function OpenNewContact() &#123; var parameters = &#123;&#125;; //Set the Parent Customer field value to &quot;Contoso&quot;. parameters[&quot;parentcustomerid&quot;] = &quot;2878282E-94D6-E111-9B1D-00155D9D700B&quot;; parameters[&quot;parentcustomeridname&quot;] = &quot;Contoso&quot;; parameters[&quot;parentcustomeridtype&quot;] = &quot;account&quot;; //Set the Address Type to &quot;Primary&quot;. parameters[&quot;address1_addresstypecode&quot;] = &quot;3&quot;; //Set text in the Description field. parameters[&quot;description&quot;] = &quot;Default values for this record were set programmatically.&quot;; //Set Do not allow E-mails to &quot;Do Not Allow&quot;. parameters[&quot;donotemail&quot;] = &quot;1&quot;; // Open the window. Xrm.Utility.openEntityForm(&quot;contact&quot;, null, parameters);&#125; 小细节 pickList赋值用OptionSetValue（int） js文件无法上传至正式环境web资源时，先在测试环境上传，并新建解决方案，将web资源添加至解决方案后导出再导入正式环境","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"销售","slug":"销售","permalink":"https://liminghua.gitee.io/tags/%E9%94%80%E5%94%AE/"}]},{"title":"PowerBI_DAX函数","slug":"PowerBI_DAX函数","date":"2020-11-04T01:18:01.000Z","updated":"2021-01-22T06:23:36.516Z","comments":true,"path":"2020/11/04/PowerBI_DAX函数/","link":"","permalink":"https://liminghua.gitee.io/2020/11/04/PowerBI_DAX%E5%87%BD%E6%95%B0/","excerpt":"","text":"DAX函数 数据分析表达式 (DAX) 是在 Analysis Services、Power BI 以及 Excel 中的 Power Pivot 使用的公式表达式语言。 DAX 公式包括函数、运算符和值，用于对表格数据模型中相关表和列中的数据执行高级计算和查询微软文档 CALCULATE DAX中最重要的函数 语法格式1CALCULATE(聚合函数,筛选条件,筛选条件...) 所有筛选条件的交集形成最终的筛选数据集合,根据筛选出的数据集合执行第一个参数的聚合运算并返回运算结果 用例 导入下面这个产品明细表： 新建一个度量值求每种产品的数量：产品数量 = COUNTROWS(‘产品明细’)因为每种产品的只有1行，所以求产品明细表的行数就相当于求各种产品的数量，把产品名称和该度量值拖拽入矩阵表， 这里外部上下文就是表格每行的行标签。 用例01 | 筛选条件为空，不影响外部上下文 现在开始用CALCULATE函数创建一个度量值： 12产品数量1 &#x3D; CALCULATE([产品数量]) 只是用了第一个参数，筛选条件为空，因为没有内部筛选所以完全依赖外部上下文，出来的结果也和原度量值一致。 另外，介绍CALCULATE语法的时候说，第一个参数为聚合运算表达式，为什么这里没有用聚合函数而只用了一个度量值呢？这是因为度量值[产品数量]本身就是一个聚合函数运算，实际上度量值[产品数量1]等同于这个：产品数量1 = CALCULATE(COUNTROWS(‘产品明细’))DAX函数可以直接引用已经创建好的度量值，可以使DAX函数看起来更简洁、更具可读性，这也是建议从最简单的度量值开始建的原因。 用例02 | 添加限制条件，缩小上下文 建一个度量值[产品数量2]， 12产品数量2 &#x3D; CALCULATE([产品数量],&#39;产品明细&#39;[品牌]&#x3D;&quot;苹果&quot;) 发现只有苹果的产品计数显示出来，而其他品牌的数据没有了，这是因为CALCULATE的第二个参数的限制，只筛选品牌为“苹果”的，限制了外部的上下文，非苹果的产品都不再运算。 用例03 | 结合ALL函数，扩大上下文 新建度量值[产品数量3]， 12产品数量3 &#x3D; CALCULATE([产品数量],ALL(&#39;产品明细&#39;)) 这次的数据居然是所有产品的数量，这是因为筛选条件使用了ALL函数，ALL(‘产品明细’)的意思是清除产品明细表里的所有筛选，外部筛选器不起作用了，每行统计的都是该表中的所有产品。每行的数据都是9，你可能觉得这个ALL函数没什么用，运算的数据没有什么意义，实际上当然不是这样，这个数据使用的地方非常多，比如我们想计算每个产品数量占总产品数量的比重，直接写个度量值：产品占比=[产品数量]/[产品数量3] 产品占比就计算出来了，这就是统计总数的一个功能。 用例04 | 重置上下文 新建度量值[产品数量4]， 12产品数量4 &#x3D; CALCULATE([产品数量], all(&#39;产品明细&#39;[产品名称]),&#39;产品明细&#39;[类别]&#x3D;&quot;手机&quot;) 先用ALL函数清除外部上下文，然后又新增了一个筛选条件，类别为”手机”的产品数量，那么结果会是什么样的呢， 每一行产品的数量都是3，正好符合建立这个度量值的逻辑，被ALL清除行标签的外部筛选后，从全部产品中统计品类为”手机”的产品的数量，所以每行都返回3. SUM 对某个列中的所有数值求和 1SUM(&lt;column&gt;) SUMX 返回为表中的每一行计算的表达式的和 12SUMX(&lt;table&gt;, &lt;expression&gt;)eg:商机金额预估_基础 &#x3D; CALCULATE(SUMX(&#39;Opportunityproduct&#39;,&#39;Opportunityproduct&#39;[需求数量]*&#39;Opportunityproduct&#39;[预计成交单价(万元)]))*10000 SUMX 函数将表或返回表的表达式作为其第一个参数。 第二个参数是包含要计算总和的数字的列，或计算结果为列的表达式。仅对列中的数字进行计数。 空白、逻辑值和文本会被忽略。 SUM &amp; SUMX SUM是列级别聚合函数（不逐行计算），SUMX是行级别聚合函数（逐行计算） USERELATIONSHIP 如下图，虚线关系为当前不可用关系，但以使用USERELATIONSHIP函数为度量值指定相关关系 1最终客户销售金额 &#x3D; CALCULATE([销售金额],USERELATIONSHIP(Account[客户识别码],OrderShipment[最终客户识别码]))","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"powerBI","slug":"powerBI","permalink":"https://liminghua.gitee.io/tags/powerBI/"},{"name":"DAX函数","slug":"DAX函数","permalink":"https://liminghua.gitee.io/tags/DAX%E5%87%BD%E6%95%B0/"}]},{"title":"IDEA快捷键","slug":"IDEA快捷键","date":"2020-10-29T07:54:23.000Z","updated":"2021-01-22T03:55:03.703Z","comments":true,"path":"2020/10/29/IDEA快捷键/","link":"","permalink":"https://liminghua.gitee.io/2020/10/29/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"Ctrl+Z：撤销 Ctrl+Shift+Z：重做 Ctrl+X：剪贴 Ctrl+C：复制 Ctrl+V：粘贴 Ctrl+Y：删除当前行 Ctrl+D:复制当前行 Ctrl+Shift+J：将选中的行合并成一行 Ctrl+N：查找类文件 Ctrl+Shift+N：查找文件 Ctrl+G：定位到文件某一行 Alt+向左箭头：返回上次光标位置 Alt+向右箭头：返回至后一次光标位置 Ctrl+Shift+Backspace：返回上次编辑位置 Ctrl+Shift+反斜杠：返回后一次编辑位置 Ctrl+B：定位至变量定义的位置 Ctrl+Alt+B：定位至选中类或者方法的具体实现 Ctrl+Shift+B:直接定位至光标所在变量的类型定义 Ctrl+U：直接定位至当前方法override或者implements的方法定义处 Ctrl+F12：显示当前文件的文件结构 Ctrl+Alt+F12：显示当前文件的路径，并可以方便的将相关父路径打开 Ctrl+H：显示当前类的继承层次 Ctrl+Shift+H：显示当前方法的继承层次 Ctrl+Alt+H：显示当前方法的调用层次 F2：定位至下一个错误处 Shift+F2：定位至前一个错误处 Ctrl+Alt+向上箭头：查找前一个变量共现的地方 Ctrl+Alt+向下箭头：查找下一个变量共现的地方 Ctrl+=：展开代码 Ctrl+-：收缩代码 Ctrl+Alt+=：递归展开代码 Ctrl+Alt+-：递归收缩代码 Ctrl+Shift+=：展开所有代码 Ctrl+Shift+-：收缩所有代码 Ctrl+Shitft+向下箭头：将光标所在的代码块向下整体移动 Ctrl+Shift+向上箭头：将光标所在的代码块向上整体移动 Ctrl+Alt+Shift+向左箭头：将元素向左移动 Ctrl+Alt+Shift+向右箭头：将元素向右移动 Alt+Shift+向下箭头：将行向下移动 Alt+Shift+向上箭头：将行向上移动 Ctrl+F：在当前文件中查找 Ctrl+R：替换字符串 Ctrl+Shift+F:在全局文件中查找字符串 Ctrl+Shift+R：在全局中替换字符串 Alt+F7：查找当前变量的使用，并列表显示 Ctrl+Alt+F7：查找当前变量的使用，并直接对话框提示 Ctrl+F7：在文件中查找符号的使用 Ctrl+Shift+F7：在文件中高亮显示变量的使用 Ctrl+O：重写基类方法 Ctrl+I：实现基类或接口中的方法 Alt+Insert：产生构造方法，get/set方法等 Ctrl+Alt+T：将选中的代码使用if，while，try/catch等包装 Ctrl+Shitf+Delete：去除相关的包装代码 Alt+/：自动完成 Alt+Enter：自动提示完成，抛出异常 提示import class Ctrl+J：插入Live Template 快速插入一行或者多行代码 Ctrl+Alt+J：使用Live Template包装 Ctrl+/：使用//注释 Ctrl+Shift+/：使用/**/注释 Ctrl+Alt+L：格式化代码 Ctrl+Alt+I：自动缩进行 Ctrl+Alt+O：优化import Ctrl+]：快速跳转至诸如{}围起来的代码块的结尾处 Ctrl+[：快速跳转至诸如{}围起来的代码块的开头处 Ctrl+Shift+Enter：将输入的if，for，函数等等补上{}或者；使代码语句完整 Shift+Enter：在当前行的下方开始新行 Ctrl+Alt+Enter：在当前行的上方插入新行 Ctrl+Delete：删除光标所在至单词结尾处的所有字符 Ctrl+Backspace：删除光标所在至单词开头处的所有字符 Ctrl+向左箭头：将光标移至前一个单词 Ctrl+向右箭头：将光标移至后一个单词 Ctrl+向上箭头：向上滚动一行 Ctrl+向下箭头：向下滚动一行 Ctrl+W：选中整个单词 Ctrl+Shift+U：切换大小写 Shift+F6：重命名 Ctrl+F6：更改函数签名 Ctrl+Shift+F6：更改类型","categories":[{"name":"工具","slug":"工具","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"编译器","slug":"编译器","permalink":"https://liminghua.gitee.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"idea","slug":"idea","permalink":"https://liminghua.gitee.io/tags/idea/"}]},{"title":"SQL执行顺序","slug":"SQL执行顺序","date":"2020-10-29T06:33:27.000Z","updated":"2021-01-22T03:55:03.710Z","comments":true,"path":"2020/10/29/SQL执行顺序/","link":"","permalink":"https://liminghua.gitee.io/2020/10/29/SQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"1、from子句组装来自不同数据源的数据（包括join on）； 2、where子句基于指定的条件对记录行进行筛选； 3、group by子句将数据划分为多个分组； 4、使用聚集函数进行计算； 5、使用having子句筛选分组； 6、计算所有的表达式； 7、select 集合输出； 8、使用order by对结果集进行排序。","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL语法","slug":"SQL语法","permalink":"https://liminghua.gitee.io/tags/SQL%E8%AF%AD%E6%B3%95/"}]},{"title":"SQL连接符、表达式及函数","slug":"SQL连接符、表达式及函数","date":"2020-10-29T02:34:16.000Z","updated":"2021-01-22T03:55:03.714Z","comments":true,"path":"2020/10/29/SQL连接符、表达式及函数/","link":"","permalink":"https://liminghua.gitee.io/2020/10/29/SQL%E8%BF%9E%E6%8E%A5%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%87%BD%E6%95%B0/","excerpt":"","text":"连接符+ 连接符 连接表中数据类型相同或近似的列，若数据类型完全不同，则需通过CAST表达式进行类型转换，若其中一列为NULL则结果为NULL 123456SELECT TOP 3 new_country_idName + &#x27;--&#x27; +new_city_idName AS Adress, NameFROM Account 表达式CAST表达式 转换数据类型，若数据为空则转换结果为NULL 123456789SELECT TOP 3 new_country_idName + &#x27;--&#x27; +new_city_idName AS Adress, Name + new_age AS MesgFROM Account &gt; [42000] [Microsoft][ODBC Driver 17 for SQL Server][SQL Server]从数据类型 nvarchar 转换为 numeric 时出错。 (8114) 123456SELECT TOP 3 new_country_idName + &#x27;--&#x27; +new_city_idName AS Adress, Name + CAST(new_age AS VARCHAR(256)) AS MesgFROM Account CASE表达式1234567891011SELECT TOP 3 new_country_idName + &#x27;--&#x27; +new_city_idName AS Adress, Name, CASE WHEN Name = &#x27;李老板&#x27; THEN &#x27;李老板好&#x27; WHEN Name = &#x27;高永平&#x27; THEN &#x27;高老板好&#x27; ELSE &#x27;您好&#x27; END AS SayFROM Account 函数 对列中某个数据进行处理并返回值 字符串操作函数12345678910111213141516171819202122232425262728293031323334353637383940---字符中操作函数UPPER(S) 将字符串统一为大写字母SELECT UPPER(&#x27;asasA&#x27;) --ASASA LOWER(S) 将字符串统一为小写字母SELECT LOWER(&#x27;asasA&#x27;) ---asasa LEN(S) 返回字符串的长度SELECT LEN(&#x27;中国1号&#x27;) --4 CHARINDEX(S1,S2) 返回S1在字符串S2中的位置 SELECT CHARINDEX(&#x27;aa1号&#x27;,&#x27;1111aa1号中国1号&#x27;) --5 SUBSTRING(S,I,N) 在S字符串中的第I个字符起取N个字符SELECT SUBSTRING(&#x27;TECHNOLO&#x27;,3,3) --CHN SELECT CONVERT(INT,&#x27;111&#x27;) LEFT(S,N) 从字符串S左边取N个字符RIGHT(S,N) 从字符串S右边取N个字符SELECT RIGHT(&#x27;00000000&#x27;+&#x27;11&#x27;,8)SELECT RIGHT(&#x27;00000000&#x27;+&#x27;2222&#x27;,8)SELECT LEFT(&#x27;11&#x27;+&#x27;00000000&#x27;+&#x27;11&#x27;,8)SELECT LEFT(&#x27;2222&#x27;+&#x27;00000000&#x27;+&#x27;2222&#x27;,8) SPACE(N) 生成N个空格SELECT &#x27;合计&#x27;+SPACE(2)+&#x27;123&#x27; RTRIM(S) --消除字符串左边开始或者右边开始的空格LTRIM(S) --消除字符串左边开始或者右边开始的空格 SELECT RTRIM(&#x27; SAMPLE &#x27;)SELECT LTRIM(&#x27; SAMPLE &#x27;)SELECT LTRIM(RTRIM(&#x27; SAMPLE &#x27;)); REPLACE(STRING,ATOREPLACE,NEWSTRING) --替换函数SELECT REPLACE(&#x27;HHAAAH&#x27;,&#x27;A&#x27;,&#x27;S&#x27;) 数学函数1234567891011121314151617181920abs(numeric_expr) --求绝对值ceiling(numeric_expr) --取大于等于指定值的最小整数exp(float_expr) --取指数floor(numeric_expr) --小于等于指定值得最大整数power(numeric_expr,power) --返回power次方rand([int_expr]) --随机数产生器round(numeric_expr,int_expr) --安int_expr规定的精度四舍五入sign(int_expr) --根据正数,0,负数,,返回+1,0,-1sqrt(float_expr) --平方根exp(float x) --求e的x次幂tan(float x) --计算x（弧度表示）的正切值。atan(float x) --求x（弧度表示）的反正切值cos(float x) --求x（弧度表示）的余弦值acos(float x) --求x（弧度表示）的反余弦值sin(float x) --计算x（弧度表示）的正弦值。asin(float x) --求x（弧度表示）的反正弦值fabs(float x) --求浮点数x的绝对值fmod(float x, float y) --计算x/y的余数pow(float x, float y) --计算x的y次幂。sqrt(float x) --计算x的平方根。 日期函数123456getdate() --返回日期datename(datepart,date_expr) --返回名称datepart(datepart,date_expr) --取日期一部份datediff(datepart,date_expr1.dateexpr2) --日期差dateadd(datepart,number,date_expr) --返回日期加上 numberday(date_expr), month(date_expr),year(date_expr) --提取date_expr中的日月年","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL语法","slug":"SQL语法","permalink":"https://liminghua.gitee.io/tags/SQL%E8%AF%AD%E6%B3%95/"}]},{"title":"聚合函数","slug":"聚合函数","date":"2020-10-29T02:26:39.000Z","updated":"2021-01-22T03:55:03.786Z","comments":true,"path":"2020/10/29/聚合函数/","link":"","permalink":"https://liminghua.gitee.io/2020/10/29/%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/","excerpt":"","text":"聚合函数 聚合函数是对列中的一系列数据进行处理，返回单个统计值 SUM() 获取单个列的合计值 MAX() 计算列的最大值 123456SELECT Name,new_ageFROM AccountWHERE new_age = (SELECT MAX(new_age) FROM Account) MIN() 计算列的最小值 AVG() 计算某个列的平均值,忽略NULL值 COUNT() 统计行数量COUNT(*)计算表中的总行数（包括null）COUNT(column)计算column列的行数（不计算null行） GROUP BY 根据字句后缀的列对数据进行分组(null值为一组) 123SELECT sex+&#x27;教师&#x27; AS teacher,AVG(age) AS avg_ageFROM t_teacherGROUP BY sex ROLLUP 123SELECT sex+&#x27;教师&#x27; AS teacher,AVG(age) AS avg_ageFROM t_teacherGROUP BY sex with ROLLUP HAVING 对group by分组后进行筛选 12345SELECT sex+&#x27;教师&#x27; AS teacher,COUNT(*) AS num_teacherFROM t_teacherGROUP BY teacherHAVING COUNT(*)&gt;=2--显示男女教师分组中人数大于2的 重复值处理 DISTINCT 在聚合函数中，默认为ALL关键字，即不论是否有重复值，对所有数据进行处理使用DISTINCT关键字后，则会进行非重值处理，即每个重复的值只取一次参与计算 123456SELECT Name,new_ageFROM AccountWHERE new_age = (SELECT AVG(DISTINCT new_age) FROM Account)","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL语法","slug":"SQL语法","permalink":"https://liminghua.gitee.io/tags/SQL%E8%AF%AD%E6%B3%95/"}]},{"title":"SQLServer查询跟踪","slug":"SQLServer查询跟踪","date":"2020-10-29T01:03:39.000Z","updated":"2021-01-22T03:55:03.707Z","comments":true,"path":"2020/10/29/SQLServer查询跟踪/","link":"","permalink":"https://liminghua.gitee.io/2020/10/29/SQLServer%E6%9F%A5%E8%AF%A2%E8%B7%9F%E8%B8%AA/","excerpt":"","text":"SQL Server Profiler 数据库性能工具 1.新建跟踪 文件-新建跟踪 2.事件选择 Stored Procedures：TextData 根据sql中的文本值进行过滤 列筛选器中键入TextData的类似于值 ：要跟踪的sql中特定的参数或关键字 3.运行","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"sql跟踪","slug":"sql跟踪","permalink":"https://liminghua.gitee.io/tags/sql%E8%B7%9F%E8%B8%AA/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://liminghua.gitee.io/tags/SQL-Server/"}]},{"title":"SQL调优","slug":"SQL调优","date":"2020-10-21T07:05:24.000Z","updated":"2021-01-22T03:55:03.712Z","comments":true,"path":"2020/10/21/SQL调优/","link":"","permalink":"https://liminghua.gitee.io/2020/10/21/SQL%E8%B0%83%E4%BC%98/","excerpt":"","text":"SET STATISTICS XX ON 收集语句运行的统计信息 SET STATISTICS TIME ON 输出语句做的物理读和逻辑读的数目 1234567891011121314151617DBCC DROPCLEANBUFFERS--清除buffer pool里的所有缓存数据DBCC FREEPROCCACHEGO--清除buffer pool里的所有缓存的执行计划SET STATISTICS TIME ON;SELECT a.Name, b.new_level FROM Account a LEFT JOIN new_accountclassification b ON a.AccountId = b.new_account_id WHERE a.AccountId = &#x27;7FEC00BA-A4BA-EA11-A13F-000C29B5B96B&#x27;SET STATISTICS TIME OFF 执行上面代码获取以下信息： 123456789101112131415161718192021222324252627282930313233343536373839404142DBCC DROPCLEANBUFFERS--清除buffer pool里的所有缓存数据DBCC FREEPROCCACHE&gt; SQL Server 分析和编译时间: CPU 时间 = 0 毫秒，占用时间 = 0 毫秒。&gt; DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。&gt; SQL Server 执行时间: CPU 时间 = 328 毫秒，占用时间 = 332 毫秒。&gt; DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。&gt; SQL Server 执行时间: CPU 时间 = 15 毫秒，占用时间 = 10 毫秒。&gt; OK&gt; 时间: 0.35s--清除buffer pool里的所有缓存的执行计划SET STATISTICS TIME ON;SELECT a.Name, b.new_level FROM Account a LEFT JOIN new_accountclassification b ON a.AccountId = b.new_account_id WHERE a.AccountId = &#x27;7FEC00BA-A4BA-EA11-A13F-000C29B5B96B&#x27;SET STATISTICS TIME OFF&gt; SQL Server 分析和编译时间: CPU 时间 = 203 毫秒，占用时间 = 278 毫秒。&gt; SQL Server 执行时间: CPU 时间 = 0 毫秒，占用时间 = 0 毫秒。&gt; SQL Server 执行时间: CPU 时间 = 0 毫秒，占用时间 = 5 毫秒。&gt; OK&gt; 时间: 0.295s CPU时间 这个值的含义指的是在这一步，SQLSERVER所花的纯CPU时间是多少。也就是说，语句花了多少CPU资源。 占用时间 此值指这一步一共用了多少时间。也就是说，这是语句运行的时间长短，有些动作会发生I/O操作，产生了I/O等待，或者是遇到阻塞、产生了阻塞等待。总之时间用掉了，但是没有用CPU资源。所以占用时间比CPU时间长是很正常的 ，但是CPU时间是语句在所有CPU上的时间总和。如果语句使用了多颗CPU，而其他等待几乎没有，那么CPU时间大于占用时间也是正常的。 分析和编译时间 这一步，就是语句的编译时间。由于语句运行之前清空了所有执行计划，SQLSERVER必须要对他编译。这里的编译时间就不为0了。由于编译主要是CPU的运算，所以一般CPU时间和占用时间是差不多的。如果这里相差比较大，就有必要看看SQLSERVER在系统资源上有没有瓶颈了。这里他们是一个15毫秒，一个是104毫秒。 SQLSERVER执行时间 语句真正运行的时间。由于语句是第一次运行，SQLSERVER需要把数据从磁盘读到内存里，这里语句的运行发生了5毫秒的I/O等待。 关键字go go 向 SQL Server 实用工具发出一批 Transact-SQL 语句结束的信号。例如当某一语句要求必须是查询批次中的第一个语句，则可以在前面加上go来终结上一个批处理，使其成为下一个批处理的开头。CREATE DEFAULT, CREATE FUNCTION, CREATE PROCEDURE, CREATE RULE, CREATE SCHEMA, CREATE TRIGGER, CREATE VIEW SET STATISTICS IO ON1234567891011SET STATISTICS IO ON;SELECT a.Name, b.new_level FROM Account a LEFT JOIN new_accountclassification b ON a.AccountId = b.new_account_id WHERE a.AccountId = &#x27;7FEC00BA-A4BA-EA11-A13F-000C29B5B96B&#x27;SET STATISTICS IO OFF; 执行上面代码获取以下信息： 12&gt; 表 &#x27;new_accountclassificationBase&#x27;。扫描计数 1，逻辑读取 6 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。&gt; 表 &#x27;AccountBase&#x27;。扫描计数 0，逻辑读取 4 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。 表 表的名称。 扫描计数 执行的扫描次数。按照执行计划，表格被扫描了几次。一般来讲大表扫描的次数越多越不好。唯一的例外是如果执行计划选择了并发运行，由多个thread线程同时做一个表的读取，每个thread读其中的一部分，但是这里会显示所有thread的数目。也就是有几个thread在并发做，就会有几个扫描。这时数目大一点没问题的。 逻辑读取 从数据缓存读取的页数。页数越多，说明查询要访问的数据量就越大，内存消耗量越大，查询也就越昂贵。可以检查是否应该调整索引，减少扫描的次数，缩小扫描范围。顺便说一下这个逻辑读取的统计原理：为什麽显示出来的结果的单位不是Page，也不是K或KB。SQLSERVER里在做读和写的时候，会运行到某一段特定的代码。每调用一次这个代码，Reads/Write就会加1。所以这个值比较大那语句一定做了比较多的I/O，但是不能通过这个值计算出I/O的绝对数量，这个值反映的是逻辑读写量不是物理读写量。 物理读取 从磁盘读取的页数 预读 为进行查询而预读入缓存的页数 物理读取+预读 就是SQLSERVER为了完成这句查询而从磁盘上读取的页数。如果不为0，说明数据没有缓存在内存里。运行速度一定会受到影响 LOB逻辑读取 从数据缓存读取的text、ntext、image、大值类型（varchar(max)、nvarchar(max)、varbinary(max)）页的数目 LOB物理读取 从磁盘读取的text、ntext、image、大值类型页的数目 LOB预读 为进行查询而放入缓存的text、ntext、image、大值类型页的数目 SET STATISTICS PROFILE ON 返回语句的执行计划，以及语句运行在每一步的实际返回行数统计 1234567891011121314SET STATISTICS PROFILE ON;SELECT a.Name, b.new_level FROM Account a LEFT JOIN new_accountclassification b ON a.AccountId = b.new_account_id WHERE a.AccountId = &#x27;7FEC00BA-A4BA-EA11-A13F-000C29B5B96B&#x27; SET STATISTICS PROFILE OFF 会返回另外的一个结果如下图：注意：这里是从最下面开始向上看的，也就是说从最下面开始一直执行直到得到结果集所以（行1）里的rows字段显示的值就是这个查询返回的结果集。而且有多少行表明SQLSERVER执行了多少个步骤,这里有6行，表明SQLSRVER执行了6个步骤！！ Rows 执行计划的每一步返回的实际行数 Executes 执行计划的每一步被运行了多少次 StmtText 执行计划的具体内容。执行计划以一棵树的形式显示。每一行都是运行的一步，都会有结果集返回，也都会有自己的cost EstimateRows SQLSERVER根据表格上的统计信息，预估的每一步的返回行数。在分析执行计划时，我们会经常将Rows和EstimateRows这两列做对比，先确认SQLSERVER预估得是否正确，以判断统计信息是否有更新 EstimateIO SQLSERVER根据EstimateRows和统计信息里记录的字段长度，预估的每一步会产生的I/O cost EstimateCPU SQLSERVR根据EstimateRows和统计信息里记录的字段长度，以及要做的事情的复杂度，预估每一步会产生的CPU cost TotalSubtreeCost SQLSERVER根据EstimateIO和EstimateCPU通过某种计算公式，计算出每一步执行计划子树的cost(包括这一步自己的cost和他的所有下层步骤的cost总和) Warnings SQLSERVER在运行每一步时遇到的警告，例如，某一步没有统计信息支持cost预估等。 Parallel 执行计划的这一步是不是使用了并行的执行计划 具体步骤分析执行计划的具体内容如下图：","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://liminghua.gitee.io/tags/SQL-Server/"},{"name":"优化","slug":"优化","permalink":"https://liminghua.gitee.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"SQL调优","slug":"SQL调优","permalink":"https://liminghua.gitee.io/tags/SQL%E8%B0%83%E4%BC%98/"}]},{"title":"开窗函数","slug":"开窗函数","date":"2020-10-21T07:05:09.000Z","updated":"2021-01-22T03:55:03.766Z","comments":true,"path":"2020/10/21/开窗函数/","link":"","permalink":"https://liminghua.gitee.io/2020/10/21/%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0/","excerpt":"","text":"开窗函数 与聚合函数一样，开窗函数也是对行集组进行聚合计算，但是它不像普通聚合函数那样每组只返回一个值，开窗函数可以为每组返回多个值，因为开窗函数所执行聚合计算的行集组是窗口。在 ISO SQL 规定了这样的函数为开窗函数，在 Oracle 中则被称为分析函数。 PARTITION BY 分组开窗函数的OVER关键字后括号中的可以使用PARTITION BY 子句来定义行的分区来供进行聚合计算。与GROUP BY 子句不同，PARTITION BY 子句创建的分区是独立于结果集的，创建的分区只是供进行聚合计算的，而且不同的开窗函数所创建的分区也不互相影响。 ORDER BY 排序 聚合开窗函数 聚合函数(列) OVER (选项)，这里的选项可以是PARTITION BY子句，但不可是ORDER BY子句 12345SELECT name,new_age,SUM(new_age)OVER(PARTITION BY new_age) max_ageFROM Account 排序开窗函数 排序函数(列) OVER(选项)，这里的选项可以是ORDER BY子句，也可以是 OVER（PARTITION BY子句 ORDER BY子句），但不可以是PARTITION BY子句 12345SELECT name,AccountNumber,row_number()OVER(PARTITION BY AccountNumber ORDER BY AccountNumber) repeatFROM Account","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL语法","slug":"SQL语法","permalink":"https://liminghua.gitee.io/tags/SQL%E8%AF%AD%E6%B3%95/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://liminghua.gitee.io/tags/SQL-Server/"}]},{"title":"数据库JOIN","slug":"数据库JOIN","date":"2020-10-21T07:04:55.000Z","updated":"2021-01-22T03:55:03.775Z","comments":true,"path":"2020/10/21/数据库JOIN/","link":"","permalink":"https://liminghua.gitee.io/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93JOIN/","excerpt":"","text":"JOIN关键字1234SELECT columnFROM join_tableJOIN_TYPE join_tableON (join_condition) join_table指参与连接操作的表名 column指查询的列 JOIN_TYPE 指连接类型 INNER JOIN，内连接（等同连接） 返回结果集只返回满足ON字句中的搜索条件的数据，不满足则不显示。默认情况下，DBMS会将JOIN也认定为INNER JOIN 表R A B C a1 b1 c1 a2 b2 c2 a3 b3 c3 表S C D c1 d1 c2 d2 c4 d3 执行R INNER JOIN S ON R.C = S.C A B C C D a1 b1 c1 c1 d1 a2 b2 c2 c2 d2 OUTER JOIN，外连接LEFT OUTER JOIN(LEFT JOIN)，左外连接 结果集返回匹配行加上左表的不匹配行 表R A B C a1 b1 c1 a2 b2 c2 a3 b3 c3 表S C D c1 d1 c2 d2 c4 d3 执行R LEFT JOIN S ON R.C = S.C A B C C D a1 b1 c1 c1 d1 a2 b2 c2 c2 d2 a3 b3 c3 null null RIGHT OUTER JOIN(RIGHT JOIN)，右外连接 结果集返回匹配行加上右表的不匹配行 表R A B C a1 b1 c1 a2 b2 c2 a3 b3 c3 表S C D c1 d1 c2 d2 c4 d3 执行R RIGHT JOIN S ON R.C = S.C A B C C D a1 b1 c1 c1 d1 a2 b2 c2 c2 d2 null null null c4 d3 FULL OUTER JOIN，全外连接 结果集返回匹配行和左右表的不匹配行 表R A B C a1 b1 c1 a2 b2 c2 a3 b3 c3 表S C D c1 d1 c2 d2 c4 d3 执行R FULL JOIN S ON R.C = S.C A B C C D a1 b1 c1 c1 d1 a2 b2 c2 c2 d2 a3 b3 c3 null null null null null c4 d3","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL语法","slug":"SQL语法","permalink":"https://liminghua.gitee.io/tags/SQL%E8%AF%AD%E6%B3%95/"}]},{"title":"jdk源码_List","slug":"jdk源码-List","date":"2020-10-08T05:42:06.000Z","updated":"2021-01-22T03:55:03.795Z","comments":true,"path":"2020/10/08/jdk源码-List/","link":"","permalink":"https://liminghua.gitee.io/2020/10/08/jdk%E6%BA%90%E7%A0%81-List/","excerpt":"","text":"List 继承了Collection，Collection继承了Iterable 文档简述： 有序的集合，也被称为序列，此接口的使用者可以对插入List中的每个元素进行精准的控制，可以通过下标搜索或访问List中的每一个元素。 与set不同，List允许重复的元素。 索引从零开始。 ListIterator：更强大的迭代器，继承于Iterator接口,只能用于各种List类型的访问。 List接口提供了两个方法来搜索指定的对象，但在很多实现中，它们将执行高开销的线性搜索。 List接口提供了两种方法来有效地插入，并在该列表中的任意点移除多个元件。 虽然List允许把自身做为元素包含,但equals方法和hashCode方法在这样的List上将不具备很好的支持性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * An ordered collection (also known as a &lt;i&gt;sequence&lt;/i&gt;). The user of this * interface has precise control over where in the list each element is * inserted. The user can access elements by their integer index (position in * the list), and search for elements in the list.&lt;p&gt; * &lt;p&gt; * Unlike sets, lists typically allow duplicate elements. More formally, * lists typically allow pairs of elements &lt;tt&gt;e1&lt;/tt&gt; and &lt;tt&gt;e2&lt;/tt&gt; * such that &lt;tt&gt;e1.equals(e2)&lt;/tt&gt;, and they typically allow multiple * null elements if they allow null elements at all. It is not inconceivable * that someone might wish to implement a list that prohibits duplicates, by * throwing runtime exceptions when the user attempts to insert them, but we * expect this usage to be rare.&lt;p&gt; * &lt;p&gt; * The &lt;tt&gt;List&lt;/tt&gt; interface places additional stipulations, beyond those * specified in the &lt;tt&gt;Collection&lt;/tt&gt; interface, on the contracts of the * &lt;tt&gt;iterator&lt;/tt&gt;, &lt;tt&gt;add&lt;/tt&gt;, &lt;tt&gt;remove&lt;/tt&gt;, &lt;tt&gt;equals&lt;/tt&gt;, and * &lt;tt&gt;hashCode&lt;/tt&gt; methods. Declarations for other inherited methods are * also included here for convenience.&lt;p&gt; * &lt;p&gt; * The &lt;tt&gt;List&lt;/tt&gt; interface provides four methods for positional (indexed) * access to list elements. Lists (like Java arrays) are zero based. Note * that these operations may execute in time proportional to the index value * for some implementations (the &lt;tt&gt;LinkedList&lt;/tt&gt; class, for * example). Thus, iterating over the elements in a list is typically * preferable to indexing through it if the caller does not know the * implementation.&lt;p&gt; * &lt;p&gt; * The &lt;tt&gt;List&lt;/tt&gt; interface provides a special iterator, called a * &lt;tt&gt;ListIterator&lt;/tt&gt;, that allows element insertion and replacement, and * bidirectional access in addition to the normal operations that the * &lt;tt&gt;Iterator&lt;/tt&gt; interface provides. A method is provided to obtain a * list iterator that starts at a specified position in the list.&lt;p&gt; * &lt;p&gt; * The &lt;tt&gt;List&lt;/tt&gt; interface provides two methods to search for a specified * object. From a performance standpoint, these methods should be used with * caution. In many implementations they will perform costly linear * searches.&lt;p&gt; * &lt;p&gt; * The &lt;tt&gt;List&lt;/tt&gt; interface provides two methods to efficiently insert and * remove multiple elements at an arbitrary point in the list.&lt;p&gt; * &lt;p&gt; * Note: While it is permissible for lists to contain themselves as elements, * extreme caution is advised: the &lt;tt&gt;equals&lt;/tt&gt; and &lt;tt&gt;hashCode&lt;/tt&gt; * methods are no longer well defined on such a list. * * &lt;p&gt;Some list implementations have restrictions on the elements that * they may contain. For example, some implementations prohibit null elements, * and some have restrictions on the types of their elements. Attempting to * add an ineligible element throws an unchecked exception, typically * &lt;tt&gt;NullPointerException&lt;/tt&gt; or &lt;tt&gt;ClassCastException&lt;/tt&gt;. Attempting * to query the presence of an ineligible element may throw an exception, * or it may simply return false; some implementations will exhibit the former * behavior and some will exhibit the latter. More generally, attempting an * operation on an ineligible element whose completion would not result in * the insertion of an ineligible element into the list may throw an * exception or it may succeed, at the option of the implementation. * Such exceptions are marked as &quot;optional&quot; in the specification for this * interface. * * &lt;p&gt;This interface is a member of the * &lt;a href=&quot;&#123;@docRoot&#125;/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @param &lt;E&gt; the type of elements in this list * @author Josh Bloch * @author Neal Gafter * @see Collection * @see Set * @see ArrayList * @see LinkedList * @see Vector * @see Arrays#asList(Object[]) * @see Collections#nCopies(int, Object) * @see Collections#EMPTY_LIST * @see AbstractList * @see AbstractSequentialList * @since 1.2 */public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; ...&#125; AbstractList123public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; ...&#125; modConut123456789101112131415161718192021222324252627/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its &#123;@code add(int, E)&#125; and * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */protected transient int modCount = 0; ItrListItrAbstractSequentialList 有序List 123public abstract class AbstractSequentialList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; ...&#125; get() – AbstractObjectList123456public Object get(int index) &#123; if (index &gt;= 0 &amp;&amp; index &lt; getLength()) &#123; return item(index); &#125; throw new IndexOutOfBoundsException(&quot;Index: &quot; + index);&#125; get() – AbstractSequentialList12345678910111213141516/** * Returns the element at the specified position in this list. * * &lt;p&gt;This implementation first gets a list iterator pointing to the * indexed element (with &lt;tt&gt;listIterator(index)&lt;/tt&gt;). Then, it gets * the element using &lt;tt&gt;ListIterator.next&lt;/tt&gt; and returns it. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; try &#123; return listIterator(index).next(); &#125; catch (NoSuchElementException exc) &#123; throw new IndexOutOfBoundsException(&quot;Index: &quot; + index); &#125;&#125; listIterator(index)12345678910111213141516171819202122232425/** * Returns a list-iterator of the elements in this list (in proper * sequence), starting at the specified position in the list. * Obeys the general contract of &#123;@code List.listIterator(int)&#125;.&lt;p&gt; * &lt;p&gt; * The list-iterator is &lt;i&gt;fail-fast&lt;/i&gt;: if the list is structurally * modified at any time after the Iterator is created, in any way except * through the list-iterator&#x27;s own &#123;@code remove&#125; or &#123;@code add&#125; * methods, the list-iterator will throw a * &#123;@code ConcurrentModificationException&#125;. Thus, in the face of * concurrent modification, the iterator fails quickly and cleanly, rather * than risking arbitrary, non-deterministic behavior at an undetermined * time in the future. * * @param index index of the first element to be returned from the * list-iterator (by a call to &#123;@code next&#125;) * @return a ListIterator of the elements in this list (in proper * sequence), starting at the specified position in the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @see List#listIterator(int) */public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index);&#125; ListIterator1234567891011121314151617181920212223242526272829303132333435/** * An iterator for lists that allows the programmer * to traverse the list in either direction, modify * the list during iteration, and obtain the iterator&#x27;s * current position in the list. A &#123;@code ListIterator&#125; * has no current element; its &lt;I&gt;cursor position&lt;/I&gt; always * lies between the element that would be returned by a call * to &#123;@code previous()&#125; and the element that would be * returned by a call to &#123;@code next()&#125;. * An iterator for a list of length &#123;@code n&#125; has &#123;@code n+1&#125; possible * cursor positions, as illustrated by the carets (&#123;@code ^&#125;) below: * &lt;PRE&gt; * Element(0) Element(1) Element(2) ... Element(n-1) * cursor positions: ^ ^ ^ ^ ^ * &lt;/PRE&gt; * Note that the &#123;@link #remove&#125; and &#123;@link #set(Object)&#125; methods are * &lt;i&gt;not&lt;/i&gt; defined in terms of the cursor position; they are defined to * operate on the last element returned by a call to &#123;@link #next&#125; or * &#123;@link #previous()&#125;. * * &lt;p&gt;This interface is a member of the * &lt;a href=&quot;&#123;@docRoot&#125;/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @author Josh Bloch * @see Collection * @see List * @see Iterator * @see Enumeration * @see List#listIterator() * @since 1.2 */public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; ...&#125; next()123456789101112/** * Returns the next element in the list and advances the cursor position. * This method may be called repeatedly to iterate through the list, * or intermixed with calls to &#123;@link #previous&#125; to go back and forth. * (Note that alternating calls to &#123;@code next&#125; and &#123;@code previous&#125; * will return the same element repeatedly.) * * @return the next element in the list * @throws NoSuchElementException if the iteration has no next element */E next(); previous()1234567891011121314/** * Returns the previous element in the list and moves the cursor * position backwards. This method may be called repeatedly to * iterate through the list backwards, or intermixed with calls to * &#123;@link #next&#125; to go back and forth. (Note that alternating calls * to &#123;@code next&#125; and &#123;@code previous&#125; will return the same * element repeatedly.) * * @return the previous element in the list * @throws NoSuchElementException if the iteration has no previous * element */E previous(); CopyOnWriteArrayList 线程安全的ArrayList结构 1234567891011121314151617181920212223242526272829303132333435363738394041/** * A thread-safe variant of &#123;@link java.util.ArrayList&#125; in which all mutative * operations (&#123;@code add&#125;, &#123;@code set&#125;, and so on) are implemented by * making a fresh copy of the underlying array. * * &lt;p&gt;This is ordinarily too costly, but may be &lt;em&gt;more&lt;/em&gt; efficient * than alternatives when traversal operations vastly outnumber * mutations, and is useful when you cannot or don&#x27;t want to * synchronize traversals, yet need to preclude interference among * concurrent threads. The &quot;snapshot&quot; style iterator method uses a * reference to the state of the array at the point that the iterator * was created. This array never changes during the lifetime of the * iterator, so interference is impossible and the iterator is * guaranteed not to throw &#123;@code ConcurrentModificationException&#125;. * The iterator will not reflect additions, removals, or changes to * the list since the iterator was created. Element-changing * operations on iterators themselves (&#123;@code remove&#125;, &#123;@code set&#125;, and * &#123;@code add&#125;) are not supported. These methods throw * &#123;@code UnsupportedOperationException&#125;. * * &lt;p&gt;All elements are permitted, including &#123;@code null&#125;. * * &lt;p&gt;Memory consistency effects: As with other concurrent * collections, actions in a thread prior to placing an object into a * &#123;@code CopyOnWriteArrayList&#125; * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt; * actions subsequent to the access or removal of that element from * the &#123;@code CopyOnWriteArrayList&#125; in another thread. * * &lt;p&gt;This class is a member of the * &lt;a href=&quot;&#123;@docRoot&#125;/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;. * * @param &lt;E&gt; the type of elements held in this collection * @author Doug Lea * @since 1.5 */public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ...&#125; COWIterator123static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; ...&#125; ArrayListget() – arrayList12345public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 检查是否越界，返回对应下标元素 elementData1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access 存储ArrayList中的元素 1private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 空ArrayList 1private static final int DEFAULT_CAPACITY = 10; 1private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 1private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 初始化时的默认大小当初始化ArrayList实例时，若为实例赋大小，则使用 EMPTY_ELEMENTDATA，若不赋大小，则使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA区别在当向空的ArrayList添加元素时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity); &#125; &#125; public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125;... private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;... public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; next()123456789101112public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125; previous()123456789101112public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i];&#125; LinkedListnext()12345678910public E next() &#123; checkForComodification(); if (!hasNext()) throw new NoSuchElementException(); lastReturned = next; next = next.next; nextIndex++; return lastReturned.item;&#125; previous()123456789public E previous() &#123; checkForComodification(); if (!hasPrevious()) throw new NoSuchElementException(); lastReturned = next = (next == null) ? last : next.prev; nextIndex--; return lastReturned.item;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://liminghua.gitee.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"集合","slug":"集合","permalink":"https://liminghua.gitee.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"jdk源码_Collection","slug":"jdk源码-Collection","date":"2020-10-07T07:16:15.000Z","updated":"2021-01-22T03:55:03.735Z","comments":true,"path":"2020/10/07/jdk源码-Collection/","link":"","permalink":"https://liminghua.gitee.io/2020/10/07/jdk%E6%BA%90%E7%A0%81-Collection/","excerpt":"","text":"Collection 集合结构中的根接口 123public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; &#125; forEach 继承Iterable接口，故可调用默认方法forEach AbstractCollection 提供了 Collection 接口的基本实现 123public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; &#123; &#125; iterator()123456/** * Returns an iterator over the elements contained in this collection. * * @return an iterator over the elements contained in this collection */public abstract Iterator&lt;E&gt; iterator(); AbstractList.iterator public abstract class AbstractList extends AbstractCollection implements List 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; Itr12345678910111213141516171819202122232425262728293031323334353637private class Itr implements Iterator&lt;E&gt; &#123; /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; checkForComodification(); try &#123; int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; size()1public abstract int size(); public abstract class AbstractList extends AbstractCollection implements Listpublic class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable ArrayList.size()123456789101112131415/** * The size of the ArrayList (the number of elements it contains). * * @serial */private int size; /** * Returns the number of elements in this list. * * @return the number of elements in this list */public int size() &#123; return size;&#125; boolean isEmpty()123public boolean isEmpty() &#123; return size() == 0;&#125; boolean contains(Object o)12345678910111213public boolean contains(Object o) &#123; Iterator&lt;E&gt; it = iterator(); if (o == null) &#123; while (it.hasNext()) if (it.next() == null) return true; &#125; else &#123; while (it.hasNext()) if (o.equals(it.next())) return true; &#125; return false;&#125; 集合可以存入空对象 123456public static void main(String[] args) &#123; Collection collection = new ArrayList(); collection.add(null); System.out.println(collection.size()==0);//false System.out.println(collection.contains(null));//true&#125; toArray()Object[] toArray()1234567891011public Object[] toArray() &#123; // Estimate size of array; be prepared to see more or fewer elements Object[] r = new Object[size()]; Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) &#123; if (!it.hasNext()) // fewer elements than expected return Arrays.copyOf(r, i); r[i] = it.next(); &#125; return it.hasNext() ? finishToArray(r, it) : r;&#125; 先根据Size()方法预建立一个与集合长度相等的数组，然后进行判断，若迭代过程中发现对象没有预期的多，则直接截取当前的数组返回 T[] toArray(T[] a)123456789101112131415161718192021222324252627public &lt;T&gt; T[] toArray(T[] a) &#123; // Estimate size of array; be prepared to see more or fewer elements int size = size(); T[] r = a.length &gt;= size ? a : (T[]) java.lang.reflect.Array .newInstance(a.getClass().getComponentType(), size); Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) &#123; if (!it.hasNext()) &#123; // fewer elements than expected if (a == r) &#123; r[i] = null; // null-terminate &#125; else if (a.length &lt; i) &#123; return Arrays.copyOf(r, i); &#125; else &#123; System.arraycopy(r, 0, a, 0, i); if (a.length &gt; i) &#123; a[i] = null; &#125; &#125; return a; &#125; r[i] = (T) it.next(); &#125; // more elements than expected return it.hasNext() ? finishToArray(r, it) : r;&#125; 若参数数组a的长度大于集合的长度，则直接用a数组赋值，若小于则利用反射建立一个长度等于集合长度的数组 boolean remove(Object o)12345678910111213141516171819public boolean remove(Object o) &#123; Iterator&lt;E&gt; it = iterator(); if (o == null) &#123; while (it.hasNext()) &#123; if (it.next() == null) &#123; it.remove(); return true; &#125; &#125; &#125; else &#123; while (it.hasNext()) &#123; if (o.equals(it.next())) &#123; it.remove(); return true; &#125; &#125; &#125; return false;&#125; Object.equals123public boolean equals(Object obj) &#123; return (this == obj);&#125; boolean containsAll(Collection&lt;?&gt; c)123456public boolean containsAll(Collection&lt;?&gt; c) &#123; for (Object e : c) if (!contains(e)) return false; return true;&#125; boolean addAll(Collection&lt;? extends E&gt; c)1234567public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified;&#125; boolean removeAll(Collection&lt;?&gt; c)123456789101112public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); boolean modified = false; Iterator&lt;?&gt; it = iterator(); while (it.hasNext()) &#123; if (c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified;&#125; Objects.requireNonNull(c)12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; default boolean removeIf(Predicate&lt;? super E&gt; filter)123456789101112default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed;&#125; 传入一个断言型功能函数，判断，若符合断言要求，remove 12Collection&lt;String&gt; collection = new ArrayList&lt;String&gt;(Arrays.asList(&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;--------&quot;));collection.removeIf(s-&gt;s.equals(&quot;first&quot;)); boolean retainAll(Collection&lt;?&gt; c)123456789101112public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); boolean modified = false; Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) &#123; if (!c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified;&#125; 取交集 遍历集合，若元素存在于参数集合C，则移除，并将modified置为true返回 boolean equals(Object o) AbstractList 12345678910111213141516public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof List)) return false; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) &#123; E o1 = e1.next(); Object o2 = e2.next(); if (!(o1 == null ? o2 == null : o1.equals(o2))) return false; &#125; return !(e1.hasNext() || e2.hasNext());&#125; 先比较参数是否和当前List指向同一对象，再比较参数是否为List实例，然后将两个List中的元素一一对比（若List对象元素不为null，则用Object.equals方法对比，若为null则判断参数List对象中元素是否为null），最后判断长度是否相等 hasNext() ArrayList 123public boolean hasNext() &#123; return cursor != size;&#125; next() ArrayList 1234567891011public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125; instanceof instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。 类的实例包含本身的实例，以及所有直接或间接子类的实例 instanceof左边显式声明的类型与右边操作元必须是同种类或存在继承关系，也就是说需要位于同一个继承树，否则会编译错误 左边的对象实例不能是基础数据类型 null用instanceof跟任何类型比较时都是false int hashCode() 重写Object.equals方法时必须同样重写Object.hashCode方法 如果两个对象equals相等，那么这两个对象的HashCode一定也相同 如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置 123456789101112131415/** * Returns the hash code value for this collection. While the * &lt;tt&gt;Collection&lt;/tt&gt; interface adds no stipulations to the general * contract for the &lt;tt&gt;Object.hashCode&lt;/tt&gt; method, programmers should * take note that any class that overrides the &lt;tt&gt;Object.equals&lt;/tt&gt; * method must also override the &lt;tt&gt;Object.hashCode&lt;/tt&gt; method in order * to satisfy the general contract for the &lt;tt&gt;Object.hashCode&lt;/tt&gt; method. * In particular, &lt;tt&gt;c1.equals(c2)&lt;/tt&gt; implies that * &lt;tt&gt;c1.hashCode()==c2.hashCode()&lt;/tt&gt;. * * @return the hash code value for this collection * @see Object#hashCode() * @see Object#equals(Object) */int hashCode(); default Stream stream() 返回一个不影响数据源的数据序列 1234567891011121314151617/** * Returns a sequential &#123;@code Stream&#125; with this collection as its source. * * &lt;p&gt;This method should be overridden when the &#123;@link #spliterator()&#125; * method cannot return a spliterator that is &#123;@code IMMUTABLE&#125;, * &#123;@code CONCURRENT&#125;, or &lt;em&gt;late-binding&lt;/em&gt;. (See &#123;@link #spliterator()&#125; * for details.) * * @return a sequential &#123;@code Stream&#125; over the elements in this collection * @implSpec The default implementation creates a sequential &#123;@code Stream&#125; from the * collection&#x27;s &#123;@code Spliterator&#125;. * @since 1.8 */default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://liminghua.gitee.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"集合","slug":"集合","permalink":"https://liminghua.gitee.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"首次收到打赏","slug":"首次收到打赏","date":"2020-09-30T02:33:03.000Z","updated":"2021-01-22T06:19:34.635Z","comments":true,"path":"2020/09/30/首次收到打赏/","link":"","permalink":"https://liminghua.gitee.io/2020/09/30/%E9%A6%96%E6%AC%A1%E6%94%B6%E5%88%B0%E6%89%93%E8%B5%8F/","excerpt":"","text":"收到了来自师傅的打赏有师傅真是太好了！(●’◡’●)","categories":[{"name":"生活","slug":"生活","permalink":"https://liminghua.gitee.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://liminghua.gitee.io/tags/%E5%BF%83%E6%83%85/"}]},{"title":"钉钉数据对接说明","slug":"钉钉数据对接说明","date":"2020-09-30T02:00:01.000Z","updated":"2021-01-22T06:23:18.432Z","comments":true,"path":"2020/09/30/钉钉数据对接说明/","link":"","permalink":"https://liminghua.gitee.io/2020/09/30/%E9%92%89%E9%92%89%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%8E%A5%E8%AF%B4%E6%98%8E/","excerpt":"","text":"API调用说明 钉钉服务端api文档 https://ding-doc.dingtalk.com/doc#/serverapi2/gh60vz钉钉api调试工具 https://open-dev.dingtalk.com/apiExplorer#/?devType=org&amp;api=/get_jsapi_ticket 部门获取部门信息 获取部门ID列表 https://oapi.dingtalk.com/department/list?access_token=ACCESS_TOKEN 根据部门ID获取部门详情 https://oapi.dingtalk.com/department/get?access_token=ACCESS_TOKEN&amp;id=123 关键字段说明 department_id 部门id department_name 部门名称 department_parent_id 父部门id，根部门为1 department_status 部门状态：(空值表示正常) 、CHANGED(改动过)、DELETED(部门取消) 部门表1234567891011CREATE TABLE ding_department ( department_id VARCHAR(128) NOT NULL, department_name VARCHAR(128), department_parent_id VARCHAR(128), department_status VARCHAR(64), PRIMARY KEY (department_id));COMMENT ON COLUMN ding_department.department_id IS &#x27;部门id&#x27;;COMMENT ON COLUMN ding_department.department_name IS &#x27;部门名称&#x27;;COMMENT ON COLUMN ding_department.department_parent_id IS &#x27;上级部门id&#x27;;COMMENT ON COLUMN ding_department.department_status IS &#x27;可用状态&#x27;; 员工员工信息 获取员工ID列表 https://oapi.dingtalk.com/topapi/smartwork/hrm/employee/queryonjob?access_token=ACCESS_TOKEN参数说明:https://ding-doc.dingtalk.com/doc#/serverapi2/rafx8t 根据ID获得员工信息 https://oapi.dingtalk.com/user/get?access_token=ACCESS_TOKEN&amp;userid=zhangsan 关键字段说明 employee_department_ids 用户所在部门id列表，注意，是列表。 employee_identity_card 身份证号 employee_status 员工状态：可用，禁用 员工表123456789101112131415CREATE TABLE ding_employee ( employee_union_id VARCHAR(128), employee_name VARCHAR(64), employee_department_ids VARCHAR(255), employee_identity_card VARCHAR2(64), employee_status VARCHAR2(64), employee_user_id VARCHAR(128), PRIMARY KEY (employee_union_id));COMMENT ON COLUMN ding_employee.employee_union_id IS &#x27;员工unionid&#x27;;COMMENT ON COLUMN ding_employee.employee_name IS &#x27;员工姓名&#x27;;COMMENT ON COLUMN ding_employee.employee_department_ids IS &#x27;员工部门名称&#x27;;COMMENT ON COLUMN ding_employee.employee_identity_card IS &#x27;员工身份证号码&#x27;;COMMENT ON COLUMN ding_employee.employee_status IS &#x27;员工状态：可用，禁用&#x27;;COMMENT ON COLUMN ding_employee.employee_user_id IS &#x27;员工id&#x27;; 工作流操作流程 获取流程模板process_code process_code流程模板唯一标识，可在OA管理后台编辑审批表单部分的url中获取 根据process_code批量获取据当前时间120天之内的任意时间段审批实例ID列表 https://ding-doc.dingtalk.com/doc#/serverapi2/hh8lx5 根据审批实例id获取审批实例详情 https://ding-doc.dingtalk.com/doc#/serverapi2/xgqkvx 关键字段说明 business_id 审批实例业务编号 一条审批流虽然会因为更新或撤销等操作新建审批流实例，但business_id仍保留一致 Attached_process_instance_ids 审批附属实例列表，当已经通过的审批实例被修改或重置，会生成一个新的实例，作为继承审批实例的附属。如果想知道当前已经通过的审批实例的状态，可以依次遍历它的附属列表，查询里面每个实例的biz_action biz biz_action 审批实例业务动作，MODIFY表示该审批实例是基于原来的实例修改而来的，REVOKE表示该审批实例对原来的实例进行撤销，NONE表示正常发起 form_component_values 表单详情列表,流程中表单数据的集合 status 审批状态，分为NEW（新创造）RUNNING（运行中）终止（被终止）完成（完成） 重型员工请假流程表1234567891011121314151617181920212223242526272829CREATE TABLE ding_leave_approval ( leave_id NUMBER NOT NULL, leave_employee_user_id NUMBER, leave_start VARCHAR(255), leave_end VARCHAR(255), leave_duration VARCHAR(255), leave_type VARCHAR(255), leave_reason VARCHAR(255), leave_title VARCHAR(255), leave_result VARCHAR(255), leave_status VARCHAR(255), leave_business_id NUMBER, leave_attached_ids VARCHAR(255), leave_biz_action VARCHAR(255), PRIMARY KEY (leave_id));COMMENT ON COLUMN ding_leave_approval.leave_id IS &#x27;请假id&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_employee_user_id IS &#x27;请假职员id&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_start IS &#x27;请假开始时间&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_end IS &#x27;请假结束时间&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_duration IS &#x27;请假时长&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_type IS &#x27;请假类型&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_reason IS &#x27;请假原因&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_title IS &#x27;标题&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_result IS &#x27;结果&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_status IS &#x27;状态&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_business_id IS &#x27;业务流程id&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_attached_ids IS &#x27;附属流程id&#x27;;COMMENT ON COLUMN ding_leave_approval.leave_biz_action IS &#x27;审批实例业务动作&#x27;; 考勤 根据用户ID列表获取180天内的考勤结果，一次最多50条 https://oapi.dingtalk.com/attendance/list?access_token=ACCESS_TOKEN 参数说明: https://ding-doc.dingtalk.com/doc#/serverapi2/ul33mm 关键字段说明 base_check_time 打卡基准时间 user_check_time 员工实际打卡时间 check_type 打卡类型-上下班 time_result 打卡的时间结果 locationResult 位置结果(范围外/范围内) 考勤表123456789101112131415161718192021CREATE TABLE ding_attendance ( attendance_id VARCHAR(128), attendance_employee_user_id VARCHAR(128), attendance_base_check_time VARCHAR(128), attendance_user_check_time VARCHAR(128), attendance_group_id VARCHAR(255), attendance_check_type VARCHAR(255), attendance_time_result VARCHAR(64), attendance_location_result VARCHAR(255), attendance_work_date VARCHAR(255), PRIMARY KEY (attendance_id));COMMENT ON COLUMN ding_attendance.attendance_id IS &#x27;考勤id&#x27;;COMMENT ON COLUMN ding_attendance.attendance_employee_user_id IS &#x27;考勤员工id&#x27;;COMMENT ON COLUMN ding_attendance.attendance_base_check_time IS &#x27;打卡基准时间&#x27;;COMMENT ON COLUMN ding_attendance.attendance_user_check_time IS &#x27;员工实际打卡时间&#x27;;COMMENT ON COLUMN ding_attendance.attendance_group_id IS &#x27;考勤组id&#x27;;COMMENT ON COLUMN ding_attendance.attendance_check_type IS &#x27;打卡类型-上下班&#x27;;COMMENT ON COLUMN ding_attendance.attendance_time_result IS &#x27;时间结果&#x27;;COMMENT ON COLUMN ding_attendance.attendance_location_result IS &#x27;打卡范围结果&#x27;;COMMENT ON COLUMN ding_attendance.attendance_work_date IS &#x27;工作日&#x27;;","categories":[{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"钉钉","slug":"钉钉","permalink":"https://liminghua.gitee.io/tags/%E9%92%89%E9%92%89/"}]},{"title":"jdk1.8_Optional","slug":"jdk1-8-Optional","date":"2020-08-29T01:17:18.000Z","updated":"2021-01-22T03:55:03.729Z","comments":true,"path":"2020/08/29/jdk1-8-Optional/","link":"","permalink":"https://liminghua.gitee.io/2020/08/29/jdk1-8-Optional/","excerpt":"","text":"概述 主要用于解决空指针异常（NullPointerException）类似包含有可选值的包装类，Optional 类既可以含有对象也可以为空 12345678910111213141516171819/** * A container object which may or may not contain a non-null value. * If a value is present, &#123;@code isPresent()&#125; will return &#123;@code true&#125; and * &#123;@code get()&#125; will return the value. * * &lt;p&gt;Additional methods that depend on the presence or absence of a contained * value are provided, such as &#123;@link #orElse(java.lang.Object) orElse()&#125; * (return a default value if value not present) and * &#123;@link #ifPresent(java.util.function.Consumer) ifPresent()&#125; (execute a block * of code if the value is present). * * &lt;p&gt;This is a &lt;a href=&quot;../lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt; * class; use of identity-sensitive operations (including reference equality * (&#123;@code ==&#125;), identity hash code, or synchronization) on instances of * &#123;@code Optional&#125; may have unpredictable results and should be avoided. * * @since 1.8 */public final class Optional&lt;T&gt; &#123;...&#125; of()&amp;ofNullable() 构造带有值的Optional类of()方法中的参数不允许为null，传入null会导致NullPointerException异常若调用ofNullable()方法并传入空值则实际上相当于直接调用empty()方法实例化一个空的Optional 123456Optional&lt;String&gt; optional = Optional.of(&quot;value&quot;);Optional&lt;String&gt; optionalNull = Optional.ofNullable(null);Optional&lt;String&gt; emptyOpt = Optional.empty();System.out.println(optional.get());//valueSystem.out.println(emptyOpt.get());//NoSuchElementExceptionSystem.out.println(optionalNull.get());//NoSuchElementException 123456789101112/** * Returns an &#123;@code Optional&#125; describing the specified value, if non-null, * otherwise returns an empty &#123;@code Optional&#125;. * * @param &lt;T&gt; the class of the value * @param value the possibly-null value to describe * @return an &#123;@code Optional&#125; with a present value if the specified value * is non-null, otherwise an empty &#123;@code Optional&#125; */public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123; return value == null ? empty() : of(value);&#125; isPresent()&amp;ifPresent() isPresent() 判断是否为空ifPresent() 判断是否为空,不为空则执行方法内的lambda表达式(实现消费型接口) 123456789101112131415161718192021/** * Return &#123;@code true&#125; if there is a value present, otherwise &#123;@code false&#125;. * * @return &#123;@code true&#125; if there is a value present, otherwise &#123;@code false&#125; */public boolean isPresent() &#123; return value != null;&#125;/** * If a value is present, invoke the specified consumer with the value, * otherwise do nothing. * * @param consumer block to be executed if a value is present * @throws NullPointerException if value is present and &#123;@code consumer&#125; is * null */public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123; if (value != null) consumer.accept(value);&#125; 1234Optional&lt;String&gt; optional = Optional.of(&quot;value&quot;);Optional&lt;String&gt; optionalNull = Optional.ofNullable(null);optional.ifPresent((s) -&gt; System.out.println(s));//valueoptionalNull.ifPresent(System.out::println);//不执行 orElse()&amp;orElseGet()&amp;orElseThrow() orElse() 若Optional对象为空值则返回方法传入的值orElseGet() 若Optional对象为空值则执行方法内的lambda表达式(供给型功能函数)orElseThrow() 若Optional对象为空值则抛出指定的异常(供给型功能函数) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Return the value if present, otherwise return &#123;@code other&#125;. * * @param other the value to be returned if there is no value present, may * be null * @return the value, if present, otherwise &#123;@code other&#125; */public T orElse(T other) &#123; return value != null ? value : other;&#125; /** * Return the value if present, otherwise invoke &#123;@code other&#125; and return * the result of that invocation. * * @param other a &#123;@code Supplier&#125; whose result is returned if no value * is present * @return the value if present otherwise the result of &#123;@code other.get()&#125; * @throws NullPointerException if value is not present and &#123;@code other&#125; is * null */public T orElseGet(Supplier&lt;? extends T&gt; other) &#123; return value != null ? value : other.get();&#125; /** * Return the contained value, if present, otherwise throw an exception * to be created by the provided supplier. * * @apiNote A method reference to the exception constructor with an empty * argument list can be used as the supplier. For example, * &#123;@code IllegalStateException::new&#125; * * @param &lt;X&gt; Type of the exception to be thrown * @param exceptionSupplier The supplier which will return the exception to * be thrown * @return the present value * @throws X if there is no value present * @throws NullPointerException if no value is present and * &#123;@code exceptionSupplier&#125; is null */public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123; if (value != null) &#123; return value; &#125; else &#123; throw exceptionSupplier.get(); &#125;&#125; 12345678Optional&lt;String&gt; optionalNull = Optional.ofNullable(null);System.out.println(optionalNull.orElse(&quot;值为null&quot;));//值为nullSystem.out.println(optionalNull.orElseGet(()-&gt;&quot;值为null&quot;));try &#123; optionalNull.orElseThrow(Exception::new);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; map()&amp;flatMap() map()方法，若传入的方法存在值，则返回方法对应类型的Optional对象，否则返回一个空的Optional同样，但入参需要是Optional对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * If a value is present, apply the provided mapping function to it, * and if the result is non-null, return an &#123;@code Optional&#125; describing the * result. Otherwise return an empty &#123;@code Optional&#125;. * * @apiNote This method supports post-processing on optional values, without * the need to explicitly check for a return status. For example, the * following code traverses a stream of file names, selects one that has * not yet been processed, and then opens that file, returning an * &#123;@code Optional&lt;FileInputStream&gt;&#125;: * * &lt;pre&gt;&#123;@code * Optional&lt;FileInputStream&gt; fis = * names.stream().filter(name -&gt; !isProcessedYet(name)) * .findFirst() * .map(name -&gt; new FileInputStream(name)); * &#125;&lt;/pre&gt; * * Here, &#123;@code findFirst&#125; returns an &#123;@code Optional&lt;String&gt;&#125;, and then * &#123;@code map&#125; returns an &#123;@code Optional&lt;FileInputStream&gt;&#125; for the desired * file if one exists. * * @param &lt;U&gt; The type of the result of the mapping function * @param mapper a mapping function to apply to the value, if present * @return an &#123;@code Optional&#125; describing the result of applying a mapping * function to the value of this &#123;@code Optional&#125;, if a value is present, * otherwise an empty &#123;@code Optional&#125; * @throws NullPointerException if the mapping function is null */public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Optional.ofNullable(mapper.apply(value)); &#125;&#125;/** * If a value is present, apply the provided &#123;@code Optional&#125;-bearing * mapping function to it, return that result, otherwise return an empty * &#123;@code Optional&#125;. This method is similar to &#123;@link #map(Function)&#125;, * but the provided mapper is one whose result is already an &#123;@code Optional&#125;, * and if invoked, &#123;@code flatMap&#125; does not wrap it with an additional * &#123;@code Optional&#125;. * * @param &lt;U&gt; The type parameter to the &#123;@code Optional&#125; returned by * @param mapper a mapping function to apply to the value, if present * the mapping function * @return the result of applying an &#123;@code Optional&#125;-bearing mapping * function to the value of this &#123;@code Optional&#125;, if a value is present, * otherwise an empty &#123;@code Optional&#125; * @throws NullPointerException if the mapping function is null or returns * a null result */public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Objects.requireNonNull(mapper.apply(value)); &#125;&#125; 12345678910111213141516171819202122232425262728293031class FlightTicketInfo &#123; private String orderNumber; public String getOrderNumber() &#123; return orderNumber; &#125;&#125;public class OptionalTest &#123; @Test public void testMap() &#123; FlightTicketInfo flightTicketInfo = null; Optional&lt;Optional&lt;String&gt;&gt; s1 = Optional.ofNullable(flightTicketInfo). map(OptionalTest::getOrderNumber); Optional&lt;String&gt; s2 = Optional.ofNullable(flightTicketInfo). map(FlightTicketInfo::getOrderNumber); Optional&lt;String&gt; s3 = Optional.ofNullable(flightTicketInfo). flatMap(OptionalTest::getOrderNumber); &#125; private static Optional&lt;String&gt; getOrderNumber(FlightTicketInfo flightTicketInfo) &#123; return Optional.ofNullable(flightTicketInfo).map(f -&gt; f.getOrderNumber()); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jkd1.8","slug":"jkd1-8","permalink":"https://liminghua.gitee.io/tags/jkd1-8/"},{"name":"Optional","slug":"Optional","permalink":"https://liminghua.gitee.io/tags/Optional/"}]},{"title":"jdk1.8_默认方法","slug":"jdk1-8-默认方法","date":"2020-07-14T05:43:26.000Z","updated":"2021-01-22T03:55:03.733Z","comments":true,"path":"2020/07/14/jdk1-8-默认方法/","link":"","permalink":"https://liminghua.gitee.io/2020/07/14/jdk1-8-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/","excerpt":"","text":"默认方法1234567891011121314151617181920212223public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; ... default void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final ListIterator&lt;E&gt; li = this.listIterator(); while (li.hasNext()) &#123; li.set(operator.apply(li.next())); &#125; &#125; ... default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125; &#125; ... ...&#125; 接口类中支持申明带有实现的方法，可以由接口实现类的实例调用 和抽象类的区别 一个类只能继承一个抽象类；但是一个类可以实现多个接口。 抽象类有实例变量，而接口只能有类变量 多继承多实现中的优先级 由于一个类可以实现多个接口，所以当一个类继承了多个签名相同的方法，类在选择方法时的优先级规则： 类中的方法优先级最高，类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。 如果第一条无法判断，那么子接口的优先级更高：方法签名相同时，优先选择拥有最具体实现的默认方法的接口， 即如果B继承了A，那么B就比A更加具体。 最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法， 显式地选择使用哪一个默认方法的实现。 场景1：12345public interface A &#123; default void hello() &#123; System.out.println(&quot;hello from A&quot;); &#125;&#125; 12345public interface B extends A &#123; default void hello() &#123; System.out.println(&quot;hello from B&quot;); &#125;&#125; 12345public class C implements A, B &#123; public static void main(String[] args) &#123; new C().hello();//hello from B &#125;&#125; 类中无方法，B继承了A，故认为B中的hello()更具体，输出“hello from B” 场景2： 若C继承了A的实现类D 123public class D implements A &#123;&#125; 123456public class C extends D implements A, B &#123; public static void main(String[] args) &#123; new C().hello();//hello from B &#125;&#125; C继承了D，但D没有对A的默认方法进行重写，故比较AB，还是输出“hello from B” 场景3： 若D中覆盖了A的默认方法 12345public class D implements A &#123; public void hello() &#123; System.out.println(&quot;hello from D&quot;); &#125;&#125; 父类中方法具有更高优先级，打印“hello from D” 场景4： 若B不再继承A 12345public interface A &#123; default void hello() &#123; System.out.println(&quot;hello from A&quot;); &#125;&#125; 12345public interface B &#123; default void hello() &#123; System.out.println(&quot;hello from B&quot;); &#125;&#125; 12345public class C implements A, B &#123; public static void main(String[] args) &#123; new C().hello(); &#125;&#125; 由于编译器无法识别A还是B的实现更加具体，所以会抛出编译错误：“C inherits unrelated defaults for hello() from types A and B”。解决冲突，可以在C中覆盖hello()方法并在方法内显示的选择调用A还是B的方法 1234567891011public class C extends D implements A, B &#123; public void hello() &#123; // 显式地选择调用接口B中的方法 // 同理，要调用接口A中的方法，可以这样：A.super.hello() B.super.hello(); &#125; public static void main(String[] args) &#123; new C().hello();//hello from B &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jkd1.8","slug":"jkd1-8","permalink":"https://liminghua.gitee.io/tags/jkd1-8/"},{"name":"默认方法","slug":"默认方法","permalink":"https://liminghua.gitee.io/tags/%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"}]},{"title":"jdk1.8_lambda","slug":"jdk1-8-lambda","date":"2020-06-24T11:44:55.000Z","updated":"2021-01-22T03:55:03.726Z","comments":true,"path":"2020/06/24/jdk1-8-lambda/","link":"","permalink":"https://liminghua.gitee.io/2020/06/24/jdk1-8-lambda/","excerpt":"","text":"参考Haskell-函数式编程 核心功能性函数接口（有且只有一个抽象方法的接口） Consumer :消费型接口 void acept(T t);1234//消费型接口Consumer，输入一个参数，对其进行打印输出 Consumer&lt;String&gt; consumer = (x) -&gt; System.out.println(x); //打印字符串 consumer.accept(&quot;Hello world!&quot;); Supplier :供给型接口 T get();1234//供给型接口Supplier，返回指定字符串Supplier&lt;String&gt; supplier = () -&gt; &quot;Hello world!&quot;;//获取字符串supplier.get(); Function&lt;T,R&gt; :函数型接口 R apply(T t);123Function&lt;String, Integer&gt; function = (x) -&gt; x.length();//获取字符串长度function.apply(&quot;Hello world!&quot;); Predicate :断言型接口 boolean test(T t);1234//断言型接口Predicate，输入数字，判断是否大于0Predicate&lt;Integer&gt; predicate = (x) -&gt; x &gt; 0;//获取判断结果predicate.test(10); 案例1.Iterable.forEach(Consumer&lt;? super T&gt; action)123456789List&lt;String&gt; soutList = Arrays.asList(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;);soutList.forEach(out-&gt; System.out.println(out));soutList.forEach(System.out::println);Page p = new Page(&quot;content&quot;);Page p = Page.new(&quot;content&quot;);public static Stream&lt;Page&gt; createPagesFrom(Stream&lt;String&gt;; contents) &#123; return contents.map(Page::new).&#125; 1). Iterable接口允许一个对象成为forEach的目标2). 这里的forEach被声明为一个默认方法，并接收了一个消费者类型的函数接口，先查找匹配对应的操作，若不为空则执行操作3). 接口中的默认方法可以不被实现类实现4). 如上代码中，输出集合soutList调用了foreach方法，箭头左边是参数，右边是抽象方法的实现内容或已有方法的引用5). 当参数列表中的参数和方法签名匹配时，可以通过 :: 直接引用方法，包括构造方法2.Collection.stream()、Stream、Stream#filter(Predicate)、Collector、Collectors、Collectors#toList()1234567891011121314 /** * Complete this for Exercise_2_Test#getAllPersonsEligibleToVote * * 根据给定年龄返回给定选民集合中合法年龄的选民集合 * @param potentialVoters - voters to filter * @param legalAgeOfVoting - age where it&#x27;s legal to vote * @return a list of eligible voters */ public static List&lt;Person&gt; eligibleVoters(List&lt;Person&gt; potentialVoters, int legalAgeOfVoting) &#123; Stream&lt;Person&gt; personStream = potentialVoters.stream().filter( person -&gt; person.getAge()&gt;=legalAgeOfVoting ); return personStream.collect(Collectors.toList()); &#125; 1). Collection#stream() 返回一个Stream序列2). Stream 流- A sequence of elements supporting sequential and parallel aggregate operations - 支撑顺序和并行聚合操作元素的序列 - lazy： computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed. - 惰式执行：即仅在终端操作启动时才执行对源数据的计算，并且仅在需要时使用源元素。 - 在对流进行“操作”（类似查询和过滤）时，这些行为应该是无干扰（不修改流的数据源）且无状态（其结果不依赖于流管道执行过程中可能改变的任何状态）的 - 消费性质，只使用一次，不可以被重用 3). Stream#filter(Predicate) 对流进行过滤 中间操作4). Predicate 断言功能性函数接口，返回Boolean值 见上文5). Stream.collect()- 返回一个结果容器 - &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector) - &lt;R&gt; 结果的类型 - &lt;A&gt; Collector的积累类型 6). Collector 执行结果转换 Collectors 实现Collector的各种还原操作- public interface Collector&lt;T, A, R&gt; - &lt;T&gt; 输入元素的类型 - &lt;A&gt; 还原运算的可变累积型（通常隐藏作为一个实现细节） - &lt;R&gt; 还原运算的结果类 7). Collectors#toList() 返回一个Collector ，其累积的输入元素融入到一个新的List中- public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() - &lt;T&gt; 输入元素的类型 3.Stream#map(Function)12345678910 /** * Apply a mapping of Books to titles (Strings) * * 将书籍的标题映射到一个新的List&lt;String&gt;* @param books - books to transform * @return list of book titles */ public static List&lt;String&gt; titlesOf(List&lt;Book&gt; books) &#123; return books.stream().map(Book::getTitle).collect(Collectors.toList()); &#125; 1). Stream#map(Function)- 返回指定类型的流 中间操作 - Function 函数型功能接口 见上文 - java.util.stream.Stream&lt;T&gt; &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) - &lt;? super T&gt;/&lt;? extends T&gt; &lt;? super T&gt;表示包括T在内的任何T的父类，&lt;? extends T&gt;表示包括T在内的任何T的子类","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jkd1.8","slug":"jkd1-8","permalink":"https://liminghua.gitee.io/tags/jkd1-8/"},{"name":"lambda","slug":"lambda","permalink":"https://liminghua.gitee.io/tags/lambda/"}]},{"title":"jdk1.8_Base64","slug":"jdk1-8-Base64","date":"2020-06-07T06:44:10.000Z","updated":"2021-01-22T03:55:03.724Z","comments":true,"path":"2020/06/07/jdk1-8-Base64/","link":"","permalink":"https://liminghua.gitee.io/2020/06/07/jdk1-8-Base64/","excerpt":"","text":"Base64static class Base64.Encoder 该类实现一个编码器，使用 Base64 编码来编码字节数据。 static class Base64.Decoder 该类实现一个解码器，使用 Base64 编码来解码字节数据。 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String args[])&#123; try&#123; // 使用基本编码 String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;Base64 编码字符串 (基本) :&quot; + base64encodedString); //Base64 编码字符串 (基本) :cnVub29iP2phdmE4 // 解码 byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString); System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;)); //原始字符串: runoob?java8 base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString); //Base64 编码字符串 (URL) :cnVub29iP2phdmE4 StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; 10; ++i) &#123; stringBuilder.append(UUID.randomUUID().toString()); &#125; byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;); String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes); System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString); //Base64 编码字符串 (MIME) : //ZTA4NjkwNzktYTcxZi00NWQwLWE0MmMtOTVlN2Y5NDZhNjNmNzRkMDIzZGEtZjI3Zi00NDhkLTlk //YzMtYzNlYmJkNjFjMzA2NDNhZjhhOWMtYTVlZC00YzIwLTgxMTItMjhkZTRiYjMxZjc2NzBjMzMy //MjctZTQyZC00MzYzLWE1ZDItMjM3MjM5ZTM0ZTQyYTYxMzFlMDUtOWJlZC00MGQ4LThjNTgtYWYy //ZWNmODgwNjBkYjEzOGM3OTYtOGRjYi00ODA4LWE5MmEtOWEyZDllOWI1ODVlNDBjNTMwYjctYjJj //NC00MDM4LWE5NjEtMzcwZjgyZDY0ZDU1MWY0OTNjMTEtYzc2NC00MmIxLTg4OTQtOTI5M2ZjMjA2 //OWUyOTgzZDM4YmMtMjZkZC00OTg2LWJhYWUtNjdjMTkxMjkzMDllMTI4MGQwMjQtM2JmZi00MTA1 //LTllZTItMTkxMjVkMTAzYWZk &#125;catch(UnsupportedEncodingException e)&#123; System.out.println(&quot;Error :&quot; + e.getMessage()); &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jkd1.8","slug":"jkd1-8","permalink":"https://liminghua.gitee.io/tags/jkd1-8/"},{"name":"Base64","slug":"Base64","permalink":"https://liminghua.gitee.io/tags/Base64/"}]},{"title":"jdk1.8_时间类","slug":"jdk1-8-时间类","date":"2020-05-26T07:59:29.000Z","updated":"2021-01-22T03:55:03.731Z","comments":true,"path":"2020/05/26/jdk1-8-时间类/","link":"","permalink":"https://liminghua.gitee.io/2020/05/26/jdk1-8-%E6%97%B6%E9%97%B4%E7%B1%BB/","excerpt":"","text":"java.timeLocalDate(年月日) 本地日期和时间 1. 最值 最大支持 +999999999-12-31 最小支持-999999999-01-01 2. 比较方法 equals 12345678LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);if(today.equals(tomorrow.minusDays(1))) &#123; System.out.println(&quot;true&quot;);&#125;else &#123; System.out.println(&quot;false&quot;);&#125; 3. now()方法 获取当前时间，无参时为当前系统默认时区，参数为时区id 123456789101112131415161718192021222324252627282930/** * Obtains the current date from the system clock in the specified time-zone. * &lt;p&gt; * This will query the &#123;@link Clock#system(ZoneId) system clock&#125; to obtain the current date. * Specifying the time-zone avoids dependence on the default time-zone. * &lt;p&gt; * Using this method will prevent the ability to use an alternate clock for testing * because the clock is hard-coded. * * @param zone the zone ID to use, not null * @return the current date using the system clock, not null */public static LocalDate now(ZoneId zone) &#123; return now(Clock.system(zone));&#125;/** * Obtains the current date from the system clock in the default time-zone. * &lt;p&gt; * This will query the &#123;@link Clock#systemDefaultZone() system clock&#125; in the default * time-zone to obtain the current date. * &lt;p&gt; * Using this method will prevent the ability to use an alternate clock for testing * because the clock is hard-coded. * * @return the current date using the system clock and default time-zone, not null */public static LocalDate now() &#123; return now(Clock.systemDefaultZone()); &#125; 4. plus()方法 public LocalDate plus(long amountToAdd, TemporalUnit unit) amountToAdd 要增加的总数 ；unit 时间单位 详见 ChronoUnit(TemporalUnit的实现类) 1234LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);//plusYears(long yearsToAdd)\\plusMonths(long monthsToAdd)\\plusWeeks(long weeksToAdd)\\plusDays(long daysToAdd) 5. minus()方法 public LocalDate minus(long amountToSubtract, TemporalUnit unit) 1234LocalDate today = LocalDate.now();LocalDate tomorrow = today.minus(1, ChronoUnit.DAYS);//minusYears(long yearsToSubtract)\\minusMonths(long monthsToSubtract)\\minusWeeks(long weeksToSubtract)\\minusDays(long daysToSubtract) 6. of()方法、getDayOfWeek()方法 LocalDate of(int year, Month month, int dayOfMonth)/LocalDate of(int year, int month, int dayOfMonth)LocalDate.getDayOfWeek() 判断传入日期是一周中的第几天 return DayOfWeek对象 1234LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek);//FRIDAYSystem.out.println(dayOfWeek.getValue());//5 7. DateTimeFormatter 格式化时间，线程安全，类内创建一次可复用 12345678910111213141516//实例化 不指定时区DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm&quot;);//实例化 指定时区DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;E, yyyy-MMMM-dd HH:mm&quot;, Locale.US);ZonedDateTime zdt = ZonedDateTime.now();DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm ZZZZ&quot;);System.out.println(formatter.format(zdt));//2020-09-28T11:55 GMT+08:00DateTimeFormatter zhFormatter = DateTimeFormatter.ofPattern(&quot;yyyy MMM dd EE HH:mm&quot;, Locale.CHINA);System.out.println(zhFormatter.format(zdt));//2020 九月 28 星期一 11:55DateTimeFormatter usFormatter = DateTimeFormatter.ofPattern(&quot;E, MMMM/dd/yyyy HH:mm&quot;, Locale.US);System.out.println(usFormatter.format(zdt));//Mon, September/28/2020 11:55System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(zdt));//2020-09-28T11:55:39.209+08:00[Asia/Shanghai] 保留字母定义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849* All letters &#x27;A&#x27; to &#x27;Z&#x27; and &#x27;a&#x27; to &#x27;z&#x27; are reserved as pattern letters. The* following pattern letters are defined:* &lt;pre&gt;* Symbol Meaning Presentation Examples* ------ ------- ------------ -------* G era text AD; Anno Domini; A* u year year 2004; 04* y year-of-era year 2004; 04* D day-of-year number 189* M/L month-of-year number/text 7; 07; Jul; July; J* d day-of-month number 10** Q/q quarter-of-year number/text 3; 03; Q3; 3rd quarter* Y week-based-year year 1996; 96* w week-of-week-based-year number 27* W week-of-month number 4* E day-of-week text Tue; Tuesday; T* e/c localized day-of-week number/text 2; 02; Tue; Tuesday; T* F week-of-month number 3** a am-pm-of-day text PM* h clock-hour-of-am-pm (1-12) number 12* K hour-of-am-pm (0-11) number 0* k clock-hour-of-am-pm (1-24) number 0** H hour-of-day (0-23) number 0* m minute-of-hour number 30* s second-of-minute number 55* S fraction-of-second fraction 978* A milli-of-day number 1234* n nano-of-second number 987654321* N nano-of-day number 1234000000** V time-zone ID zone-id America/Los_Angeles; Z; -08:30* z time-zone name zone-name Pacific Standard Time; PST* O localized zone-offset offset-O GMT+8; GMT+08:00; UTC-08:00;* X zone-offset &#x27;Z&#x27; for zero offset-X Z; -08; -0830; -08:30; -083015; -08:30:15;* x zone-offset offset-x +0000; -08; -0830; -08:30; -083015; -08:30:15;* Z zone-offset offset-Z +0000; -0800; -08:00;** p pad next pad modifier 1** &#x27; escape for text delimiter* &#x27;&#x27; single quote literal &#x27;* [ optional section start* ] optional section end* # reserved for future use* &#123; reserved for future use* &#125; reserved for future use LocalDateTime(年月日时分秒) 本地日期和时间 1. 常用方法案例12345678910111213141516171819LocalDateTime ldt = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = ldt.getDayOfWeek();System.out.println(dayOfWeek); // WEDNESDAYMonth month = ldt.getMonth();System.out.println(month); // DECEMBERlong minuteOfDay = ldt.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); // 23*60+59=1439long dayOfWeekLong = ldt.getLong(ChronoField.DAY_OF_WEEK);System.out.println(dayOfWeekLong); // 3DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);LocalDateTime parsed = LocalDateTime.parse(&quot;2016-12-01 23:59:59&quot;, formatter);String string = parsed.format(formatter);System.out.println(string); // 2016-12-01 23:59:59 2. Instant时间戳 在java.util.Date类与LocalDate、LocalDateTime类之间转换中 均可以通过Instant作为中间类完成转换 1234567LocalDateTime ldt = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);//获取当前默认时区下ldt转换成的时间戳 Instant instant = ldt.atZone(ZoneId.systemDefault()).toInstant(); Date legacyDate = Date.from(instant); System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 LocalTime(时分秒) 本地日期和时间 1. Clock12345678Clock clock = Clock.systemDefaultZone();//返回1970-01-01T00:00Z (UTC)至今的毫秒数，即按毫秒单位的unix时间戳long t0 = clock.millis();System.out.println(t0);Instant instant = clock.instant();Date legacyDate = Date.from(instant);System.out.println(legacyDate); 2. ZoneId.getRules(),isBefore() getRules 当前默认时区与指定时区间的转换公式isBefore 当前时间是否在指定时间之前ChronoUnit.between 按指定时间单位计算俩时间的差 1234567891011121314151617181920212223242526272829303132333435ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);System.out.println(zone1.getRules());//ZoneRules[currentStandardOffset=+01:00]System.out.println(zone2.getRules());//ZoneRules[currentStandardOffset=-03:00]// timeLocalTime now1 = LocalTime.now(zone1);//10:17:39.043LocalTime now2 = LocalTime.now(zone2);//05:17:39.050System.out.println(now1);System.out.println(now2);System.out.println(now1.isBefore(now2)); // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween);//-4System.out.println(minutesBetween);//-299// create timeLocalTime now = LocalTime.now();System.out.println(now);//16:17:39.052LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late);//23:59:59DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime formateTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);System.out.println(formateTime);//13:37 ZonedDateTime 带时区的日期和时间(ISO-8601) 12ZonedDateTime zonedDateTime = ZonedDateTime.now();System.out.println(zonedDateTime);//2020-09-28T17:19:44.836+08:00[Asia/Shanghai]","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"jkd1.8","slug":"jkd1-8","permalink":"https://liminghua.gitee.io/tags/jkd1-8/"},{"name":"时间类","slug":"时间类","permalink":"https://liminghua.gitee.io/tags/%E6%97%B6%E9%97%B4%E7%B1%BB/"}]},{"title":"简单代码演示控制反转IOC和依赖注入DI","slug":"简单的用代码理解控制反转IOC和依赖注入DI","date":"2020-04-26T07:43:16.000Z","updated":"2021-01-22T03:55:03.784Z","comments":true,"path":"2020/04/26/简单的用代码理解控制反转IOC和依赖注入DI/","link":"","permalink":"https://liminghua.gitee.io/2020/04/26/%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5DI/","excerpt":"","text":"ioc（Inversion of Control） 控制反转，也可以称为依赖倒置，即当A要调用B时，A无需主动获取，会有人主动把B送过来供A使用，以减少在A的代码中存在B，导致模块间的高度耦合。 正常的代码控制流程1.创建一个接口Car 123public interface Car &#123; void go();&#125; 2.定义两种车实现接口car 12345678910111213public class Benz implements Car &#123; public void go() &#123; System.out.println(&quot;benz go......&quot;); &#125;&#125;public class BMW implements Car&#123; public void go() &#123; System.out.println(&quot;bmw go......&quot;); &#125;&#125; 3.人要开车 123456789public class Person &#123; Car car=new Benz(); void DriveCar()&#123; System.out.println(&quot;begin drive&quot;); car.go(); &#125;&#125; 这种方式是我们常见的代码控制流程，人想要开车，需要自己实例化，且这个人只能开一种车。 如何让他可以想开什么车就开什么车呢？ 通过依赖注入 依赖注入的方式DI（Dependency Injection） 依赖注入是实现控制反转的方式之一。 看一下修改后的person类 123456789101112public class Person &#123; Car car=null; public Person(Car car)&#123; this.car=car; &#125; void driveCar()&#123; System.out.println(&quot;begin drive&quot;); car.go(); &#125;&#125; 现在的Person类已经不自己实例化车的对象了，而是通过构造函数来获得车的对象，所以，这个类就可以开各种车了，只要这个车实现了Car接口就可以。看一下如何使用Person类 1234public static void main(String[] args) &#123; Person person=new Person(new Benz()); person.driveCar();&#125; 现在的Person类可以开不止一种车，只要你通过构造函数传递进来。在这个例子中，Car对象就是Person类的依赖，当我们实例化Person类时，将一个Car的实例传递给Person类，就是依赖注入，我们的Person类从而实现了控制反转。控制反转到底反转了什么？有种说法是这样的：所谓控制反转，反转的是获取对象依赖的过程。控制权反转后，获取依赖对象的过程由自身管理变为由IOC容器注入。 Spring实现依赖注入的方式 在上面的这行代码中Person p=new Person(new Benz());，我们通过手动的方式new了一个Benz()的对象，然后将其注入到Person类中。而Spring不这么干，因为Spring觉得，你这行代码实例化了一个具体的Benz类，如果你以后想要在这里实例化一个BMW类的话，岂不是要修改代码？那我干脆写到配置文件里好了，即便你将来要该注意，至少不需要修改代码，于是就有了下面的配置 123456&lt;beans&gt; &lt;bean id=&quot;car&quot; class=&quot;com.XXX.Benz&quot; /&gt; &lt;bean id=&quot;person&quot; class=&quot;com.XXX.Person&quot; &gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 从配置文件中获取Person类的对象时，car对象会被自动装配进来，而person对象不需要关心到底是哪个具体的类被传递进来了。所以，Spring作为一个IOC框架主要做了两步：创建对象和组装对象之间的关系。","categories":[{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liminghua.gitee.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://liminghua.gitee.io/tags/Spring/"}]},{"title":"About Me","slug":"aboutMe","date":"2020-04-17T06:40:38.000Z","updated":"2021-01-22T03:55:03.716Z","comments":true,"path":"2020/04/17/aboutMe/","link":"","permalink":"https://liminghua.gitee.io/2020/04/17/aboutMe/","excerpt":"","text":"A Coder, live in XuZhou, China . 姓名：李明华 现居：江苏徐州 GitHub：LiMingHuaGit QQ：2290320152 微信：someonelover0","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-04-17T04:40:04.328Z","updated":"2021-01-22T03:55:03.722Z","comments":true,"path":"2020/04/17/hello-world/","link":"","permalink":"https://liminghua.gitee.io/2020/04/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://liminghua.gitee.io/categories/LeetCode/"},{"name":"工作","slug":"工作","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"工具","slug":"工具","permalink":"https://liminghua.gitee.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"技术","slug":"技术","permalink":"https://liminghua.gitee.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"生活","slug":"生活","permalink":"https://liminghua.gitee.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://liminghua.gitee.io/tags/SQL-Server/"},{"name":"pickList","slug":"pickList","permalink":"https://liminghua.gitee.io/tags/pickList/"},{"name":"哈希表","slug":"哈希表","permalink":"https://liminghua.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://liminghua.gitee.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"数据库","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQL语法","slug":"SQL语法","permalink":"https://liminghua.gitee.io/tags/SQL%E8%AF%AD%E6%B3%95/"},{"name":"双指针","slug":"双指针","permalink":"https://liminghua.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"踩坑","slug":"踩坑","permalink":"https://liminghua.gitee.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"删除文件","slug":"删除文件","permalink":"https://liminghua.gitee.io/tags/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"},{"name":"系统权限","slug":"系统权限","permalink":"https://liminghua.gitee.io/tags/%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"},{"name":"矩阵","slug":"矩阵","permalink":"https://liminghua.gitee.io/tags/%E7%9F%A9%E9%98%B5/"},{"name":"几何","slug":"几何","permalink":"https://liminghua.gitee.io/tags/%E5%87%A0%E4%BD%95/"},{"name":"数学","slug":"数学","permalink":"https://liminghua.gitee.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"CRM","slug":"CRM","permalink":"https://liminghua.gitee.io/tags/CRM/"},{"name":"WebService","slug":"WebService","permalink":"https://liminghua.gitee.io/tags/WebService/"},{"name":"soap","slug":"soap","permalink":"https://liminghua.gitee.io/tags/soap/"},{"name":"vue","slug":"vue","permalink":"https://liminghua.gitee.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://liminghua.gitee.io/tags/js/"},{"name":"Portal","slug":"Portal","permalink":"https://liminghua.gitee.io/tags/Portal/"},{"name":"vsReport","slug":"vsReport","permalink":"https://liminghua.gitee.io/tags/vsReport/"},{"name":"钉钉","slug":"钉钉","permalink":"https://liminghua.gitee.io/tags/%E9%92%89%E9%92%89/"},{"name":"vue组件","slug":"vue组件","permalink":"https://liminghua.gitee.io/tags/vue%E7%BB%84%E4%BB%B6/"},{"name":"CRM样式变更","slug":"CRM样式变更","permalink":"https://liminghua.gitee.io/tags/CRM%E6%A0%B7%E5%BC%8F%E5%8F%98%E6%9B%B4/"},{"name":"自定义页面","slug":"自定义页面","permalink":"https://liminghua.gitee.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2/"},{"name":"绕过登录权限","slug":"绕过登录权限","permalink":"https://liminghua.gitee.io/tags/%E7%BB%95%E8%BF%87%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90/"},{"name":"Arduino","slug":"Arduino","permalink":"https://liminghua.gitee.io/tags/Arduino/"},{"name":"DIY","slug":"DIY","permalink":"https://liminghua.gitee.io/tags/DIY/"},{"name":"成品资源","slug":"成品资源","permalink":"https://liminghua.gitee.io/tags/%E6%88%90%E5%93%81%E8%B5%84%E6%BA%90/"},{"name":"系统安全","slug":"系统安全","permalink":"https://liminghua.gitee.io/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"},{"name":"销售","slug":"销售","permalink":"https://liminghua.gitee.io/tags/%E9%94%80%E5%94%AE/"},{"name":"excel导入","slug":"excel导入","permalink":"https://liminghua.gitee.io/tags/excel%E5%AF%BC%E5%85%A5/"},{"name":"报表","slug":"报表","permalink":"https://liminghua.gitee.io/tags/%E6%8A%A5%E8%A1%A8/"},{"name":"瑞泰框架","slug":"瑞泰框架","permalink":"https://liminghua.gitee.io/tags/%E7%91%9E%E6%B3%B0%E6%A1%86%E6%9E%B6/"},{"name":"rtcrm.js","slug":"rtcrm-js","permalink":"https://liminghua.gitee.io/tags/rtcrm-js/"},{"name":"powerBI","slug":"powerBI","permalink":"https://liminghua.gitee.io/tags/powerBI/"},{"name":"DAX函数","slug":"DAX函数","permalink":"https://liminghua.gitee.io/tags/DAX%E5%87%BD%E6%95%B0/"},{"name":"编译器","slug":"编译器","permalink":"https://liminghua.gitee.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"idea","slug":"idea","permalink":"https://liminghua.gitee.io/tags/idea/"},{"name":"sql跟踪","slug":"sql跟踪","permalink":"https://liminghua.gitee.io/tags/sql%E8%B7%9F%E8%B8%AA/"},{"name":"优化","slug":"优化","permalink":"https://liminghua.gitee.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"SQL调优","slug":"SQL调优","permalink":"https://liminghua.gitee.io/tags/SQL%E8%B0%83%E4%BC%98/"},{"name":"源码","slug":"源码","permalink":"https://liminghua.gitee.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"集合","slug":"集合","permalink":"https://liminghua.gitee.io/tags/%E9%9B%86%E5%90%88/"},{"name":"心情","slug":"心情","permalink":"https://liminghua.gitee.io/tags/%E5%BF%83%E6%83%85/"},{"name":"jkd1.8","slug":"jkd1-8","permalink":"https://liminghua.gitee.io/tags/jkd1-8/"},{"name":"Optional","slug":"Optional","permalink":"https://liminghua.gitee.io/tags/Optional/"},{"name":"默认方法","slug":"默认方法","permalink":"https://liminghua.gitee.io/tags/%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"},{"name":"lambda","slug":"lambda","permalink":"https://liminghua.gitee.io/tags/lambda/"},{"name":"Base64","slug":"Base64","permalink":"https://liminghua.gitee.io/tags/Base64/"},{"name":"时间类","slug":"时间类","permalink":"https://liminghua.gitee.io/tags/%E6%97%B6%E9%97%B4%E7%B1%BB/"},{"name":"Java","slug":"Java","permalink":"https://liminghua.gitee.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://liminghua.gitee.io/tags/Spring/"}]}