<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2020/04/17/aboutMe/</url>
    <content><![CDATA[<blockquote>
<p>A Coder, live in XuZhou, China .  </p>
</blockquote>
<ul>
<li>姓名：李明华</li>
<li>现居：江苏徐州</li>
<li>GitHub：<a href="https://github.com/LiMingHuaGit" target="_blank" rel="noopener">LiMingHuaGit</a></li>
<li>QQ：<a href="qq.com/">2290320152</a></li>
<li>微信：<a href="wechat.com/">someonelover0</a></li>
</ul>
<img src="/2020/04/17/aboutMe/self.jpg" class="">
]]></content>
  </entry>
  <entry>
    <title>jdk1.8_时间类</title>
    <url>/2020/09/26/jdk1-8-%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="java-time"><a href="#java-time" class="headerlink" title="java.time"></a>java.time</h1><h2 id="LocalDate-年月日"><a href="#LocalDate-年月日" class="headerlink" title="LocalDate(年月日)"></a>LocalDate(年月日)</h2><blockquote>
<p>本地日期和时间</p>
</blockquote>
<h3 id="1-最值"><a href="#1-最值" class="headerlink" title="1. 最值"></a>1. 最值</h3><blockquote>
<p>最大支持 +999999999-12-31 最小支持-999999999-01-01</p>
</blockquote>
<h3 id="2-比较方法"><a href="#2-比较方法" class="headerlink" title="2. 比较方法"></a>2. 比较方法</h3><p><img src="1.jpg" alt=""></p>
<blockquote>
<p>equals </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(today.equals(tomorrow.minusDays(<span class="number">1</span>))) &#123;</span><br><span class="line">    System.out.println(<span class="string">"true"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"false"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-now-方法"><a href="#3-now-方法" class="headerlink" title="3. now()方法"></a>3. now()方法</h3><blockquote>
<p>获取当前时间，无参时为当前系统默认时区，参数为时区id </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtains the current date from the system clock in the specified time-zone.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This will query the &#123;<span class="doctag">@link</span> Clock#system(ZoneId) system clock&#125; to obtain the current date.</span></span><br><span class="line"><span class="comment"> * Specifying the time-zone avoids dependence on the default time-zone.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Using this method will prevent the ability to use an alternate clock for testing</span></span><br><span class="line"><span class="comment"> * because the clock is hard-coded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zone  the zone ID to use, not null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current date using the system clock, not null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">now</span><span class="params">(ZoneId zone)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now(Clock.system(zone));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtains the current date from the system clock in the default time-zone.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This will query the &#123;<span class="doctag">@link</span> Clock#systemDefaultZone() system clock&#125; in the default</span></span><br><span class="line"><span class="comment"> * time-zone to obtain the current date.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Using this method will prevent the ability to use an alternate clock for testing</span></span><br><span class="line"><span class="comment"> * because the clock is hard-coded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current date using the system clock and default time-zone, not null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> now(Clock.systemDefaultZone()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-plus-方法"><a href="#4-plus-方法" class="headerlink" title="4. plus()方法"></a>4. plus()方法</h3><blockquote>
<p>public LocalDate plus(long amountToAdd, TemporalUnit unit)  amountToAdd 要增加的总数 ；unit 时间单位 详见 ChronoUnit(TemporalUnit的实现类)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//plusYears(long yearsToAdd)\plusMonths(long monthsToAdd)\plusWeeks(long weeksToAdd)\plusDays(long daysToAdd)</span></span><br></pre></td></tr></table></figure>
<h3 id="5-minus-方法"><a href="#5-minus-方法" class="headerlink" title="5. minus()方法"></a>5. minus()方法</h3><blockquote>
<p>public LocalDate minus(long amountToSubtract, TemporalUnit unit)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.minus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//minusYears(long yearsToSubtract)\minusMonths(long monthsToSubtract)\minusWeeks(long weeksToSubtract)\minusDays(long daysToSubtract)</span></span><br></pre></td></tr></table></figure>
<h3 id="6-of-方法、getDayOfWeek-方法"><a href="#6-of-方法、getDayOfWeek-方法" class="headerlink" title="6. of()方法、getDayOfWeek()方法"></a>6. of()方法、getDayOfWeek()方法</h3><blockquote>
<p>LocalDate of(int year, Month month, int dayOfMonth)/LocalDate of(int year, int month, int dayOfMonth)<br>LocalDate.getDayOfWeek() 判断传入日期是一周中的第几天  return DayOfWeek对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);<span class="comment">//FRIDAY</span></span><br><span class="line">System.out.println(dayOfWeek.getValue());<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<h3 id="7-DateTimeFormatter"><a href="#7-DateTimeFormatter" class="headerlink" title="7. DateTimeFormatter"></a>7. DateTimeFormatter</h3><blockquote>
<p>格式化时间，线程安全，类内创建一次可复用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化 不指定时区</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line"><span class="comment">//实例化 指定时区</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"E, yyyy-MMMM-dd HH:mm"</span>, Locale.US);</span><br><span class="line"></span><br><span class="line">ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd'T'HH:mm ZZZZ"</span>);</span><br><span class="line">System.out.println(formatter.format(zdt));<span class="comment">//2020-09-28T11:55 GMT+08:00</span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter zhFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy MMM dd EE HH:mm"</span>, Locale.CHINA);</span><br><span class="line">System.out.println(zhFormatter.format(zdt));<span class="comment">//2020 九月 28 星期一 11:55</span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter usFormatter = DateTimeFormatter.ofPattern(<span class="string">"E, MMMM/dd/yyyy HH:mm"</span>, Locale.US);</span><br><span class="line">System.out.println(usFormatter.format(zdt));<span class="comment">//Mon, September/28/2020 11:55</span></span><br><span class="line"></span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(zdt));<span class="comment">//2020-09-28T11:55:39.209+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>保留字母定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* All letters <span class="string">'A'</span> to <span class="string">'Z'</span> and <span class="string">'a'</span> to <span class="string">'z'</span> are reserved as pattern letters. The</span><br><span class="line">* following pattern letters are defined:</span><br><span class="line">* &lt;pre&gt;</span><br><span class="line">*  Symbol  Meaning                     Presentation      Examples</span><br><span class="line">*  ------  -------                     ------------      -------</span><br><span class="line">*   G       era                         text              AD; Anno Domini; A</span><br><span class="line">*   u       year                        year              <span class="number">2004</span>; <span class="number">04</span></span><br><span class="line">*   y       year-of-era                 year              <span class="number">2004</span>; <span class="number">04</span></span><br><span class="line">*   D       day-of-year                 number            <span class="number">189</span></span><br><span class="line">*   M/L     month-of-year               number/text       <span class="number">7</span>; <span class="number">07</span>; Jul; July; J</span><br><span class="line">*   d       day-of-month                number            <span class="number">10</span></span><br><span class="line">*</span><br><span class="line">*   Q/q     quarter-of-year             number/text       <span class="number">3</span>; <span class="number">03</span>; Q3; <span class="number">3</span>rd quarter</span><br><span class="line">*   Y       week-based-year             year              <span class="number">1996</span>; <span class="number">96</span></span><br><span class="line">*   w       week-of-week-based-year     number            <span class="number">27</span></span><br><span class="line">*   W       week-of-month               number            <span class="number">4</span></span><br><span class="line">*   E       day-of-week                 text              Tue; Tuesday; T</span><br><span class="line">*   e/c     localized day-of-week       number/text       <span class="number">2</span>; <span class="number">02</span>; Tue; Tuesday; T</span><br><span class="line">*   F       week-of-month               number            <span class="number">3</span></span><br><span class="line">*</span><br><span class="line">*   a       am-pm-of-day                text              PM</span><br><span class="line">*   h       clock-hour-of-am-pm (<span class="number">1</span>-<span class="number">12</span>)  number            <span class="number">12</span></span><br><span class="line">*   K       hour-of-am-pm (<span class="number">0</span>-<span class="number">11</span>)        number            <span class="number">0</span></span><br><span class="line">*   k       clock-hour-of-am-pm (<span class="number">1</span>-<span class="number">24</span>)  number            <span class="number">0</span></span><br><span class="line">*</span><br><span class="line">*   H       hour-of-day (<span class="number">0</span>-<span class="number">23</span>)          number            <span class="number">0</span></span><br><span class="line">*   m       minute-of-hour              number            <span class="number">30</span></span><br><span class="line">*   s       second-of-minute            number            <span class="number">55</span></span><br><span class="line">*   S       fraction-of-second          fraction          <span class="number">978</span></span><br><span class="line">*   A       milli-of-day                number            <span class="number">1234</span></span><br><span class="line">*   n       nano-of-second              number            <span class="number">987654321</span></span><br><span class="line">*   N       nano-of-day                 number            <span class="number">1234000000</span></span><br><span class="line">*</span><br><span class="line">*   V       time-zone ID                zone-id           America/Los_Angeles; Z; -<span class="number">08</span>:<span class="number">30</span></span><br><span class="line">*   z       time-zone name              zone-name         Pacific Standard Time; PST</span><br><span class="line">*   O       localized zone-offset       offset-O          GMT+<span class="number">8</span>; GMT+<span class="number">08</span>:<span class="number">00</span>; UTC-<span class="number">08</span>:<span class="number">00</span>;</span><br><span class="line">*   X       zone-offset <span class="string">'Z'</span> <span class="keyword">for</span> zero    offset-X          Z; -<span class="number">08</span>; -<span class="number">0830</span>; -<span class="number">08</span>:<span class="number">30</span>; -<span class="number">083015</span>; -<span class="number">08</span>:<span class="number">30</span>:<span class="number">15</span>;</span><br><span class="line">*   x       zone-offset                 offset-x          +<span class="number">0000</span>; -<span class="number">08</span>; -<span class="number">0830</span>; -<span class="number">08</span>:<span class="number">30</span>; -<span class="number">083015</span>; -<span class="number">08</span>:<span class="number">30</span>:<span class="number">15</span>;</span><br><span class="line">*   Z       zone-offset                 offset-Z          +<span class="number">0000</span>; -<span class="number">0800</span>; -<span class="number">08</span>:<span class="number">00</span>;</span><br><span class="line">*</span><br><span class="line">*   p       pad next                    pad modifier      <span class="number">1</span></span><br><span class="line">*</span><br><span class="line">*   <span class="string">'       escape for text             delimiter</span></span><br><span class="line"><span class="string">*   '</span><span class="string">'      single quote                literal           '</span></span><br><span class="line">*   [       optional section start</span><br><span class="line">*   ]       optional section end</span><br><span class="line">*   #       reserved for future use</span><br><span class="line">*   &#123;       reserved <span class="keyword">for</span> future use</span><br><span class="line">*   &#125;       reserved <span class="keyword">for</span> future use</span><br></pre></td></tr></table></figure>
<h2 id="LocalDateTime-年月日时分秒"><a href="#LocalDateTime-年月日时分秒" class="headerlink" title="LocalDateTime(年月日时分秒)"></a>LocalDateTime(年月日时分秒)</h2><blockquote>
<p>本地日期和时间</p>
</blockquote>
<h3 id="1-常用方法案例"><a href="#1-常用方法案例" class="headerlink" title="1. 常用方法案例"></a>1. 常用方法案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = ldt.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = ldt.getMonth();</span><br><span class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = ldt.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    <span class="comment">// 23*60+59=1439</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> dayOfWeekLong = ldt.getLong(ChronoField.DAY_OF_WEEK);</span><br><span class="line">System.out.println(dayOfWeekLong);    <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"2016-12-01 23:59:59"</span>, formatter);</span><br><span class="line">String string = parsed.format(formatter);</span><br><span class="line">System.out.println(string);     <span class="comment">// 2016-12-01 23:59:59</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Instant时间戳"><a href="#2-Instant时间戳" class="headerlink" title="2. Instant时间戳"></a>2. Instant时间戳</h3><blockquote>
<p>在java.util.Date类与LocalDate、LocalDateTime类之间转换中 均可以通过Instant作为中间类完成转换</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"><span class="comment">//获取当前默认时区下ldt转换成的时间戳</span></span><br><span class="line">      Instant instant = ldt.atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line"></span><br><span class="line">      Date legacyDate = Date.from(instant);</span><br><span class="line">      System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure>

<h2 id="LocalTime-时分秒"><a href="#LocalTime-时分秒" class="headerlink" title="LocalTime(时分秒)"></a>LocalTime(时分秒)</h2><blockquote>
<p>本地日期和时间</p>
</blockquote>
<h3 id="1-Clock"><a href="#1-Clock" class="headerlink" title="1. Clock"></a>1. Clock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"><span class="comment">//返回1970-01-01T00:00Z (UTC)至今的毫秒数，即按毫秒单位的unix时间戳</span></span><br><span class="line"><span class="keyword">long</span> t0 = clock.millis();</span><br><span class="line">System.out.println(t0);</span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);</span><br></pre></td></tr></table></figure>
<h3 id="2-ZoneId-getRules-isBefore"><a href="#2-ZoneId-getRules-isBefore" class="headerlink" title="2. ZoneId.getRules(),isBefore()"></a>2. ZoneId.getRules(),isBefore()</h3><blockquote>
<p>getRules 当前默认时区与指定时区间的转换公式<br>isBefore 当前时间是否在指定时间之前<br>ChronoUnit.between 按指定时间单位计算俩时间的差</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(zone1.getRules());<span class="comment">//ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line">System.out.println(zone2.getRules());<span class="comment">//ZoneRules[currentStandardOffset=-03:00]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// time</span></span><br><span class="line">LocalTime now1 = LocalTime.now(zone1);<span class="comment">//10:17:39.043</span></span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);<span class="comment">//05:17:39.050</span></span><br><span class="line"></span><br><span class="line">System.out.println(now1);</span><br><span class="line">System.out.println(now2);</span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line">System.out.println(hoursBetween);<span class="comment">//-4</span></span><br><span class="line">System.out.println(minutesBetween);<span class="comment">//-299</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// create time</span></span><br><span class="line"></span><br><span class="line">LocalTime now = LocalTime.now();</span><br><span class="line">System.out.println(now);<span class="comment">//16:17:39.052</span></span><br><span class="line"></span><br><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(late);<span class="comment">//23:59:59</span></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">                DateTimeFormatter</span><br><span class="line">                        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">                        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime formateTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(formateTime);<span class="comment">//13:37</span></span><br></pre></td></tr></table></figure>
<h2 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h2><blockquote>
<p>带时区的日期和时间(ISO-8601)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZonedDateTime  zonedDateTime = ZonedDateTime.now();</span><br><span class="line">System.out.println(zonedDateTime);<span class="comment">//2020-09-28T17:19:44.836+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jkd1.8</tag>
        <tag>时间类</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>jdk1.8_lambda</title>
    <url>/2020/09/24/jdk1-8-lambda/</url>
    <content><![CDATA[<blockquote>
<p>参考Haskell-函数式编程</p>
</blockquote>
<h1 id="核心功能性函数接口（有且只有一个抽象方法的接口）"><a href="#核心功能性函数接口（有且只有一个抽象方法的接口）" class="headerlink" title="核心功能性函数接口（有且只有一个抽象方法的接口）"></a>核心功能性函数接口（有且只有一个抽象方法的接口）</h1><ul>
<li>Consumer<T> :消费型接口    void acept(T t);<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费型接口Consumer，输入一个参数，对其进行打印输出</span></span><br><span class="line"> Consumer&lt;String&gt; consumer = (x) -&gt; System.out.println(x);</span><br><span class="line"> <span class="comment">//打印字符串</span></span><br><span class="line"> consumer.accept(<span class="string">"Hello world!"</span>);</span><br></pre></td></tr></table></figure></li>
<li>Supplier<T> :供给型接口    T get();<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//供给型接口Supplier，返回指定字符串</span></span><br><span class="line">Supplier&lt;String&gt; supplier = () -&gt; <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="comment">//获取字符串</span></span><br><span class="line">supplier.get();</span><br></pre></td></tr></table></figure></li>
<li>Function&lt;T,R&gt; :函数型接口 R apply(T t);<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; function = (x) -&gt; x.length();</span><br><span class="line"><span class="comment">//获取字符串长度</span></span><br><span class="line">function.apply(<span class="string">"Hello world!"</span>);</span><br></pre></td></tr></table></figure></li>
<li>Predicate<T> :断言型接口 boolean test(T t);<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//断言型接口Predicate，输入数字，判断是否大于0</span></span><br><span class="line">Predicate&lt;Integer&gt; predicate = (x) -&gt; x &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取判断结果</span></span><br><span class="line">predicate.test(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="1-Iterable-forEach-Consumer-lt-super-T-gt-action"><a href="#1-Iterable-forEach-Consumer-lt-super-T-gt-action" class="headerlink" title="1.Iterable.forEach(Consumer&lt;? super T&gt; action)"></a>1.Iterable.forEach(Consumer&lt;? super T&gt; action)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; soutList = Arrays.asList(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>);</span><br><span class="line">soutList.forEach(out-&gt; System.out.println(out));</span><br><span class="line">soutList.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Page p = <span class="keyword">new</span> Page(<span class="string">"content"</span>);</span><br><span class="line">Page p = Page.<span class="keyword">new</span>(<span class="string">"content"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Page&gt; <span class="title">createPagesFrom</span><span class="params">(Stream&lt;String&gt;; contents)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> contents.map(Page::<span class="keyword">new</span>).</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="1.jpg" alt="Iterable接口"><br> <img src="2.jpg" alt="forEach方法"></p>
<h3 id="1-Iterable接口允许一个对象成为forEach的目标"><a href="#1-Iterable接口允许一个对象成为forEach的目标" class="headerlink" title="1). Iterable接口允许一个对象成为forEach的目标"></a>1). Iterable接口允许一个对象成为forEach的目标</h3><h3 id="2-这里的forEach被声明为一个默认方法，并接收了一个消费者类型的函数接口，先查找匹配对应的操作，若不为空则执行操作"><a href="#2-这里的forEach被声明为一个默认方法，并接收了一个消费者类型的函数接口，先查找匹配对应的操作，若不为空则执行操作" class="headerlink" title="2). 这里的forEach被声明为一个默认方法，并接收了一个消费者类型的函数接口，先查找匹配对应的操作，若不为空则执行操作"></a>2). 这里的forEach被声明为一个默认方法，并接收了一个消费者类型的函数接口，先查找匹配对应的操作，若不为空则执行操作</h3><h3 id="3-接口中的默认方法可以不被实现类实现"><a href="#3-接口中的默认方法可以不被实现类实现" class="headerlink" title="3). 接口中的默认方法可以不被实现类实现"></a>3). 接口中的默认方法可以不被实现类实现</h3><h3 id="4-如上代码中，输出集合soutList调用了foreach方法，箭头左边是参数，右边是抽象方法的实现内容或已有方法的引用"><a href="#4-如上代码中，输出集合soutList调用了foreach方法，箭头左边是参数，右边是抽象方法的实现内容或已有方法的引用" class="headerlink" title="4). 如上代码中，输出集合soutList调用了foreach方法，箭头左边是参数，右边是抽象方法的实现内容或已有方法的引用"></a>4). 如上代码中，输出集合soutList调用了foreach方法，箭头左边是参数，右边是抽象方法的实现内容或已有方法的引用</h3><h3 id="5-当参数列表中的参数和方法签名匹配时，可以通过-直接引用方法，包括构造方法"><a href="#5-当参数列表中的参数和方法签名匹配时，可以通过-直接引用方法，包括构造方法" class="headerlink" title="5). 当参数列表中的参数和方法签名匹配时，可以通过 :: 直接引用方法，包括构造方法"></a>5). 当参数列表中的参数和方法签名匹配时，可以通过 :: 直接引用方法，包括构造方法</h3><h2 id="2-Collection-stream-、Stream、Stream-filter-Predicate-、Collector、Collectors、Collectors-toList"><a href="#2-Collection-stream-、Stream、Stream-filter-Predicate-、Collector、Collectors、Collectors-toList" class="headerlink" title="2.Collection.stream()、Stream、Stream#filter(Predicate)、Collector、Collectors、Collectors#toList()"></a>2.Collection.stream()、Stream、Stream#filter(Predicate)、Collector、Collectors、Collectors#toList()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Complete this for Exercise_2_Test#getAllPersonsEligibleToVote</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">* 根据给定年龄返回给定选民集合中合法年龄的选民集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> potentialVoters - voters to filter</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> legalAgeOfVoting - age where it's legal to vote</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a list of eligible voters</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Person&gt; <span class="title">eligibleVoters</span><span class="params">(List&lt;Person&gt; potentialVoters, <span class="keyword">int</span> legalAgeOfVoting)</span> </span>&#123;</span><br><span class="line">      Stream&lt;Person&gt; personStream = potentialVoters.stream().filter(</span><br><span class="line">              person -&gt; person.getAge()&gt;=legalAgeOfVoting</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> personStream.collect(Collectors.toList());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-Collection-stream-返回一个Stream序列"><a href="#1-Collection-stream-返回一个Stream序列" class="headerlink" title="1). Collection#stream() 返回一个Stream序列"></a>1). Collection#stream() 返回一个Stream序列</h3><h3 id="2-Stream-流"><a href="#2-Stream-流" class="headerlink" title="2). Stream 流"></a>2). Stream 流</h3><pre><code>- A sequence of elements supporting sequential and parallel aggregate operations
- 支撑顺序和并行聚合操作元素的序列
- lazy： computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.
- 惰式执行：即仅在终端操作启动时才执行对源数据的计算，并且仅在需要时使用源元素。
- 在对流进行“操作”（类似查询和过滤）时，这些行为应该是无干扰（不修改流的数据源）且无状态（其结果不依赖于流管道执行过程中可能改变的任何状态）的
- 消费性质，只使用一次，不可以被重用</code></pre><h3 id="3-Stream-filter-Predicate-对流进行过滤-中间操作"><a href="#3-Stream-filter-Predicate-对流进行过滤-中间操作" class="headerlink" title="3). Stream#filter(Predicate)  对流进行过滤 中间操作"></a>3). Stream#filter(Predicate)  对流进行过滤 中间操作</h3><h3 id="4-Predicate-断言功能性函数接口，返回Boolean值-见上文"><a href="#4-Predicate-断言功能性函数接口，返回Boolean值-见上文" class="headerlink" title="4). Predicate 断言功能性函数接口，返回Boolean值 见上文"></a>4). Predicate 断言功能性函数接口，返回Boolean值 见上文</h3><h3 id="5-Stream-collect"><a href="#5-Stream-collect" class="headerlink" title="5). Stream.collect()"></a>5). Stream.collect()</h3><pre><code>- 返回一个结果容器 
- &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)
- &lt;R&gt; 结果的类型
- &lt;A&gt; Collector的积累类型</code></pre><h3 id="6-Collector-执行结果转换-Collectors-实现Collector的各种还原操作"><a href="#6-Collector-执行结果转换-Collectors-实现Collector的各种还原操作" class="headerlink" title="6). Collector 执行结果转换 Collectors 实现Collector的各种还原操作"></a>6). Collector 执行结果转换 Collectors 实现Collector的各种还原操作</h3><pre><code>- public interface Collector&lt;T, A, R&gt;
- &lt;T&gt;  输入元素的类型
- &lt;A&gt;  还原运算的可变累积型（通常隐藏作为一个实现细节）
- &lt;R&gt;  还原运算的结果类</code></pre><h3 id="7-Collectors-toList-返回一个Collector-，其累积的输入元素融入到一个新的List中"><a href="#7-Collectors-toList-返回一个Collector-，其累积的输入元素融入到一个新的List中" class="headerlink" title="7). Collectors#toList() 返回一个Collector ，其累积的输入元素融入到一个新的List中"></a>7). Collectors#toList() 返回一个Collector ，其累积的输入元素融入到一个新的List中</h3><pre><code>- public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()
- &lt;T&gt;  输入元素的类型</code></pre><h2 id="3-Stream-map-Function"><a href="#3-Stream-map-Function" class="headerlink" title="3.Stream#map(Function)"></a>3.Stream#map(Function)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Apply a mapping of Books to titles (Strings)</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 将书籍的标题映射到一个新的List&lt;String&gt;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> books - books to transform</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> list of book titles</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">titlesOf</span><span class="params">(List&lt;Book&gt; books)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> books.stream().map(Book::getTitle).collect(Collectors.toList());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-Stream-map-Function"><a href="#1-Stream-map-Function" class="headerlink" title="1). Stream#map(Function)"></a>1). Stream#map(Function)</h3><pre><code>- 返回指定类型的流 中间操作
- Function 函数型功能接口 见上文
- java.util.stream.Stream&lt;T&gt; &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)
- &lt;? super T&gt;/&lt;? extends T&gt; &lt;? super T&gt;表示包括T在内的任何T的父类，&lt;? extends T&gt;表示包括T在内的任何T的子类</code></pre>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jkd1.8</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>简单代码演示控制反转IOC和依赖注入DI</title>
    <url>/2020/04/17/%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5DI/</url>
    <content><![CDATA[<h1 id="ioc（Inversion-of-Control）"><a href="#ioc（Inversion-of-Control）" class="headerlink" title="ioc（Inversion of Control）"></a>ioc（Inversion of Control）</h1><blockquote>
<p>控制反转，也可以称为依赖倒置，即当A要调用B时，A无需主动获取，会有人主动把B送过来供A使用，以减少在A的代码中存在B，导致模块间的高度耦合。</p>
</blockquote>
<h2 id="正常的代码控制流程"><a href="#正常的代码控制流程" class="headerlink" title="正常的代码控制流程"></a>正常的代码控制流程</h2><p>1.创建一个接口Car</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.定义两种车实现接口car</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"benz go......"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"bmw go......"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.人要开车</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Car car=<span class="keyword">new</span> Benz();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DriveCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"begin drive"</span>);</span><br><span class="line">    car.go();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式是我们常见的代码控制流程，人想要开车，需要自己实例化，且这个人只能开一种车。</li>
<li>如何让他可以想开什么车就开什么车呢？<blockquote>
<p>通过依赖注入</p>
</blockquote>
</li>
</ul>
<h2 id="依赖注入的方式DI（Dependency-Injection）"><a href="#依赖注入的方式DI（Dependency-Injection）" class="headerlink" title="依赖注入的方式DI（Dependency Injection）"></a>依赖注入的方式DI（Dependency Injection）</h2><ul>
<li>依赖注入是实现控制反转的方式之一。</li>
<li>看一下修改后的person类  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Car car=<span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car=car;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">driveCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"begin drive"</span>);</span><br><span class="line">    car.go();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在的Person类已经不自己实例化车的对象了，而是通过构造函数来获得车的对象，所以，这个类就可以开各种车了，只要这个车实现了Car接口就可以。看一下如何使用Person类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Person person=<span class="keyword">new</span> Person(<span class="keyword">new</span> Benz());</span><br><span class="line">  person.driveCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在的Person类可以开不止一种车，只要你通过构造函数传递进来。在这个例子中，Car对象就是Person类的依赖，当我们实例化Person类时，将一个Car的实例传递给Person类，就是依赖注入，我们的Person类从而实现了控制反转。<br>控制反转到底反转了什么？有种说法是这样的：所谓控制反转，反转的是获取对象依赖的过程。控制权反转后，获取依赖对象的过程由自身管理变为由IOC容器注入。</p>
</blockquote>
<h2 id="Spring实现依赖注入的方式"><a href="#Spring实现依赖注入的方式" class="headerlink" title="Spring实现依赖注入的方式"></a>Spring实现依赖注入的方式</h2><blockquote>
<p>在上面的这行代码中Person p=new Person(new Benz());，我们通过手动的方式new了一个Benz()的对象，然后将其注入到Person类中。而Spring不这么干，因为Spring觉得，你这行代码实例化了一个具体的Benz类，如果你以后想要在这里实例化一个BMW类的话，岂不是要修改代码？那我干脆写到配置文件里好了，即便你将来要该注意，至少不需要修改代码，于是就有了下面的配置</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.XXX.Benz"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.XXX.Person"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"car"</span> <span class="attr">ref</span>=<span class="string">"car"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从配置文件中获取Person类的对象时，car对象会被自动装配进来，而person对象不需要关心到底是哪个具体的类被传递进来了。所以，Spring作为一个IOC框架主要做了两步：创建对象和组装对象之间的关系。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
