<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李明华的博客</title>
  <icon>https://www.gravatar.com/avatar/159142b6000484cb350066a4de1a0f20</icon>
  <subtitle>面朝大海，春暖花开</subtitle>
  <link href="https://liminghua.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://liminghua.gitee.io/"/>
  <updated>2021-01-24T10:57:12.601Z</updated>
  <id>https://liminghua.gitee.io/</id>
  
  <author>
    <name>李明华</name>
    <email>2290320152@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>674.最长连续递增序列</title>
    <link href="https://liminghua.gitee.io/2021/01/24/674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <id>https://liminghua.gitee.io/2021/01/24/674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</id>
    <published>2021-01-24T10:49:13.000Z</published>
    <updated>2021-01-24T10:57:12.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p> </p><p>示例 1：</p><blockquote><p>输入：nums = [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [2,2,2,2,2]<br>输出：1<br>解释：最长连续递增序列是 [2], 长度为1。</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放最大的递增子序列长度</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//记录每一个新的递增子序列的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//如果递增中断，记录新的子序列起始位置</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较当前序列和历史最长递增子序列的长度</span></span><br><span class="line">            ans = Math.max(ans, i - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路<br>对于下标范围 [l,r] 的连续子序列，如果对任意 l≤i&lt;r 都满足 nums[i]&lt;nums[i+1]，则该连续子序列是递增序列。<br>假设数组 nums 的长度是 n，对于 0&lt;l≤r&lt;n−1，如果下标范围 [l,r] 的连续子序列是递增序列，则考虑 nums[l−1] 和 nums[r+1]。<br>如果 nums[l−1]&lt;nums[l]，则将 nums[l−1] 加到 nums[l] 的前面，可以得到更长的连续递增序列.<br>如果 nums[r+1]&gt;nums[r]，则将 nums[r+1] 加到 nums[r] 的后面，可以得到更长的连续递增序列。<br>基于上述分析可知，为了得到最长连续递增序列，可以使用贪心的策略得到尽可能长的连续递增序列。做法是使用记录当前连续递增序列的开始下标和结束下标，遍历数组的过程中每次比较相邻元素，根据相邻元素的大小关系决定是否需要更新连续递增序列的开始下标。<br>具体而言，令 start 表示连续递增序列的开始下标，初始时 start=0，然后遍历数组 nums，进行如下操作。<br>如果下标 i&gt;0 且 nums[i]≤nums[i−1]，则说明当前元素小于或等于上一个元素，因此 nums[i−1] 和 nums[i] 不可能属于同一个连续递增序列，必须从下标 i 处开始一个新的连续递增序列，因此令 start=i。如果下标 i=0 或 nums[i]&gt;nums[i−1]，则不更新 start 的值。<br>此时下标范围 [start,i] 的连续子序列是递增序列，其长度为 i−start+1，使用当前连续递增序列的长度更新最长连续递增序列的长度。<br>遍历结束之后，即可得到整个数组的最长连续递增序列的长度。</li></ul><ul><li><p>时间复杂度<br>O(N) </p></li><li><p>空间复杂度<br>O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。&lt;/p&gt;
&lt;p&gt;连续递增的子序列 可以由两个下标 l 和 r（l &amp;l</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>拆弹专家2观后感</title>
    <link href="https://liminghua.gitee.io/2021/01/24/%E6%8B%86%E5%BC%B9%E4%B8%93%E5%AE%B62%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <id>https://liminghua.gitee.io/2021/01/24/%E6%8B%86%E5%BC%B9%E4%B8%93%E5%AE%B62%E8%A7%82%E5%90%8E%E6%84%9F/</id>
    <published>2021-01-24T10:13:49.000Z</published>
    <updated>2021-01-24T10:40:27.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性格和情绪"><a href="#性格和情绪" class="headerlink" title="性格和情绪"></a>性格和情绪</h2><p>可以不做好性格，但不能<strong>放任坏情绪</strong></p><h2 id="思想和信念"><a href="#思想和信念" class="headerlink" title="思想和信念"></a>思想和信念</h2><p>思想和信念是很可怕的东西,当一群恐怖分子为了某个目标不顾一切,视死如归,在看他看来,可能自己真的是个英雄<br>人和人的不同,想法和想法的冲突,国家和国家的体制不一,社会阶层和社会阶层的相互倾轧,大多数和极个别…<br>谁又能保证自己一辈子都是<strong>人民民主</strong>的一部分,永远不会成为<strong>专政</strong>的对象?</p><h2 id="自我强大和资源"><a href="#自我强大和资源" class="headerlink" title="自我强大和资源"></a>自我强大和资源</h2><p>自我强大是必要的，只有当你足够强大，才能对社会对世界有足够影响，才能代表一个群体<br>底层人的自怨自艾只能让自己越来越丧失斗志<br>强者才能决定自己可以怎么活，决定别人应该怎么活</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;性格和情绪&quot;&gt;&lt;a href=&quot;#性格和情绪&quot; class=&quot;headerlink&quot; title=&quot;性格和情绪&quot;&gt;&lt;/a&gt;性格和情绪&lt;/h2&gt;&lt;p&gt;可以不做好性格，但不能&lt;strong&gt;放任坏情绪&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;思想和信念&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="生活" scheme="https://liminghua.gitee.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="电影" scheme="https://liminghua.gitee.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>167.两数之和II-输入有序数组</title>
    <link href="https://liminghua.gitee.io/2021/01/22/167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://liminghua.gitee.io/2021/01/22/167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2021-01-22T00:52:58.000Z</published>
    <updated>2021-01-23T12:52:38.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><blockquote><p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p></blockquote><p>示例:</p><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] rs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> length = numbers.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i]+numbers[j]==target)&#123;</span><br><span class="line">                    rs[<span class="number">0</span>] = ++i;</span><br><span class="line">                    rs[<span class="number">1</span>] = ++j;</span><br><span class="line">                    <span class="keyword">return</span> rs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度<br>O(n*n) </p></li><li><p>空间复杂度<br>O(1)</p></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = i + <span class="number">1</span>, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">                <span class="keyword">if</span> (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, mid + <span class="number">1</span>&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>在数组中找到两个数，使得它们的和等于目标值，可以首先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差。利用数组的有序性质，可以通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找。</li></ul><ul><li>时间复杂度<br>O(nlogn)，其中 n 是数组的长度。需要遍历数组一次确定第一个数，时间复杂度是 O(n)，寻找第二个数使用二分查找，时间复杂度是 O(logn)，因此总时间复杂度是 O(nlogn)。</li></ul><ul><li>空间复杂度<br>O(1)</li></ul><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[low] + numbers[high];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;low + <span class="number">1</span>, high + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                ++low;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --high;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。<br>使用双指针的实质是缩小查找范围。那么会不会把可能的解过滤掉？答案是不会。假设 numbers[i]+numbers[j]=target 是唯一解，其中 0≤i&lt;j≤numbers.length−1。初始时两个指针分别指向下标 0 和下标 numbers.length−1，左指针指向的下标小于或等于 i，右指针指向的下标大于或等于 j。除非初始时左指针和右指针已经位于下标 i 和 j，否则一定是左指针先到达下标 i 的位置或者右指针先到达下标 j 的位置。<br>如果左指针先到达下标 i 的位置，此时右指针还在下标 j 的右侧，sum&gt;target，因此一定是右指针左移，左指针不可能移到 i 的右侧。<br>如果右指针先到达下标 j 的位置，此时左指针还在下标 i 的左侧，sum&lt;target，因此一定是左指针右移，右指针不可能移到 j 的左侧。<br>由此可见，在整个移动过程中，左指针不可能移到 i 的右侧，右指针不可能移到 j 的左侧，因此不会把可能的解过滤掉。由于题目确保有唯一的答案，因此使用双指针一定可以找到答案。</li></ul><ul><li>时间复杂度<br>O(n)，其中 n 是数组的长度。两个指针移动的总次数最多为 n 次。</li></ul><ul><li>空间复杂度<br>O(1)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给定一个已按照&lt;strong&gt;升序排列&lt;/strong&gt; 的有序数组，找到两个数使得它们相加之和等于目标数。&lt;/p&gt;
&lt;p&gt;函数应该返回这两个下标值</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>509.斐波那契数</title>
    <link href="https://liminghua.gitee.io/2021/01/22/509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>https://liminghua.gitee.io/2021/01/22/509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</id>
    <published>2021-01-22T00:52:29.000Z</published>
    <updated>2021-01-23T12:14:13.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p><strong>斐波那契数</strong>，通常用 F(n) 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p></blockquote><p>给你 n ，请计算 F(n) 。</p><p> </p><p>示例 1：</p><blockquote><p>输入：2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p></blockquote><p>示例 2：</p><blockquote><p>输入：3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p></blockquote><p>示例 3：</p><blockquote><p>输入：4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//最基础值，递归的终点</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归成立的公式</span></span><br><span class="line">        <span class="keyword">return</span> fn(n-<span class="number">1</span>)+fn(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度<br>O(n) </p></li><li><p>空间复杂度<br>O(n)</p></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="1.gif" class="lazyload" data-srcset="1.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>思路<br>斐波那契数的边界条件是 0F(0)=0 和F(1)=1。当 n&gt;1 时，每一项的和都等于前两项的和，因此有如下递推关系：<br>F(n)=F(n-1)+F(n-2)<br>F(n)=F(n−1)+F(n−2)<br>由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 F(0) 和 F(1)。<br>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n) 的实现。由于 F(n) 只和 F(n−1) 与 F(n−2) 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 O(1)。如下的代码中给出的就是这种实现。</li></ul><ul><li><p>时间复杂度<br>O(N) </p></li><li><p>空间复杂度<br>O(N)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;斐波那契数&lt;/strong&gt;，通常用 F(n) 表示，形成的序列称为 &lt;strong&gt;斐波那契数列&lt;/strong&gt; 。该数列由 0</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>989.数组形式的整数加法</title>
    <link href="https://liminghua.gitee.io/2021/01/22/989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/"/>
    <id>https://liminghua.gitee.io/2021/01/22/989-%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%95%B4%E6%95%B0%E5%8A%A0%E6%B3%95/</id>
    <published>2021-01-22T00:52:08.000Z</published>
    <updated>2021-01-22T06:07:45.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。</p><p>给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。</p><p> </p><p>示例 1：</p><blockquote><p>输入：A = [1,2,0,0], K = 34<br>输出：[1,2,3,4]<br>解释：1200 + 34 = 1234</p></blockquote><p>示例 2：</p><blockquote><p>输入：A = [2,7,4], K = 181<br>输出：[4,5,5]<br>解释：274 + 181 = 455</p></blockquote><p>示例 3：</p><blockquote><p>输入：A = [2,1,5], K = 806<br>输出：[1,0,2,1]<br>解释：215 + 806 = 1021</p></blockquote><p>示例 4：</p><blockquote><p>输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1<br>输出：[1,0,0,0,0,0,0,0,0,0,0]<br>解释：9999999999 + 1 = 10000000000</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="逐位相加"><a href="#逐位相加" class="headerlink" title="逐位相加"></a>逐位相加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; rs = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//从个位加起（倒序遍历）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length -<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="comment">//当前位数和</span></span><br><span class="line">            <span class="keyword">int</span> sum = A[i]+K%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//K的下一位</span></span><br><span class="line">            K/=<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//若当前位和大于10 下一位进一，当前和减10</span></span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                K++;</span><br><span class="line">                sum-=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//存入结果集（倒序）</span></span><br><span class="line">            rs.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若K位数大于A，处理K的进位结果</span></span><br><span class="line">        <span class="keyword">for</span> (; K &gt; <span class="number">0</span>; K /= <span class="number">10</span>) &#123;</span><br><span class="line">            rs.add(K % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻转结果集</span></span><br><span class="line">        Collections.reverse(rs);</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度<br>O(max(n,logK)),其中 n 为数组的长度。</p></li><li><p>空间复杂度<br>O(max(n,logK))。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。&lt;/</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>832.翻转图像</title>
    <link href="https://liminghua.gitee.io/2021/01/21/832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://liminghua.gitee.io/2021/01/21/832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2021-01-21T09:04:31.000Z</published>
    <updated>2021-01-22T06:15:26.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。</p><p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。</p><p>反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p><p>示例 1:</p><blockquote><p>输入: [[1,1,0],[1,0,1],[0,0,0]]<br>输出: [[1,0,0],[0,1,0],[1,1,1]]<br>解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；<br>    然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</p></blockquote><p>示例 2:</p><blockquote><p>输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]<br>输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]<br>解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；<br>    然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public int[][] flipAndInvertImage(int[][] A) &#123;</span></span><br><span class="line"><span class="comment">//         for(int[] line:A)&#123;</span></span><br><span class="line"><span class="comment">//             line = reverse(line);</span></span><br><span class="line"><span class="comment">//             line = Invert(line);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: A)</span><br><span class="line">            <span class="comment">//小于行的中位数，游标自增</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (C + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">//异或1取反并翻转中位数两侧</span></span><br><span class="line">                <span class="keyword">int</span> tmp = row[i] ^ <span class="number">1</span>;</span><br><span class="line">                row[i] = row[C - <span class="number">1</span> - i] ^ <span class="number">1</span>;</span><br><span class="line">                row[C - <span class="number">1</span> - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 A[i][j]，将它和 A[i][c - j - 1] 进行交换（即翻转），其中 c 是数组 A 的列数。在交换的同时，可以将这两个数进行反转。</li></ul><ul><li><p>时间复杂度<br>O(M∗N)，其中 M 和 N 分别为数组 A 的行数和列数。</p></li><li><p>空间复杂度<br>O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。&lt;/p&gt;
&lt;p&gt;水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>查询picklist所有值</title>
    <link href="https://liminghua.gitee.io/2021/01/21/%E6%9F%A5%E8%AF%A2picklist%E6%89%80%E6%9C%89%E5%80%BC/"/>
    <id>https://liminghua.gitee.io/2021/01/21/%E6%9F%A5%E8%AF%A2picklist%E6%89%80%E6%9C%89%E5%80%BC/</id>
    <published>2021-01-21T06:07:30.000Z</published>
    <updated>2021-01-22T06:23:26.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查询实体下PickList的所有value和name"><a href="#查询实体下PickList的所有value和name" class="headerlink" title="查询实体下PickList的所有value和name"></a>查询实体下PickList的所有value和name</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">--attributename 字段名</span></span><br><span class="line"><span class="comment">--logicalname 实体名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">attributevalue,</span><br><span class="line"><span class="keyword">value</span> <span class="keyword">as</span> name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">entity e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> stringmap sm <span class="keyword">ON</span> e.objecttypecode <span class="operator">=</span> sm.objecttypecode <span class="keyword">AND</span> sm.attributename <span class="operator">=</span> <span class="string">&#x27;new_upkeepstation&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">logicalname <span class="operator">=</span> <span class="string">&#x27;incident&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;查询实体下PickList的所有value和name&quot;&gt;&lt;a href=&quot;#查询实体下PickList的所有value和name&quot; class=&quot;headerlink&quot; title=&quot;查询实体下PickList的所有value和name&quot;&gt;&lt;/a&gt;查询实体下Pic</summary>
      
    
    
    
    <category term="工作" scheme="https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="SQL Server" scheme="https://liminghua.gitee.io/tags/SQL-Server/"/>
    
    <category term="pickList" scheme="https://liminghua.gitee.io/tags/pickList/"/>
    
  </entry>
  
  <entry>
    <title>219.存在重复元素II</title>
    <link href="https://liminghua.gitee.io/2021/01/21/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <id>https://liminghua.gitee.io/2021/01/21/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</id>
    <published>2021-01-21T05:55:31.000Z</published>
    <updated>2021-01-22T06:15:03.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p><p> </p><p>示例 1:</p><blockquote><p>输入: nums = [1,2,3,1], k = 3<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [1,0,1,1], k = 1<br>输出: true</p></blockquote><p>示例 3:</p><blockquote><p>输入: nums = [1,2,3,1,2,3], k = 2<br>输出: false</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        Set&lt;Integer&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">//若temp中存在和当前元素相同的值，则满足nums [i] = nums [j]，并且i和j的差的绝对值小于等于k,返回true</span></span><br><span class="line">            <span class="keyword">if</span>(temp.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前元素放入temp中</span></span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            <span class="comment">//若temp中的元素超过了K，即temp中最早加入的元素和最新比对的元素差的绝对值大于K，移除最早的元素</span></span><br><span class="line">            <span class="keyword">if</span>(temp.size()&gt;k)&#123;</span><br><span class="line">                temp.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>思路<br>用散列表来维护这个k大小的滑动窗口</p></li><li><p>时间复杂度<br>O(N)  n 次 搜索，删除，插入 操作，每次操作都耗费常数时间。</p></li><li><p>空间复杂度<br>O(min(n,k))  开辟的额外空间取决于散列表中存储的元素的个数，也就是滑动窗口的大小 O(min(n,k))。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://liminghua.gitee.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>1725.可以形成最大正方形的矩形数目</title>
    <link href="https://liminghua.gitee.io/2021/01/21/1725-%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/"/>
    <id>https://liminghua.gitee.io/2021/01/21/1725-%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/</id>
    <published>2021-01-21T02:07:58.000Z</published>
    <updated>2021-01-22T06:15:49.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。</p><p>如果存在 k 同时满足 k &lt;= li 和 k &lt;= wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。</p><p>设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。</p><p>返回可以切出边长为 maxLen 的正方形的矩形 数目 。</p><p> </p><p>示例 1：</p><blockquote><p>输入：rectangles = [[5,8],[3,9],[5,12],[16,5]]<br>输出：3<br>解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。<br>最大正方形的边长为 5 ，可以由 3 个矩形切分得到。</p></blockquote><p>示例 2：</p><blockquote><p>输入：rectangles = [[2,3],[3,7],[4,3],[3,7]]<br>输出：3</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countGoodRectangles</span><span class="params">(<span class="keyword">int</span>[][] rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[rectangles.length];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;rectangles.length;i++)&#123;</span><br><span class="line">            temp[i] = Math.min(rectangles[i][<span class="number">0</span>],rectangles[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(temp[i]&gt;maxLen)&#123;</span><br><span class="line">                maxLen = temp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;temp.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[j]==maxLen)</span><br><span class="line">                rs++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>计算结果时可以根据贪心算法优化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countGoodRectangles</span><span class="params">(<span class="keyword">int</span>[][] rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] rect : rectangles) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = Math.min(rect[<span class="number">0</span>], rect[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLen) &#123;</span><br><span class="line">                maxLen = len;</span><br><span class="line">                ans = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == maxLen) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度<br>O(N)</p></li><li><p>空间复杂度<br>O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="贪心算法" scheme="https://liminghua.gitee.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1588.所有奇数长度子数组的和</title>
    <link href="https://liminghua.gitee.io/2021/01/20/1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/"/>
    <id>https://liminghua.gitee.io/2021/01/20/1588-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/</id>
    <published>2021-01-20T03:25:41.000Z</published>
    <updated>2021-01-22T08:40:17.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。</p><p>子数组 定义为原数组中的一个连续子序列。</p><p>请你返回 arr 中 所有奇数长度子数组的和 。</p><p> </p><p>示例 1：</p><blockquote><p>输入：arr = [1,4,2,5,3]<br>输出：58<br>解释：所有奇数长度子数组和它们的和为：<br>[1] = 1<br>[4] = 4<br>[2] = 2<br>[5] = 5<br>[3] = 3<br>[1,4,2] = 7<br>[4,2,5] = 11<br>[2,5,3] = 10<br>[1,4,2,5,3] = 15<br>我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58</p></blockquote><p>示例 2：</p><blockquote><p>输入：arr = [1,2]<br>输出：3<br>解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。</p></blockquote><p>示例 3：</p><blockquote><p>输入：arr = [10,11,12]<br>输出：66</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> LeftOdd = (i+<span class="number">1</span>)/<span class="number">2</span>, LeftEven = i/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> RightOdd = (len-i)/<span class="number">2</span>, RightEven = (len-<span class="number">1</span>-i)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            res += arr[i]*(LeftOdd*RightOdd + LeftEven*RightEven);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>没必要计算所有满足条件的数组，只需要知道每个元素会出现的次数，然后乘以其值，求和就可以得到结果<ul><li>odd奇数，even偶数</li><li>对于每个元素i(数组中下标为i)来说，要构成奇数长度的子数组<br>即 i左边的元素个数left+i本身自己一个+右边元素的个数right=奇数<br>即 left+right=偶数</li><li>满足a+b=偶数就只有两种情况<ol><li>奇数+奇数=偶数</li><li>偶数+偶数=偶数</li></ol></li><li><ol><li>所以只需要求得i左边可以选择奇数长度的可能有多少种，即left_odd,同样求右边奇数right_odd<br>就可以求出策略1有多少种可能</li><li>所以只需要求得i左边可以选择偶数长度的可能有多少种，即left_odd,同样求右边偶数right_odd<br>就可以求出策略1有多少种可能，注意0也算选择的一种可能</li></ol></li><li>即元素i在所有奇数长度子数组出现的次数总和是<br>left_odd<em>right_odd+left_even</em>right_even</li><li>元素i左边元素共有i个，右边元素共有siz-i-1个</li></ul></li></ul><p>要算长度为奇数的子序列的总的数组和，则需要知道每个数字在各个长度为奇数的子数组中出现的次数，比如说1，4，2，5，3这个序列，长度为3的子序列（1，4，2）（4，2，5）（2，5，3）中，4出现了2次，2出现了3次等，所以问题的关键就变成了如何找每个数字在各个子序列中出现的次数。<br>对于数组中的一个数字来说，它前面的数字可以出现 0 ~ i-1 次，它后面的数字可以出现 0 ~ n-i 次。要是前面的数字出现偶数次，则i后面的数字也应该出现偶数次，前面奇数次，后面同样奇数次。</p><ul><li><p>时间复杂度<br>O(N)</p></li><li><p>空间复杂度<br>O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。&lt;/p&gt;
&lt;p&gt;子数组 定义为原数组中的一个连续子序列。&lt;/p&gt;
&lt;p&gt;请你返回</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>CASE/WHEN嵌套</title>
    <link href="https://liminghua.gitee.io/2021/01/20/CASE-WHEN%E5%B5%8C%E5%A5%97/"/>
    <id>https://liminghua.gitee.io/2021/01/20/CASE-WHEN%E5%B5%8C%E5%A5%97/</id>
    <published>2021-01-20T03:18:12.000Z</published>
    <updated>2021-01-22T06:27:44.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="供方服务交通费结算报表"><a href="#供方服务交通费结算报表" class="headerlink" title="供方服务交通费结算报表"></a>供方服务交通费结算报表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">TB01.name <span class="string">&#x27;责任归属&#x27;</span>, </span><br><span class="line">srv_order.new_vendoridName <span class="string">&#x27;责任供应商&#x27;</span>,</span><br><span class="line">srv_order.new_name <span class="string">&#x27;服务信息单&#x27;</span>,</span><br><span class="line">srv_order.new_productmodel_idName <span class="string">&#x27;产品型号&#x27;</span>,</span><br><span class="line">srv_order.new_userprofile_idName <span class="string">&#x27;VIN码&#x27;</span>,</span><br><span class="line">TB02.name <span class="string">&#x27;人员类型&#x27;</span>,</span><br><span class="line">outline.new_stationidName <span class="string">&#x27;服务网点&#x27;</span>,</span><br><span class="line">outline.new_srv_worker_idName <span class="string">&#x27;完工服务人员&#x27;</span>,</span><br><span class="line">outline.new_name <span class="string">&#x27;派工单号&#x27;</span>,</span><br><span class="line">DATEADD(<span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_arrivetime) <span class="string">&#x27;到位时间&#x27;</span>,</span><br><span class="line">DATEADD(<span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_returntime) <span class="string">&#x27;完工时间&#x27;</span>,</span><br><span class="line">ROUND(<span class="keyword">CONVERT</span>(<span class="type">FLOAT</span>,(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(new_srv_outsideline.new_mileage) <span class="keyword">FROM</span> new_srv_outsideline <span class="keyword">WHERE</span> new_srv_outsideline.new_srv_workorder_id<span class="operator">=</span>srv_order.new_srv_workorderid)),<span class="number">2</span>) <span class="string">&#x27;派工公里数&#x27;</span>,</span><br><span class="line">ROUND(<span class="keyword">CONVERT</span>(<span class="type">FLOAT</span>,(<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(new_srv_outsideline.new_mileage) <span class="keyword">FROM</span> new_srv_outsideline <span class="keyword">WHERE</span> new_srv_outsideline.new_srv_workorder_id<span class="operator">=</span>srv_order.new_srv_workorderid)),<span class="number">2</span>)<span class="operator">*</span><span class="number">2</span><span class="operator">*</span><span class="number">2</span><span class="string">&#x27;交通费&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">CASE</span> isnull(new_returntime,<span class="number">0</span>)</span><br><span class="line"><span class="comment">-- 如果完工时间为null</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> (</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="comment">-- 到位时间也为null则返回null</span></span><br><span class="line"><span class="keyword">WHEN</span> new_arrivetime <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">THEN</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">-- 到位时间早7：00-晚8:00，补贴35元；</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">CONVERT</span> ( <span class="type">VARCHAR</span>, DATEADD( <span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_arrivetime ), <span class="number">108</span>)<span class="operator">&lt;</span><span class="string">&#x27;20:00:00&#x27;</span> <span class="keyword">and</span> <span class="keyword">CONVERT</span> ( <span class="type">VARCHAR</span>, DATEADD( <span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_arrivetime ), <span class="number">108</span>)<span class="operator">&gt;=</span><span class="string">&#x27;07:00:00&#x27;</span> </span><br><span class="line"><span class="keyword">THEN</span> <span class="number">35</span> </span><br><span class="line"><span class="comment">-- 到位时间晚8:00--早7:00，补贴135元；</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="number">135</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 如果完工时间不为null</span></span><br><span class="line"><span class="keyword">ELSE</span> (</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="comment">-- 完工时间早7：00-晚8:00，补贴35元；</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="keyword">CONVERT</span> ( <span class="type">VARCHAR</span>, DATEADD( <span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_returntime ), <span class="number">108</span>)<span class="operator">&lt;</span><span class="string">&#x27;20:00:00&#x27;</span> <span class="keyword">and</span> <span class="keyword">CONVERT</span> ( <span class="type">VARCHAR</span>, DATEADD( <span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_returntime ), <span class="number">108</span>)<span class="operator">&gt;=</span><span class="string">&#x27;07:00:00&#x27;</span></span><br><span class="line">  <span class="keyword">THEN</span> <span class="number">35</span></span><br><span class="line"><span class="comment">-- 完工时间晚8:00--早7:00，补贴135元；</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="number">135</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">END</span> <span class="string">&#x27;食宿补贴&#x27;</span>,</span><br><span class="line"><span class="keyword">null</span> <span class="string">&#x27;交通食补总费&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">new_srv_workorder srv_order <span class="comment">--服务单</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> new_srv_trouble <span class="keyword">on</span> new_srv_trouble.new_srv_workorder_id<span class="operator">=</span>srv_order.new_srv_workorderid</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> new_srv_outsideline outline <span class="keyword">ON</span> outline.new_srv_workorder_id<span class="operator">=</span>srv_order.new_srv_workorderid</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> new_srv_worker srv_worker <span class="keyword">ON</span> srv_worker.new_srv_workerid<span class="operator">=</span>outline.new_srv_worker_id</span><br><span class="line"><span class="keyword">outer</span> apply fn_GetPickListName(<span class="string">&#x27;new_srv_workorder&#x27;</span>,<span class="string">&#x27;new_resp&#x27;</span>,srv_order.new_resp) TB01</span><br><span class="line"><span class="keyword">outer</span> apply fn_GetPickListName(<span class="string">&#x27;new_srv_worker&#x27;</span>,<span class="string">&#x27;new_workertype&#x27;</span>,srv_worker.new_workertype) TB02</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">new_resp <span class="operator">=</span> <span class="number">2</span> <span class="comment">-- 责任归属，供应商</span></span><br><span class="line"><span class="keyword">and</span> new_dealstatus <span class="operator">=</span> <span class="number">11</span> <span class="comment">-- 处理状态，已确认</span></span><br><span class="line"><span class="keyword">and</span> srv_order.StateCode <span class="operator">=</span> <span class="number">0</span> <span class="comment">-- 单据可用</span></span><br><span class="line"><span class="comment">--根据服务单确认时间筛选</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">CONVERT</span>(<span class="type">VARCHAR</span>, DATEADD(<span class="keyword">HOUR</span>, <span class="number">8</span>, srv_order.new_finishtime),<span class="number">120</span>)<span class="operator">&gt;=</span><span class="string">&#x27;2020-05-11 11:44:37&#x27;</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">CONVERT</span>(<span class="type">VARCHAR</span>, DATEADD(<span class="keyword">HOUR</span>, <span class="number">8</span>, srv_order.new_finishtime),<span class="number">120</span>)<span class="operator">&lt;=</span><span class="string">&#x27;2021-01-13 12:46:42&#x27;</span></span><br><span class="line"><span class="comment">-- and CONVERT(VARCHAR, DATEADD(HOUR, 8, srv_order.new_finishtime),120)&gt;= @start</span></span><br><span class="line"><span class="comment">-- and CONVERT(VARCHAR, DATEADD(HOUR, 8, srv_order.new_finishtime),120)&lt;= @end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="CASE-WHEN"><a href="#CASE-WHEN" class="headerlink" title="CASE WHEN"></a>CASE WHEN</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CASE</span> isnull(new_returntime,<span class="number">0</span>)</span><br><span class="line"><span class="comment">-- 如果完工时间为null</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> (</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="comment">-- 到位时间也为null则返回null</span></span><br><span class="line"><span class="keyword">WHEN</span> new_arrivetime <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">THEN</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">-- 到位时间早7：00-晚8:00，补贴35元；</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">CONVERT</span> ( <span class="type">VARCHAR</span>, DATEADD( <span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_arrivetime ), <span class="number">108</span>)<span class="operator">&lt;</span><span class="string">&#x27;20:00:00&#x27;</span> <span class="keyword">and</span> <span class="keyword">CONVERT</span> ( <span class="type">VARCHAR</span>, DATEADD( <span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_arrivetime ), <span class="number">108</span>)<span class="operator">&gt;=</span><span class="string">&#x27;07:00:00&#x27;</span> </span><br><span class="line"><span class="keyword">THEN</span> <span class="number">35</span> </span><br><span class="line"><span class="comment">-- 到位时间晚8:00--早7:00，补贴135元；</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="number">135</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 如果完工时间不为null</span></span><br><span class="line"><span class="keyword">ELSE</span> (</span><br><span class="line"><span class="keyword">CASE</span> </span><br><span class="line"><span class="comment">-- 完工时间早7：00-晚8:00，补贴35元；</span></span><br><span class="line">  <span class="keyword">WHEN</span> <span class="keyword">CONVERT</span> ( <span class="type">VARCHAR</span>, DATEADD( <span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_returntime ), <span class="number">108</span>)<span class="operator">&lt;</span><span class="string">&#x27;20:00:00&#x27;</span> <span class="keyword">and</span> <span class="keyword">CONVERT</span> ( <span class="type">VARCHAR</span>, DATEADD( <span class="keyword">HOUR</span>, <span class="number">8</span>, outline.new_returntime ), <span class="number">108</span>)<span class="operator">&gt;=</span><span class="string">&#x27;07:00:00&#x27;</span></span><br><span class="line">  <span class="keyword">THEN</span> <span class="number">35</span></span><br><span class="line"><span class="comment">-- 完工时间晚8:00--早7:00，补贴135元；</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="number">135</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">END</span> <span class="string">&#x27;食宿补贴&#x27;</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>嵌套内的子CASE要写 <strong>END</strong> ,不然会无法识别子case的结束点导致语法错误.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;供方服务交通费结算报表&quot;&gt;&lt;a href=&quot;#供方服务交通费结算报表&quot; class=&quot;headerlink&quot; title=&quot;供方服务交通费结算报表&quot;&gt;&lt;/a&gt;供方服务交通费结算报表&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    <category term="工作" scheme="https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="数据库" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="SQL语法" scheme="https://liminghua.gitee.io/tags/SQL%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>628.三个数的最大乘积</title>
    <link href="https://liminghua.gitee.io/2021/01/19/628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"/>
    <id>https://liminghua.gitee.io/2021/01/19/628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</id>
    <published>2021-01-19T02:27:25.000Z</published>
    <updated>2021-01-22T06:15:18.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p>示例 1:</p><blockquote><p>输入: [1,2,3]<br>输出: 6</p></blockquote><p>示例 2:</p><blockquote><p>输入: [1,2,3,4]<br>输出: 24</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[nums.length - <span class="number">1</span>], nums[nums.length - <span class="number">1</span>] * nums[nums.length - <span class="number">2</span>] * nums[nums.length - <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>思路<br>我们将数组进行升序排序，如果数组中所有的元素都是非负数，那么答案即为最后三个元素的乘积。</li></ul><p>如果数组中出现了负数，那么我们还需要考虑乘积中包含负数的情况，显然选择最小的两个负数和最大的一个正数是最优的，即为前两个元素与最后一个元素的乘积。</p><p>上述两个结果中的较大值就是答案。注意我们可以不用判断数组中到底有没有正数，0 或者负数，因为上述两个结果实际上已经包含了所有情况，最大值一定在其中。</p><ul><li><p>时间复杂度<br>O(NlogN)，其中 NN 是数组的长度。</p></li><li><p>空间复杂度<br>O(logN)，为排序使用的空间。</p></li></ul><h3 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = n;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= min2) &#123;     <span class="comment">// n lies between min1 and min2</span></span><br><span class="line">                min2 = n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= max1) &#123;            <span class="comment">// n is greater than max1, max2 and max3</span></span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = n;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= max2) &#123;     <span class="comment">// n lies betweeen max1 and max2</span></span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = n;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= max3) &#123;     <span class="comment">// n lies betwen max2 and max3</span></span><br><span class="line">                max3 = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(min1 * min2 * max1, max1 * max2 * max3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>思路<br>在方法一中，我们实际上只要求出数组中最大的三个数以及最小的两个数，因此我们可以不用排序，用线性扫描直接得出这五个数。<br>min1 &lt;= min2 &lt;= max3 &lt;= max2 &lt;= max1</p></li><li><p>时间复杂度<br>O(N)</p></li><li><p>空间复杂度<br>O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>977.有序数组的平方</title>
    <link href="https://liminghua.gitee.io/2021/01/19/977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <id>https://liminghua.gitee.io/2021/01/19/977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</id>
    <published>2021-01-19T02:26:44.000Z</published>
    <updated>2021-01-22T06:15:33.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1：</p><blockquote><p>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; ++i) &#123;</span><br><span class="line">            ans[i] = A[i] * A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度<br>O(nlogn)，其中 n 是数组 A 的长度。</p></li><li><p>空间复杂度<br>O(logn)。除了存储答案的数组以外，需要 O(logn) 的栈空间进行排序。</p></li></ul><h3 id="双指针（中位向两边）"><a href="#双指针（中位向两边）" class="headerlink" title="双指针（中位向两边）"></a>双指针（中位向两边）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> negative = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//找正负数分界点点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                negative = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, i = negative, j = negative + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//存在负数</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//右边遍历完，j指针向左移动</span></span><br><span class="line">                ans[index] = A[j] * A[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line"><span class="comment">//左边遍历完毕，i指针向右移动</span></span><br><span class="line">                ans[index] = A[i] * A[i];</span><br><span class="line">                --i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] * A[i] &lt; A[j] * A[j]) &#123;</span><br><span class="line"><span class="comment">//i指向值的平方小，存入，指针向左移动</span></span><br><span class="line">                ans[index] = A[i] * A[i];</span><br><span class="line">                --i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//j指针指向值的平方小，存入，指针向右移动</span></span><br><span class="line">                ans[index] = A[j] * A[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//结果集指向下一位</span></span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>显然，如果数组 A 中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；如果数组 A 中的所有数都是负数，那么将每个数平方后，数组会保持降序。</li></ul><p>这样一来，如果我们能够找到数组 A 中负数与非负数的分界线，那么就可以用类似「归并排序」的方法了。具体地，我们设 neg 为数组 A 中负数与非负数的分界线，也就是说，A[0] 到 A[neg] 均为负数，而  A[neg+1] 到 A[n−1] 均为非负数。当我们将数组 A 中的数平方后，那么 A[0] 到 A[neg] 单调递减，A[neg+1] 到 A[n−1] 单调递增。</p><p>由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置 neg 和 neg+1，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。</p><ul><li><p>时间复杂度<br>O(n)，其中 n 是数组 A 的长度</p></li><li><p>空间复杂度<br>O(1)</p></li></ul><h3 id="双指针（两边至中间）"><a href="#双指针（两边至中间）" class="headerlink" title="双指针（两边至中间）"></a>双指针（两边至中间）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>, pos = n - <span class="number">1</span>; i &lt;= j;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] * A[i] &gt; A[j] * A[j]) &#123;</span><br><span class="line">                ans[pos] = A[i] * A[i];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[pos] = A[j] * A[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            --pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>思路<br>同样地，可以使用两个指针分别指向位置 0 和 n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况，</p></li><li><p>时间复杂度<br>O(n)，其中 n 是数组 A 的长度</p></li><li><p>空间复杂度<br>O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://liminghua.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>1550.存在连续三个奇数的数组</title>
    <link href="https://liminghua.gitee.io/2021/01/19/1550-%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://liminghua.gitee.io/2021/01/19/1550-%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2021-01-19T02:26:22.000Z</published>
    <updated>2021-01-22T06:15:42.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。</p><p>示例 1：</p><blockquote><p>输入：arr = [2,6,4,1]<br>输出：false<br>解释：不存在连续三个元素都是奇数的情况。</p></blockquote><p>示例 2：</p><blockquote><p>输入：arr = [1,2,34,3,4,5,7,23,12]<br>输出：true<br>解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public boolean threeConsecutiveOdds(int[] arr) &#123;</span></span><br><span class="line"><span class="comment">//         int n = arr.length;</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt;= n - 3; ++i) &#123;</span></span><br><span class="line"><span class="comment">//             //a&amp;1   = 0 偶数</span></span><br><span class="line"><span class="comment">//             //a&amp;1   = 1 奇数</span></span><br><span class="line"><span class="comment">//             //任何偶数二进制第一位数必定0，而奇数必定是1，而1的二进制就是1</span></span><br><span class="line"><span class="comment">//             if ((arr[i] &amp; 1) != 0 &amp;&amp; (arr[i + 1] &amp; 1) != 0 &amp;&amp; (arr[i + 2] &amp; 1) != 0) &#123;</span></span><br><span class="line"><span class="comment">//                 return true;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return false;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                temp.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.size()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>思路<br>位运算判断奇偶数</p></li><li><p>时间复杂度<br>O(N)</p></li><li><p>空间复杂度<br>O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>删除文件夹没有权限</title>
    <link href="https://liminghua.gitee.io/2021/01/18/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/"/>
    <id>https://liminghua.gitee.io/2021/01/18/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/</id>
    <published>2021-01-18T14:44:04.000Z</published>
    <updated>2021-01-22T06:22:55.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>替换服务器上网站静态资源时提示：<br>您需要来自xxx的权限才能对此文件夹进行更改</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>移动文件夹到C盘ProgramFiles,右键删除即可。</p><p><img src="2.png" class="lazyload" data-srcset="2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h2&gt;&lt;p&gt;替换服务器上网站静态资源时提示：&lt;br&gt;您需要来自xxx的权限才能对此文件夹进行更改&lt;/p&gt;</summary>
      
    
    
    
    <category term="工作" scheme="https://liminghua.gitee.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="踩坑" scheme="https://liminghua.gitee.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
    <category term="删除文件" scheme="https://liminghua.gitee.io/tags/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"/>
    
    <category term="系统权限" scheme="https://liminghua.gitee.io/tags/%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>17.10主要元素</title>
    <link href="https://liminghua.gitee.io/2021/01/18/17-10%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/"/>
    <id>https://liminghua.gitee.io/2021/01/18/17-10%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/</id>
    <published>2021-01-18T03:24:35.000Z</published>
    <updated>2021-01-22T06:10:19.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。</p><p>示例 1：</p><blockquote><p>输入：[1,2,5,9,5,9,5,5,5]<br>输出：5 </p></blockquote><p>示例 2：</p><blockquote><p>输入：[3,2]<br>输出：-1 </p></blockquote><p>示例 3：</p><blockquote><p>输入：[2,2,1,1,1,2,2]<br>输出：2</p></blockquote><p>说明：</p><blockquote><p>你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//执行用时：</span></span><br><span class="line"><span class="comment">//21 ms, 在所有 Java 提交中击败了12.59%的用户</span></span><br><span class="line"><span class="comment">//内存消耗：</span></span><br><span class="line"><span class="comment">//43.9 MB, 在所有 Java 提交中击败了8.10%的用户</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; temp = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.get(nums[i])==<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.put(nums[i],temp.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.get(nums[i])&gt;length/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>思路<br>遍历列表，将元素重复出现的次数放入map并进行比对,但不符合题目要求空间复杂度O(1)</p></li><li><p>时间复杂度<br>O(N)</p></li><li><p>空间复杂度<br>O(N)</p></li></ul><h3 id="摩尔投票算法"><a href="#摩尔投票算法" class="headerlink" title="摩尔投票算法"></a>摩尔投票算法</h3><ul><li>用时最少</li></ul><p>执行用时：<br>1 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：<br>41.6 MB, 在所有 Java 提交中击败了67.28%的用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行用时：</span></span><br><span class="line"><span class="comment">//1 ms, 在所有 Java 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">//内存消耗：</span></span><br><span class="line"><span class="comment">//41.6 MB, 在所有 Java 提交中击败了67.28%的用户</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录元素出现次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//temp，存放需要进行比对的上一个元素</span></span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="comment">//第一个元素或者说抵消后出现的第一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//计数1</span></span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将元素值存入temp</span></span><br><span class="line">                k = nums[i];  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//元素重复出现计数加1</span></span><br><span class="line">                <span class="keyword">if</span>(k == nums[i]) ++count; </span><br><span class="line"><span class="comment">//元素不重复抵消一位(减1)</span></span><br><span class="line">                <span class="keyword">else</span> --count; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//若全部抵消，则不存在占比超过一半的元素</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//验证</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对元素进行计数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(k == nums[i]) count++;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//占比超过一半</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span> * count &gt; nums.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> k;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>内存消耗最少</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> majority = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == majority) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                    majority = nums[i];</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == majority) &#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a &gt; nums.length / <span class="number">2</span> ? majority : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路</li></ul><p>摩尔投票算法是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。</p><ul><li><p>时间复杂度<br>O(2N) = O(N)</p></li><li><p>空间复杂度<br>O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquo</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>867.转置矩阵</title>
    <link href="https://liminghua.gitee.io/2021/01/17/867-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/"/>
    <id>https://liminghua.gitee.io/2021/01/17/867-%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</id>
    <published>2021-01-17T09:01:22.000Z</published>
    <updated>2021-01-22T06:15:30.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给定一个矩阵 A， 返回 A 的转置矩阵。</p><p>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p> </p><p>示例 1：</p><blockquote><p>输入：[[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[1,4,7],[2,5,8],[3,6,9]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：[[1,2,3],[4,5,6]]<br>输出：[[1,4],[2,5],[3,6]]</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] transpose(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="comment">//矩阵列，行</span></span><br><span class="line">        <span class="keyword">int</span> R = A.length, C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//翻转后的新矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[C][R];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                ans[c][r] = A[r][c];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路<br>转置矩阵就是根据对角线翻转矩阵，行变成列，列变成行。（grd线性代数）<br>尺寸为 R x C 的矩阵 A 转置后会得到尺寸为 C x R 的矩阵 ans，对此有 ans[c][r] = A[r][c]。<br>初始化一个新的矩阵 ans 来表示答案。然后，复制矩阵的每个条目。</li></ul><ul><li><p>时间复杂度：<br>O(R∗C)，其中 R 和 C 是给定矩阵 A 的行数和列数。</p></li><li><p>空间复杂度<br>O(R*C)，也就是答案所使用的空间。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给定一个矩阵 A， 返回 A 的转置矩阵。&lt;/p&gt;
&lt;p&gt;矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://liminghua.gitee.io/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>1232.缀点成线</title>
    <link href="https://liminghua.gitee.io/2021/01/17/1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/"/>
    <id>https://liminghua.gitee.io/2021/01/17/1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/</id>
    <published>2021-01-17T08:33:21.000Z</published>
    <updated>2021-01-22T06:15:39.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</p><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。</p><p>示例 1：<br><img src="1.jpg" class="lazyload" data-srcset="1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><blockquote><p>输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]<br>输出：true</p></blockquote><p>示例 2：<br><img src="2.jpg" class="lazyload" data-srcset="2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><blockquote><p>输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]<br>输出：false</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; coordinates.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res1 = (coordinates[i][<span class="number">0</span>] - coordinates[i - <span class="number">1</span>][<span class="number">0</span>]) * (coordinates[i + <span class="number">1</span>][<span class="number">1</span>] - coordinates[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> res2 = (coordinates[i + <span class="number">1</span>][<span class="number">0</span>] - coordinates[i][<span class="number">0</span>]) * (coordinates[i][<span class="number">1</span>] - coordinates[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(res1 != res2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> deltaX = coordinates[<span class="number">0</span>][<span class="number">0</span>], deltaY = coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> n = coordinates.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            coordinates[i][<span class="number">0</span>] -= deltaX;</span><br><span class="line">            coordinates[i][<span class="number">1</span>] -= deltaY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = coordinates[<span class="number">1</span>][<span class="number">1</span>], B = -coordinates[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = coordinates[i][<span class="number">0</span>], y = coordinates[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (A * x + B * y != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkStraightLine</span><span class="params">(<span class="keyword">int</span>[][] coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] c = coordinates;            <span class="comment">//简便缩写</span></span><br><span class="line">        <span class="keyword">if</span>(c == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;         <span class="comment">//无任何点时，直线不存在</span></span><br><span class="line">        <span class="keyword">if</span>(c.length == <span class="number">1</span> || c.length ==<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;        <span class="comment">//只有一个点或者两个点时直接返回true</span></span><br><span class="line">        <span class="comment">//若在一条直线上，斜率必相等</span></span><br><span class="line">        <span class="comment">//即(y2-y1)/(x2-x1)=(yi-y2)/(xi-x2)</span></span><br><span class="line">        <span class="comment">//当直线平行y轴时有除零风险，固交叉相乘改变为乘法</span></span><br><span class="line">        <span class="comment">//即(y2-y1)(xi-x2)=(yi-y2)(x2-x1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; c.length;i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>((c[<span class="number">1</span>][<span class="number">1</span>]-c[<span class="number">0</span>][<span class="number">1</span>]) * (c[i][<span class="number">0</span>]-c[<span class="number">1</span>][<span class="number">0</span>]) == (c[i][<span class="number">1</span>]-c[<span class="number">1</span>][<span class="number">1</span>]) * (c[<span class="number">1</span>][<span class="number">0</span>]-c[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//斜率匹配，继续循环</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不匹配，不为直线</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//匹配完毕，任意节点斜率符合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>由斜率公式得<br>(y1-y0)/(x1-x0)=(yi-y0)/(xi-x0)<br>防止除0，变换成相乘的形式<br>(y1-y0)<em>(xi-x0)==(x1-x0)</em>(yi-y0)</li></ul><p>尽量避免 y1-y0/x1-x0等求斜率或者除法比较比值的操作，而换成乘法来比较，例如求y=kx+b的解析式或者题解中的方式，因为乘法的开销远小于除法</p><ul><li><p>时间复杂度：<br>O(n)，其中 n 是数组中的元素数量。</p></li><li><p>空间复杂度<br>O(1)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="几何" scheme="https://liminghua.gitee.io/tags/%E5%87%A0%E4%BD%95/"/>
    
    <category term="数学" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>26.删除排序数组中的重复项</title>
    <link href="https://liminghua.gitee.io/2021/01/16/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://liminghua.gitee.io/2021/01/16/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2021-01-16T01:37:45.000Z</published>
    <updated>2021-01-22T06:10:22.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给定一个排序数组，你需要在 <b>原地</b> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <b>原地</b> 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>示例 1:</p><blockquote><p>给定数组 nums = [1,1,2], </p></blockquote><blockquote><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p></blockquote><blockquote><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。 </p></blockquote><p>说明:</p><blockquote><p>为什么返回数值是整数，但输出的答案是数组呢?</p></blockquote><blockquote><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p></blockquote><blockquote><p>你可以想象内部操作如下:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="双（快慢）指针"><a href="#双（快慢）指针" class="headerlink" title="双（快慢）指针"></a>双（快慢）指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>数组完成排序后，可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，就增加 j 以跳过重复项。<br>当遇到 nums[i] ！= nums[j] 时，跳过重复项的运行已经结束，因此必须把 nums[j] 的值复制到 nums[i + 1]。然后递增 i，接着再次重复相同的过程，直到 j 到达数组的末尾为止。</li></ul><ul><li><p>时间复杂度<br>时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。</p></li><li><p>空间复杂度<br>空间复杂度：O(1)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给定一个排序数组，你需要在 &lt;b&gt;原地&lt;/b&gt; 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://liminghua.gitee.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>189.旋转数组</title>
    <link href="https://liminghua.gitee.io/2021/01/15/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>https://liminghua.gitee.io/2021/01/15/189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2021-01-15T06:34:34.000Z</published>
    <updated>2021-01-22T06:14:59.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>进阶：</p><blockquote><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p></blockquote><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="使用额外的数组"><a href="#使用额外的数组" class="headerlink" title="使用额外的数组"></a>使用额外的数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">if</span>(k&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                temp[i] = nums[nums.length-k+i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.arraycopy(nums, <span class="number">0</span>, temp, k, nums.length-k);</span><br><span class="line">            System.arraycopy(temp, <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;nums.length&amp;&amp;nums.length!=<span class="number">1</span>)&#123;</span><br><span class="line">            k=k%nums.length;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                temp[i] = nums[nums.length-k+i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.arraycopy(nums, <span class="number">0</span>, temp, k, nums.length-k);</span><br><span class="line">            System.arraycopy(temp, <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            newArr[(i + k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(newArr, <span class="number">0</span>, nums, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>使用额外的数组来将每个元素放至正确的位置。用 n 表示数组的长度，遍历原数组，将原数组下标为 i 的元素放至新数组下标为 (i+k)modn 的位置，最后将新数组拷贝至原数组即可。</li></ul><ul><li><p>时间复杂度<br>时间复杂度：O(n)，其中 n 为数组的长度。</p></li><li><p>空间复杂度<br>空间复杂度：O(n)。</p></li></ul><h3 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">            end -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>思路<br>该方法基于如下的事实：当我们将数组的元素向右移动 kk 次后，尾部 kmodn 个元素会移动至数组头部，其余元素向后移动 kmodn 个位置。</li></ul><p>该方法为数组的翻转：可以先将所有元素翻转，这样尾部的 kmodn 个元素就被移至数组头部，然后再翻转 [0,kmodn−1] 区间的元素和 [kmodn,n−1] 区间的元素即能得到最后的答案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums &#x3D; &quot;-----&gt;--&gt;&quot;; k &#x3D;3</span><br><span class="line">result &#x3D; &quot;--&gt;-----&gt;&quot;;</span><br><span class="line"></span><br><span class="line">reverse &quot;-----&gt;--&gt;&quot;we can get &quot;&lt;--&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;--&quot; we can get &quot;--&gt;&lt;-----&quot;</span><br><span class="line">reverse &quot;&lt;-----&quot; we can get &quot;--&gt;-----&gt;&quot;</span><br><span class="line">this visualization help me figure it out :)</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中 n 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)=O(n)。</p><p>空间复杂度：O(1)。</p><h3 id="环状替换"><a href="#环状替换" class="headerlink" title="环状替换"></a>环状替换</h3><blockquote><p>官方解答最优解法 暂时没整明白</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q&quot;&gt;&lt;a href=&quot;#Q&quot; class=&quot;headerlink&quot; title=&quot;Q&quot;&gt;&lt;/a&gt;Q&lt;/h2&gt;&lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt;进阶：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽可能想出更多</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://liminghua.gitee.io/categories/LeetCode/"/>
    
    
    <category term="数组" scheme="https://liminghua.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
